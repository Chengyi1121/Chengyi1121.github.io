

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="0.基本操作1.使用Clion开发Rust​    需要在系统的path里添加clion的bin路径，然后就可以通过命令行使用clion .来打开项目了。 2.使用cargo创建库项目​    cargo new add –lib 3.打印地址123456789101112131415161718192021fn main() &amp;#123;    let o &#x3D; Obj::new(1, 2, 3)">
<meta property="og:type" content="article">
<meta property="og:title" content="rust-lang">
<meta property="og:url" content="http://example.com/2022/02/14/rust-lang/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="0.基本操作1.使用Clion开发Rust​    需要在系统的path里添加clion的bin路径，然后就可以通过命令行使用clion .来打开项目了。 2.使用cargo创建库项目​    cargo new add –lib 3.打印地址123456789101112131415161718192021fn main() &amp;#123;    let o &#x3D; Obj::new(1, 2, 3)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220114153100948.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220114153226641.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220114182046202.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220114181038063.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220114181940185.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220114182405990.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115132259157.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115132743008.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115132811413.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115133335999.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115133353197.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115134031494.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115135319262.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115140318148.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115141807954.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115142315424.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115144940387.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115144751616.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220115163757974.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220116100625209.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220116102055982.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220116103815978.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220116121716763.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220116142000246.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220116152252174.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220119202214447.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220119202225682.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220120223838199.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220121151726938.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220122155108279.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220123150617915.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220123172820248.png">
<meta property="og:image" content="http://example.com/2022/02/14/rust-lang/image-20220214142148258.png">
<meta property="article:published_time" content="2022-02-14T06:24:47.169Z">
<meta property="article:modified_time" content="2022-02-14T06:24:35.225Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/02/14/rust-lang/image-20220114153100948.png">
  
  
  <title>rust-lang - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="rust-lang">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-14 14:24" pubdate>
        February 14, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      45k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      375 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">rust-lang</h1>
            
            <div class="markdown-body">
              <h1 id="0-基本操作"><a href="#0-基本操作" class="headerlink" title="0.基本操作"></a>0.基本操作</h1><h2 id="1-使用Clion开发Rust"><a href="#1-使用Clion开发Rust" class="headerlink" title="1.使用Clion开发Rust"></a>1.使用Clion开发Rust</h2><p>​    需要在系统的path里添加clion的bin路径，然后就可以通过命令行使用clion .来打开项目了。</p>
<h2 id="2-使用cargo创建库项目"><a href="#2-使用cargo创建库项目" class="headerlink" title="2.使用cargo创建库项目"></a>2.使用cargo创建库项目</h2><p>​    cargo new add –lib</p>
<h2 id="3-打印地址"><a href="#3-打印地址" class="headerlink" title="3.打印地址"></a>3.打印地址</h2><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">o</span> = Obj::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">adr</span> = &amp;o <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> Obj <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0x&#123;:x&#125;&quot;</span>, adr);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Obj</span> &#123;<br>    val1: <span class="hljs-type">u8</span>,<br>    val2: <span class="hljs-type">u8</span>,<br>    val3: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Obj</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(v1: <span class="hljs-type">u8</span>, v2: <span class="hljs-type">u8</span>, v3: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> Obj &#123;<br>        Obj &#123;<br>            val1: v1,<br>            val2: v2,<br>            val3: v3,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="1-rust简介"><a href="#1-rust简介" class="headerlink" title="1 rust简介"></a>1 rust简介</h1><h2 id="1-1-基本特性"><a href="#1-1-基本特性" class="headerlink" title="1.1 基本特性"></a>1.1 基本特性</h2><p>特性</p>
<ul>
<li><p>运行时速度快</p>
</li>
<li><p>内存安全</p>
</li>
<li><p>并发</p>
<p>  rust是一门安全的语言，表现在类型安全和内存安全（横向对比c&#x2F;c++），同时性能也很好，因为没有GC（对比java），同时在设计的时候就考虑了多核处理器，支持并发，火狐公司的一个内核就是用rust写的，全并发执行。</p>
<p>  rust采的命名方法是：蛇形命名法，也就是字母小写单词之间加下划线</p>
<p>  rust的命令有rustc和rustup，rustc后面的c的意思是编译器。</p>
</li>
</ul>
<h2 id="1-2-命令行-vscode构建项目"><a href="#1-2-命令行-vscode构建项目" class="headerlink" title="1.2 命令行+vscode构建项目"></a>1.2 命令行+vscode构建项目</h2><p>步骤</p>
<ul>
<li>mkdir hello_rust创建工程目录</li>
<li>cd h*进入目录</li>
<li>code .用vscode打开该工程</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">常用的windows cmd命令<br><span class="hljs-number">1</span>. cd / -<span class="hljs-punctuation">-&gt;</span> 进入首盘，如c盘d盘<br><span class="hljs-number">2</span>. cd .. -<span class="hljs-punctuation">-&gt;</span> 进入上一级目录<br><span class="hljs-number">3</span>. dir -<span class="hljs-punctuation">-&gt;</span> 查看当当前目录下的文件 dir /a 是查看所有文件，包括隐藏文件<br><span class="hljs-number">4</span>. 可以用help cd查看cd的用法<br></code></pre></td></tr></table></figure>

<h2 id="1-3-编写hello-world程序"><a href="#1-3-编写hello-world程序" class="headerlink" title="1.3 编写hello world程序"></a>1.3 编写hello world程序</h2><ul>
<li>fn表示函数声明</li>
<li>rust采用的缩进不是tab，而是四个空格</li>
<li>println!是rust的宏，也就是rust micro</li>
<li>rust是预先编译的语言，也就是先编译好，然后生成二进制文件，可直接交给别人使用，而无需rust环境</li>
<li>rustc只适用于简单的rust文件，用cargo</li>
</ul>
<h2 id="1-4-cargo创建工程"><a href="#1-4-cargo创建工程" class="headerlink" title="1.4 cargo创建工程"></a>1.4 cargo创建工程</h2><div class="code-wrapper"><pre><code class="hljs">cargo是rust的创建及包管理工具

rust里代码的包称为crate
</code></pre></div>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">windows cmd<br><span class="hljs-number">1</span>.rmdir xxx -- remove dir<br><span class="hljs-number">2</span>.del xxx -- delete file<br></code></pre></td></tr></table></figure>

<p>cargo.toml文件</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.toml是cargo的配置文件<br><span class="hljs-number">2</span>.前一部分是项目的信息，如项目名称，package，版本信息作者等<br><span class="hljs-number">3</span>.后部分是项目依赖<br></code></pre></td></tr></table></figure>

<p>顶层目录可放置的信息</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.README文件<br><span class="hljs-number">2</span>.许可信息<br><span class="hljs-number">3</span>.配置文件<br><span class="hljs-number">4</span>.其它与源程序无关的东西<br></code></pre></td></tr></table></figure>

<div class="code-wrapper"><pre><code class="hljs">当没有用cargo创建工程时，可以直接把文件拷贝到src下，然后再在顶层目录下编写一个cargo.toml文件即可
</code></pre></div>
<p>cargo.lock</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.负责追寻项目依赖的准确版本<br><span class="hljs-number">2</span>.不需要去修改这个文件<br></code></pre></td></tr></table></figure>

<p>使用cargo运行项目</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.cargo run会编译当前工程的main.rs及相关文件，然后再运行生成的exe文件<br><span class="hljs-number">2</span>.如果源代码没有更改过的话，就不编译了，之既然运行exe<br></code></pre></td></tr></table></figure>

<p>cargo check调试检查项目</p>
<div class="code-wrapper"><pre><code class="hljs">一般在开发的时候都是用的这个命令来进行检查调试，因为更快。

只有要生成文件的时候才会使用run/build指令

如果要发布的话，使用cargo build --release，这样编译的时候时间更久，会进行优化，提高编译出来的程序的性能
</code></pre></div>
<br>

<h1 id="2-rust基本语法"><a href="#2-rust基本语法" class="headerlink" title="2 rust基本语法"></a>2 rust基本语法</h1><h2 id="2-1-获取控制台输入"><a href="#2-1-获取控制台输入" class="headerlink" title="2.1 获取控制台输入"></a>2.1 获取控制台输入</h2><h3 id="1-输入"><a href="#1-输入" class="headerlink" title="1.输入"></a>1.输入</h3><div class="code-wrapper"><pre><code class="hljs">std里提供了一个io，也就是标准输入输出，然后io里有一个关联函数叫stdin，是io里关于输入输出的输入那一部分，会返回一个句柄。然后stdin里有一个方法是read_line，读取命令行中的一行，这个方法可能抛出异常，所以该有一个except函数。

read_line会返回一个io::Result类型，也就是枚举类型，有两个值，一个是OK，另一个是Err，如果返回Err的话，就会中断当前程序，执行except那一部分。
</code></pre></div>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::io::stdin.<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> string).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;exception message&quot;</span>);<br></code></pre></td></tr></table></figure>

<div class="code-wrapper"><pre><code class="hljs">关联函数类似于java中的静态方法。
</code></pre></div>
<h3 id="2-输出"><a href="#2-输出" class="headerlink" title="2.输出"></a>2.输出</h3><div class="code-wrapper"><pre><code class="hljs">println!宏
</code></pre></div>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;这是一个数字：&#123;&#125;&quot;</span>, number);<br></code></pre></td></tr></table></figure>

<div class="code-wrapper"><pre><code class="hljs">&#123;&#125;中的就是number。
</code></pre></div>
<h2 id="2-2-添加外部依赖包rand（修改toml文件）"><a href="#2-2-添加外部依赖包rand（修改toml文件）" class="headerlink" title="2.2 添加外部依赖包rand（修改toml文件）"></a>2.2 添加外部依赖包rand（修改toml文件）</h2><div class="code-wrapper"><pre><code class="hljs">在cargo.toml中添加bin结点。
</code></pre></div>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;guess_game&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang/.org/cargo/reference/manifest.html</span><br><span class="hljs-comment"># 下面的部分是添加的代码，其中name是你的项目名称</span><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;guess_game&quot;</span><br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;src/test.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">rand</span> = <span class="hljs-string">&quot;0.5.0&quot;</span><br></code></pre></td></tr></table></figure>

<div class="code-wrapper"><pre><code class="hljs">然后cargo就会自动下载依赖包了。

为什么会自动下载包？

其实，是因为打开了rust server，这样就会自动去扫描toml里的依赖，检查版本并且及时下载对应的版本。

如果我们关闭这个server，那么更新toml中的依赖，工程文件中的包并不会更新，因为工程文件会去lock文件中去找到并使用对应的版本。这个时候不仅要修改toml，还要进行生级，也就是输入指令：cargo update。

但事实上使用这个指令需要换源，因为直接用的话，会提示超时，因为下载的源好像是github，需要用steam++加速或者换源。
</code></pre></div>
<h2 id="2-3-使用枚举进行比较"><a href="#2-3-使用枚举进行比较" class="headerlink" title="2.3 使用枚举进行比较"></a>2.3 使用枚举进行比较</h2><div class="code-wrapper"><pre><code class="hljs">进行比较需要用到std下的cmp中的Ordering这个枚举类型。
</code></pre></div>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br></code></pre></td></tr></table></figure>

<div class="code-wrapper"><pre><code class="hljs">进行枚举时需要注意一下两个问题：
</code></pre></div>
<ul>
<li>类型一致</li>
<li>使用时大小等都得写全</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num2</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">match</span> num1.<span class="hljs-title function_ invoke__">cmp</span>(&amp;num2) &#123;<br>    Ordering::Equal =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;=&quot;</span>),<br>    Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt;&quot;</span>),<br>    Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&lt;&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-4-处理异常"><a href="#2-4-处理异常" class="headerlink" title="2.4 处理异常"></a>2.4 处理异常</h2><div class="code-wrapper"><pre><code class="hljs">前面我们使用的是except方法来处理异常，如parse将字符串转换成数字时，会返回一个Result，根据这个类型是OK还是Err来判断是否执行except中的内容。如果Result中判定为Err的话，会直接中断当前程序，然后程序结束（崩溃）。这样我们的程序一遇到非法输入就崩溃，并不健壮。

所以这里我们用了上一节中的match模式匹配来处理这个问题。如果是OK的话，就执行ok的代码块，如果是Rrr的话再做相应的应对措施（如提示用户重新输入）
</code></pre></div>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> num.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>    <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is not valid input, try again&quot;</span>, num.<span class="hljs-title function_ invoke__">trim</span>());<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;,<br>&#125;; <span class="hljs-comment">//将字符串转为u32类型，无符号整数32位</span><br></code></pre></td></tr></table></figure>



<h1 id="3-变量及控制流"><a href="#3-变量及控制流" class="headerlink" title="3 变量及控制流"></a>3 变量及控制流</h1><h2 id="3-1变量"><a href="#3-1变量" class="headerlink" title="3.1变量"></a>3.1变量</h2><h3 id="3-1-1-不可变变量"><a href="#3-1-1-不可变变量" class="headerlink" title="3.1.1 不可变变量"></a>3.1.1 不可变变量</h3><p>​    使用let关键字声明，将等号右边的值绑定到等号左侧。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = -<span class="hljs-number">1</span>;<br><span class="hljs-comment">// num = 2;错误，不可变变量无法二次绑定</span><br></code></pre></td></tr></table></figure>

<h3 id="3-1-2-可变变量"><a href="#3-1-2-可变变量" class="headerlink" title="3.1.2 可变变量"></a>3.1.2 可变变量</h3><p>​    mutable，可变化的，还是使用let声明</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">1</span>;<br>num = num + <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>

<h3 id="3-1-3-常量"><a href="#3-1-3-常量" class="headerlink" title="3.1.3 常量"></a>3.1.3 常量</h3><p>​        常量用const声明（constant的意思），常量必须显式声明数据类型，无法自动推断。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> MAX_LEN: <span class="hljs-type">u8</span> = <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure>

<p>​    其实工程中大多数都是不可变类型的变量。</p>
<h2 id="3-2-shadow机制"><a href="#3-2-shadow机制" class="headerlink" title="3.2 shadow机制"></a>3.2 shadow机制</h2><p>​    变量可以被隐藏。如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-string">&quot;ssss&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = string.<span class="hljs-title function_ invoke__">len</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = string + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;string is &#123;&#125;&quot;</span>, string);<br></code></pre></td></tr></table></figure>

<p>​    此机制是为了避免以下情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name_string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jack&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">name_length</span> <span class="hljs-operator">=</span> name_string.length();<br></code></pre></td></tr></table></figure>



<h2 id="3-3-标量类型"><a href="#3-3-标量类型" class="headerlink" title="3.3 标量类型"></a>3.3 标量类型</h2><h3 id="3-3-1-整数"><a href="#3-3-1-整数" class="headerlink" title="3.3.1 整数"></a>3.3.1 整数</h3><p>​    整数的类型：</p>
<p>​                                                     <img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220114153100948.png" alt="image-20220114153100948"></p>
<p>​    其中isize和usize和机器的位数有关，一般不用。</p>
<p>​    整数的字面量表示：</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220114153226641.png" alt="image-20220114153226641"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">adr</span> = <span class="hljs-number">0x1234_5678u64</span><span class="hljs-comment">//无符号64位16进制数</span><br></code></pre></td></tr></table></figure>

<p>​    整数的默认类型一般是i32，比较快。    </p>
<p>​    下面是整数溢出的情况：</p>
<ul>
<li>调试模式下：会发生panic（恐慌）</li>
<li>发布模式：不发生panic，选择环绕操作，即256&#x3D;0</li>
</ul>
<h3 id="3-3-2-浮点"><a href="#3-3-2-浮点" class="headerlink" title="3.3.2 浮点"></a>3.3.2 浮点</h3><p>​    两种类型：</p>
<ul>
<li>f64</li>
<li>f32</li>
</ul>
<p>​    一般是采用f64</p>
<h3 id="3-3-3-bool类型"><a href="#3-3-3-bool类型" class="headerlink" title="3.3.3 bool类型"></a>3.3.3 bool类型</h3><p>​    true或者false。</p>
<p>​    占用大小一个Byte</p>
<p>​    为什么不用一个bit？因为如果用一位的话不利于存储，会产生内存碎片。</p>
<h3 id="3-3-4-字符类型"><a href="#3-3-4-字符类型" class="headerlink" title="3.3.4 字符类型"></a>3.3.4 字符类型</h3><p>​    char</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">yeye</span> = &#x27;👴&#x27;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, yeye);<br></code></pre></td></tr></table></figure>

<h2 id="3-4-复合类型"><a href="#3-4-复合类型" class="headerlink" title="3.4 复合类型"></a>3.4 复合类型</h2><h3 id="3-4-1-元组Tuple"><a href="#3-4-1-元组Tuple" class="headerlink" title="3.4.1 元组Tuple"></a>3.4.1 元组Tuple</h3><p>​    每个位置对应一个类型，类型不必相同。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tp</span> = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, tp.<span class="hljs-number">0</span>, tp.<span class="hljs-number">1</span>, tp.<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>​    元组赋值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tp</span> = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>);<br><span class="hljs-comment">// println!(&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;, tp.0, tp.1, tp.2);</span><br><span class="hljs-keyword">let</span> (x, y, z) = tp;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, x, y, z);<br></code></pre></td></tr></table></figure>

<h3 id="3-4-2-数组"><a href="#3-4-2-数组" class="headerlink" title="3.4.2 数组"></a>3.4.2 数组</h3><p>​    和其他语言类似</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>

<h3 id="3-4-5-Vector"><a href="#3-4-5-Vector" class="headerlink" title="3.4.5 Vector"></a>3.4.5 Vector</h3><p>​    大小可变，用的更多。</p>
<h2 id="3-5-函数"><a href="#3-5-函数" class="headerlink" title="3.5 函数"></a>3.5 函数</h2><p>​    函数声明，函数名，参数列表，返回值。这是声明函数的全过程。</p>
<p>​    代码块里的最后一行没加分号，代表是返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">32</span>, <span class="hljs-number">2</span>))<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    x + y<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    或者这样也行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-6-if-else"><a href="#3-6-if-else" class="headerlink" title="3.6 if-else"></a>3.6 if-else</h2><p>​    第一种用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">if</span> cdt &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure>

<p>​    第二种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>;<br><span class="hljs-keyword">if</span> cdt &#123;<br>    num = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure>

<p>​    如果ifelse嵌套太多，使用模式匹配吧。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">match</span> cdt &#123;<br>    <span class="hljs-literal">true</span> =&gt; <span class="hljs-number">1</span>,<br>    <span class="hljs-literal">false</span> =&gt; <span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure>

<h2 id="3-7-循环"><a href="#3-7-循环" class="headerlink" title="3.7 循环"></a>3.7 循环</h2><h3 id="3-7-1-loop"><a href="#3-7-1-loop" class="headerlink" title="3.7.1 loop"></a>3.7.1 loop</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">loop</span> &#123;<br>    count = count + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, count);<br>    <span class="hljs-keyword">if</span> count &gt;<span class="hljs-number">100</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-7-2-while"><a href="#3-7-2-while" class="headerlink" title="3.7.2 while"></a>3.7.2 while</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">100</span> &#123;<br>    count = count + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-7-3-for-each"><a href="#3-7-3-for-each" class="headerlink" title="3.7.3 for - each"></a>3.7.3 for - each</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> arr &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> arr.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>60s倒计时</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">e</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">61</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="4-所有权"><a href="#4-所有权" class="headerlink" title="4 所有权"></a>4 所有权</h1><p>​    rust采用所有权系统来管理内存。并且，是在编译时检查，这样就不会减慢程序运行的速度。无运行时开销。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220114182046202.png" alt="image-20220114182046202"></p>
<h2 id="4-1-栈内存与堆内存"><a href="#4-1-栈内存与堆内存" class="headerlink" title="4.1 栈内存与堆内存"></a>4.1 栈内存与堆内存</h2><ul>
<li>堆栈：LIFO，last in first out，后进先出</li>
<li>堆：OS给用户在heap上找到一块足够大的区域，标记为在用，然后返回给用户。这就是在堆上分配内存。</li>
</ul>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220114181038063.png" alt="image-20220114181038063"></p>
<p>​    堆是通过分配来得到内存，而栈不同，栈是直接将数据存放到那一个格子就行了，不需要分配。</p>
<p>​    栈上分配的内存是固定不变的，如数组。而堆上分配的内存可以动态变化，也就是可变数组，像C语言里的动态内存分配，就是在堆上分配空间，然后返回一个指针给用户（malloc函数返回指针）。而这个指针由于是固定大小，所以可以存到栈上去。</p>
<p>​    在堆上分配空间更慢，因为OS需要找到一块足够大的空间。而在栈上就比较快了，因为这个空间肯定在栈的顶端。</p>
<p>​    在堆上访问数据也慢，因为需要通过指针寻址来访问，是间接访问，需要跳转，从栈-&gt;堆，比较慢；而从栈上访问数据就不一样了，因为是栈-&gt;栈，所以快。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220114181940185.png" alt="image-20220114181940185"></p>
<h2 id="4-2-所有权规则"><a href="#4-2-所有权规则" class="headerlink" title="4.2 所有权规则"></a>4.2 所有权规则</h2><p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220114182405990.png" alt="image-20220114182405990"></p>
<p>​    简化：在一个时间内，每个值有且只有一个变量，并且当所有者超出作用域时，所有者及其值将被删除。</p>
<h2 id="4-3-初识String"><a href="#4-3-初识String" class="headerlink" title="4.3 初识String"></a>4.3 初识String</h2><p>​    之前的标量数据类型都是存储在stack上的，一旦离开作用域就会被弹出。</p>
<p>​    而String是一种存放在heap上的数据类型。    </p>
<p>​    String可以代表std中复杂的数据类型，或者是我们自己创建的数据类型。</p>
<p>​    在程序运行中，有两种字符串：</p>
<ul>
<li>字符串字面量：是不可变的。在程序运行之前，即在编译期间，就可以知道其内容了，所以直接硬编码到可执行文件中了。所以在运行期间就不需要额外的内存了，高效。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">//hello就是一个字符串字面量</span><br></code></pre></td></tr></table></figure>

<ul>
<li>String类型：可变的，如获取用户的输入是，是不可预知的，用的就是String。String是在运行期间才会在heap上分配内存，通过from函数向OS申请内存。然后变变量超出作用域后，救会通过drop函数回收内存（自动的）。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//从字符串字面量创建一个String类型</span><br></code></pre></td></tr></table></figure>

<p>​    下面解释一段程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br></code></pre></td></tr></table></figure>

<p>​    第一行向heap申请了一块内存。具体是如下：在堆上申请了一块空间，存放hello字符数组，然后返回这个字符数组的三个信息：起始地址，长度，容量。返回给s1接收。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115132259157.png" alt="image-20220115132259157"></p>
<p>​    第二行是将s1的指针考培给了s2，包括heap指针，len和capacity。然后按照常规的思路，s1 s2都离开作用域时，都会进行drop回收内存。这样一块heap内存被回收了两次，是不安全的。</p>
<p>​    为了解决这个，在将s1指针拷贝给了s2后，也就是MOVE操作后，s1的内容被废弃，再次调用将出现报错。然后s1s2离开作用域后，只有s2指向的heap会被drop掉。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115132743008.png" alt="image-20220115132743008"></p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115132811413.png" alt="image-20220115132811413"></p>
<p>​    这样无疑更安全，也不会在堆上重新分配空间。</p>
<p>​    以上其实是一种浅拷贝，然是由于s1时失效了，于是创建了新的术语叫MOVE。</p>
<ul>
<li>浅拷贝 – MOVE移动</li>
<li>深拷贝 – CLONE克隆</li>
</ul>
<p>​    Rust所有的操作都是廉价的浅拷贝操作，不会开辟新的heap内存，除非是这样要求的。</p>
<p>​    下面的深拷贝，即克隆的操作。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115133335999.png" alt="image-20220115133335999"></p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115133353197.png" alt="image-20220115133353197"></p>
<p>​    而在栈上进行的MOVE，先前声明的变量就不会失效。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">//useful</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x; <span class="hljs-comment">//useful</span><br></code></pre></td></tr></table></figure>

<p>​    可以用下面两个概念来解释：</p>
<ul>
<li>Copy trait（复制特性）：实现了Copy trait的数据结构，在赋值后旧的变量仍然有效。</li>
<li>Drop trait（回收特性）：实现了Drop trait的数据结构，不能再实现Copy trait</li>
</ul>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115134031494.png" alt="image-20220115134031494"></p>
<h2 id="4-4-函数与所有权"><a href="#4-4-函数与所有权" class="headerlink" title="4.4 函数与所有权"></a>4.4 函数与所有权</h2><p>​    将值窜给函数，要么会发生移动（Move），要么发生复制（Copy）</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115135319262.png" alt="image-20220115135319262"></p>
<ul>
<li>copy trait的数据类型被传入时（i32）：传进去的时副本，在函数结束的时候，副本会被弹出stack</li>
<li>drop trait数据类型被传入时（String）：传进去后，旧的变量丧失所有权，回收时不再使用drop清理heap内存。传进去的数据获得所有权，在函数结束时弹出堆栈并且使用drop回收堆内存</li>
</ul>
<p>​    如果想即使用所有权，还能返回回来的话，可以使用元组</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> (s1, len) = <span class="hljs-title function_ invoke__">get_len</span>(s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;   &#123;&#125;&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_len</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>, <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br>    (s, l)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-5-引用"><a href="#4-5-引用" class="headerlink" title="4.5 引用"></a>4.5 引用</h2><p>​    引用：引用数据的值而不使用其所有权。&amp;符号表示</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115140318148.png" alt="image-20220115140318148"></p>
<p>引用分类：</p>
<ul>
<li>不可变引用：不能修改指向堆上的数据</li>
<li>可变引用：可以修改指向堆上的数据</li>
<li>悬空引用：引用指向的数据已经被释放，而引用依然有效（Rust在编译期杜绝了这个问题）</li>
</ul>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115141807954.png" alt="image-20220115141807954"></p>
<p>​    有以下规则： </p>
<ul>
<li>一个作用域内只能有一个可变引用</li>
<li>一个作用域内可以有多个不可变引用</li>
<li>同一个作用域内可变引用与不可变引用不能同时存在</li>
</ul>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115142315424.png" alt="image-20220115142315424"></p>
<p>​    可以看到：先声明了俩不可变的引用，然后声明了一个可变引用。如果不对不可变引用做操作的话，不会报错。如果在声明了可变引用后，还对不可变引用进行操作，这样就会报错。</p>
<h2 id="4-5-切片"><a href="#4-5-切片" class="headerlink" title="4.5 切片"></a>4.5 切片</h2><p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115144940387.png" alt="image-20220115144940387"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;ssss ssss&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">indx</span> = <span class="hljs-title function_ invoke__">get_space_index</span>(&amp;s);<br>    s.<span class="hljs-title function_ invoke__">clear</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, indx);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_space_index</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> p1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上面的代码是获取第一个空格所在的位置。</p>
<p>​    bug：当字符串被清空了后，得到的index不会发生改变，也就是同步性的问题。要保证：在字符串改变的同时，这个index也会同步改变。这很困难。</p>
<p>​    rust可以采用切片解决这个问题。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115144751616.png" alt="image-20220115144751616"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;ssss ssss&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">indx</span> = <span class="hljs-title function_ invoke__">get_space_index</span>(&amp;s[..]);<br>    s.<span class="hljs-title function_ invoke__">clear</span>(); <span class="hljs-comment">//报错，这个方法会创建一个可变的引用，与上一行的不可变引用冲突 </span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, indx);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_space_index</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> p1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i]; <span class="hljs-comment">//[0, i)</span><br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>​    因为函数里面采用了字符串切片，也就是不可变引用，所以修改时报错。</p>
<p>​    注意：字符串切片仅仅针对UTF-8的字符，两字节的汉字会报错。</p>
<p>​    还做了一个优化，把字符串引用修改成为了字符串切片，这样就能同时接收两种类型了(&amp;String -&gt; &amp;str)。如字符串字面量（&amp;str）和String类型。</p>
<p>​    数组也可以切片，和上面类似。</p>
<h1 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h1><h2 id="5-1-结构定义"><a href="#5-1-结构定义" class="headerlink" title="5.1 结构定义"></a>5.1 结构定义</h2><p>​    三类：</p>
<ul>
<li>struct：普通结构</li>
<li>tuple struct：元组结构，当你想给元组起名字的时候，使用它。</li>
<li>Unit - like - struct：无任何字段的结构</li>
</ul>
<p>​    普通结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    active: <span class="hljs-type">bool</span>,<br>    id: <span class="hljs-type">u32</span>,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jack</span> = <span class="hljs-title function_ invoke__">get_user</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;jack&quot;</span>), String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;12222@qq.com&quot;</span>), <span class="hljs-literal">true</span>, <span class="hljs-number">1111</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jack.active);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_user</span>(name: <span class="hljs-type">String</span>, email: <span class="hljs-type">String</span>, active: <span class="hljs-type">bool</span>, id: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        name,<br>        email,<br>        active,<br>        id,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>​    元组结构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-2-结构实例"><a href="#5-2-结构实例" class="headerlink" title="5.2 结构实例"></a>5.2 结构实例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = rectangle&#123;<br>        width: <span class="hljs-number">2</span>,<br>        length: <span class="hljs-number">3</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">get_area</span>(&amp;r1));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, r1);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_area</span>(rec: &amp;rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    rec.length * rec.width<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>​    Rust中有类似与java的toString方法，或者说是trait，但是默认没有实现，所以我们就用的是debug特性。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220115163757974.png" alt="image-20220115163757974"></p>
<ul>
<li>#[derive(Debug)]：实现debug trait</li>
<li>{:?}：输出结构的信息，不换行</li>
<li>{:#?}：输出结构的信息，换行</li>
</ul>
<h2 id="5-3-struct方法"><a href="#5-3-struct方法" class="headerlink" title="5.3 struct方法"></a>5.3 struct方法</h2><p>​    两种：</p>
<ul>
<li>方法：方法用impl定义的块去实现，需要传递它本身（或本身的引用）</li>
<li>关联函数：不需要传递本身，只是跟这个结构有关联，类似静态函数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.length<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.length &gt;= other.length &amp;&amp; <span class="hljs-keyword">self</span>.width &gt;= other.width<br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sqare</span>(size: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> rectangle &#123;<br>        rectangle &#123;<br>            width: size,<br>            length: size,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">20</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = rectangle &#123;<br>        width: <span class="hljs-number">100</span>,<br>        length: <span class="hljs-number">20</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = rectangle &#123;<br>        width: <span class="hljs-number">10</span>,<br>        length: <span class="hljs-number">10</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r2.<span class="hljs-title function_ invoke__">area</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;r2));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;r3));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = rectangle::<span class="hljs-title function_ invoke__">sqare</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, r4);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="6-枚举与模式匹配"><a href="#6-枚举与模式匹配" class="headerlink" title="6 枚举与模式匹配"></a>6 枚举与模式匹配</h1><h2 id="6-1-定义枚举"><a href="#6-1-定义枚举" class="headerlink" title="6.1 定义枚举"></a>6.1 定义枚举</h2><p>​    rust的枚举很强大。可以自定义枚举并存储数据，不需要消耗额外的结构体。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">home</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-number">120</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V6</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;::1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    枚举也可以定义方法。与结构体相同使用impl</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">express</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-2-Option枚举"><a href="#6-2-Option枚举" class="headerlink" title="6.2 Option枚举"></a>6.2 Option<T>枚举</T></h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span> &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;Sdssdffdsdsds&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n2</span>:<span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-3-match"><a href="#6-3-match" class="headerlink" title="6.3 match"></a>6.3 match</h2><p>​    math允许一个值与一系列的模式进行匹配，并执行匹配上的代码。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Fir,<br>    <span class="hljs-title function_ invoke__">Fun</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Week</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_fun</span>(one_day: &amp;Week) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">match</span> one_day &#123;<br>            Week::<span class="hljs-title function_ invoke__">Fun</span>(statement) =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, statement);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            Week::Mon =&gt; <span class="hljs-literal">false</span>,<br>            Week::Fir =&gt; <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::<span class="hljs-title function_ invoke__">Fun</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;no need to work!!!&quot;</span>));<br>    Week::<span class="hljs-title function_ invoke__">is_fun</span>(&amp;day);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上面通过枚举存储了数据（String），并且通过模式匹配，将数据与statement绑定，重现了数据。</p>
<p>​    match必须列举所有的值进行匹配，若值太多了，使用_来代表其他的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>    <span class="hljs-title function_ invoke__">Fun</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Week</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_fun</span>(one_day: &amp;Week) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">match</span> one_day &#123;<br>            Week::<span class="hljs-title function_ invoke__">Fun</span>(statement) =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, statement);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            Week::Mon =&gt; <span class="hljs-literal">false</span>,<br>            Week::Fir =&gt; <span class="hljs-literal">false</span>,<br>            _ =&gt; <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-4-if-let语法糖"><a href="#6-4-if-let语法糖" class="headerlink" title="6.4 if-let语法糖"></a>6.4 if-let语法糖</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;this is Firday&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;nonono&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    等价于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir;<br>    <span class="hljs-keyword">match</span> day &#123;<br>        Week::Fir =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;this is Firday&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;nonono&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="7-package-crate-module"><a href="#7-package-crate-module" class="headerlink" title="7  package crate module"></a>7  package crate module</h1><p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220116100625209.png" alt="image-20220116100625209"></p>
<h2 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h2><p>​    自顶向下：</p>
<ul>
<li><p>Package：通过cargo可以创建一个新的包，位于最顶层。</p>
</li>
<li><p>Crate：cargo创建完包后，下面的.rs文件，有的会生成binary二进制文件（main.rs就是默认创建的binary文件，crate root），有的是产生library（其它的非main.rs文件）。Crate只能是以下两种类型：</p>
<ul>
<li>binary</li>
<li>library</li>
</ul>
</li>
<li><p>Module：在一个.rs文件中，可以定义多个module。</p>
</li>
<li><p>Path：</p>
</li>
</ul>
<p>​    还有一个概念叫crate root，是.rs源代码文件，编译器从这里开始组成我们的Module文件。</p>
<p>​    下面是Package的描述：</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220116102055982.png" alt="image-20220116102055982"></p>
<p>​    crate可以把相关的功能整合到一个作用域内，还可以避免命名冲突。</p>
<p>​    Module是在一个crate内，将代码进行分组，可以复用，并且可以控制代码的权限（pub or pri）。mod还是可以嵌套的。</p>
<h2 id="7-2-权限"><a href="#7-2-权限" class="headerlink" title="7.2 权限"></a>7.2 权限</h2><p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220116103815978.png" alt="image-20220116103815978"></p>
<p>​    同级可以互相调用，父级不能调用子级的私有，子级可以调用所有父级的，无论暴露与否。外层mod加上了pub，里层的函数没加，函数依然是pri的。所以外面的mod里面的fn都需要加上pub才行。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son_1 &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun1</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">mod</span> son_2 &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun2</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtt</span>() &#123;<br>    crate::father::son_1::<span class="hljs-title function_ invoke__">fun1</span>();<br>    crate::father::son_2::<span class="hljs-title function_ invoke__">fun2</span>(); <span class="hljs-comment">//报错，提示函数和mod都是私有的</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    访问函数可以通过绝对路径和相对路径。建议绝对路径。</p>
<ul>
<li>绝对路径：<code>crate::father::son_1::fun1();</code></li>
<li>相对路径：<ul>
<li><code>father::son_1::fun1();</code></li>
<li>子级在调用父级的函数时，可以通过<code>super关键字</code></li>
</ul>
</li>
</ul>
<h2 id="7-3-结构的权限"><a href="#7-3-结构的权限" class="headerlink" title="7.3 结构的权限"></a>7.3 结构的权限</h2><p>​    结构默认为pri，并且结构的字段也是pri的，如果像设置乘公有的，加上pub</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>        <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_eat</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;is eating &#123;&#125; at &#123;&#125;.&#123;&#125;.&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.food, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">1</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">2</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">3</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">4</span>);<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtt</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jack</span> = crate::father::eat &#123;<br>        time: (<span class="hljs-number">2022</span>, <span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>),<br>        food: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;kaoji&quot;</span>),<br>    &#125;;<br>    jack.<span class="hljs-title function_ invoke__">to_eat</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-4-枚举的权限"><a href="#7-4-枚举的权限" class="headerlink" title="7.4 枚举的权限"></a>7.4 枚举的权限</h2><p>​    枚举前面加上pub后，其里面的枚举变体自动变成公共的了。</p>
<h2 id="7-5-use的使用"><a href="#7-5-use的使用" class="headerlink" title="7.5 use的使用"></a>7.5 use的使用</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>​    针对函数，use一般时引用它的上一级mod，而不是直接引入到函数本身，这样增强代码的可读性，避免函数冲突了。</p>
<p>​    而针对结构struct，enum的话，就是引入到本身，而不是父级条目。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>            <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>            <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cry</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wawawawa&quot;</span>);<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">use</span> crate::father::son;<br><span class="hljs-keyword">use</span> crate::father::son::eat;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtttt</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = eat &#123;<br>        time: (<span class="hljs-number">2020</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>),<br>        food: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sasa&quot;</span>),<br>    &#125;;<br>    son::<span class="hljs-title function_ invoke__">cry</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    对于有同名的数据结构，有以下两种做法：</p>
<ul>
<li>像函数一样，引入到父级条目下就停止，不到该数据结构。</li>
<li>可以使用别名，用as，指定一个别名。</li>
</ul>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220116121716763.png" alt="image-20220116121716763"></p>
<p>​    可以看到报错了。</p>
<p>​    可以写成如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = IoResult::<span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = FmtResult::<span class="hljs-literal">Ok</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h3><p>​    使用use导入mod后，这个mod对内部作用是可见的。而对如果外部去调用这个函数，对这个mod是没有访问权限的。所以这个时候可以使用pub use，这样这个模块对外部也是可见的了。</p>
<p>​    pub use 意思是重导出。</p>
<h2 id="7-6-特殊的use使用"><a href="#7-6-特殊的use使用" class="headerlink" title="7.6 特殊的use使用"></a>7.6 特殊的use使用</h2><ul>
<li>一次引入同一级下的多个包。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult;<br>-------<span class="hljs-punctuation">-&gt;</span><br><span class="hljs-keyword">use</span> std::&#123;<br>    io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult,<br>    fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult,<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>用self代表它自身</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span>;<br><span class="hljs-keyword">use</span> std::io;<br>-------<span class="hljs-punctuation">-&gt;</span><br><span class="hljs-keyword">use</span> std::io::&#123;<br>    <span class="hljs-type">Result</span>,<br>    <span class="hljs-keyword">self</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>通过通配符*引入全部的包（不建议经常使用），一般用于 以下情况<ul>
<li>测试：将所有的公共条目引入测试test模块</li>
<li>预导入</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::*;<br></code></pre></td></tr></table></figure>

<h2 id="7-7-引入自己写的mod"><a href="#7-7-引入自己写的mod" class="headerlink" title="7.7 引入自己写的mod"></a>7.7 引入自己写的mod</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my_lib;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_lib::father::son::<span class="hljs-title function_ invoke__">cry</span>(); <span class="hljs-comment">//使用了my_lib.rs下的father模块中的son模块中的一个关联函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    如果mod的嵌套太多，可以创建一个新的同名文件夹，然后里面建立子mod的同名.rs文件。</p>
<p>​    可以用mod和use一起作用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//main.rs</span><br><span class="hljs-keyword">mod</span> my_lib;<br><span class="hljs-keyword">use</span> my_lib::father::son <span class="hljs-keyword">as</span> son;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    son::<span class="hljs-title function_ invoke__">cry</span>();<br>&#125;<br><br><span class="hljs-comment">//my_lib.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> father;<br><br><span class="hljs-comment">//my_lib\father.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>        <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cry</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wawawawa&quot;</span>);<br>        <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    树形结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">src<br>	main.rs<br>	my_lib.rs<br>	my_lib<br>		father.rs<br></code></pre></td></tr></table></figure>

<h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8 集合"></a>8 集合</h1><p>​    集和是建立在heap上的数据，因此在编译时不需要去确定大小，在运行时会自动变化。</p>
<h2 id="8-1-Vector"><a href="#8-1-Vector" class="headerlink" title="8.1 Vector"></a>8.1 Vector</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><p>​    有两种方式创建Vector</p>
<ul>
<li>通过关联函数，这种情况需要显示的指明类型。</li>
<li>通过已有的值来创建</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = <span class="hljs-built_in">vec!</span>[String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;first&quot;</span>)];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    rust有上下文推断机制，如果前面没有明确Vec的类型，这时会报错；然后后面添加了元素，又能够自动推断出类型了，报错会消失。</p>
<h3 id="2-更新"><a href="#2-更新" class="headerlink" title="2.更新"></a>2.更新</h3><p>​    我们使用第一种方式创建Vector，并且向里面添加元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1i64</span>); <span class="hljs-comment">//64位有符号</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-清理"><a href="#3-清理" class="headerlink" title="3.清理"></a>3.清理</h3><p>​    一般而言，离开作用域后，Vector就会被OS调用drop给清理掉。</p>
<h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4.获取"></a>4.获取</h3><p>​    两种方法：</p>
<ul>
<li>索引：得到的是数据本身</li>
<li>get方法：得到的是Some(T)或者None，其中T是不可变引用。</li>
</ul>
<p>​    get更安全，可以对得到的数据进行类型判断，如果是Some就取出，是None就不取出，提示错误。</p>
<p>​    而索引的话，就会出现panic，程序恐慌。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">30i32</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span>: <span class="hljs-type">i32</span> = <span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">10000</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(n) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;get it: &#123;&#125;&quot;</span>, n);<br>            *n<br>        &#125;,<br>        <span class="hljs-literal">None</span> =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>            -<span class="hljs-number">1</span><br>        &#125;,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    因为Vec在heap上，所以有所有权的借用，用get得到的是引用，用索引的到的是本身。但是借用两边并不会报错（i32），<em>说明是存放在栈上的，copy和move都一样</em>。这个地方是错误的，因为i32实现的是copy trait，所以使用等号时会在栈上压栈一个相同的数据。自然不会有所有权的问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">30i32</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n2</span> = v[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">//并没有报错</span><br></code></pre></td></tr></table></figure>

<p>​    下面修改成String类型的试试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//cannot move out of index of `std::vec::Vec&lt;std::string::String&gt;`</span><br><span class="hljs-comment">//move occurs because value has type `std::string::String`, which does not implement the `Copy` trait</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    错误信息如上。String没有实现copy trait，而是drop trait，如果操作成功，原来Vec里面对应位置的数据就会失效，所以只能采用借用，也就是用引用来获取。</p>
<p>​    而get默认的就是得到一个引用，用索引的话需要加上引用符号。</p>
<p>​    下面我们先通过索引加引用符号得到一个不可变引用，然后再添加一个元素进去，最后再打印这个不可变引用指向的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = &amp;v[<span class="hljs-number">0</span>];<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;   &quot;</span>)); <span class="hljs-comment">//这一行会报错</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, n1);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220116142000246.png" alt="image-20220116142000246"></p>
<p>​    原因是什么呢？</p>
<ul>
<li>不可变引用与可变引用不能同时存在。</li>
<li>Vec的机制，因为在堆上分配的空间，所以空间可能不足，需要重新分配空间，然后进行一个数据的迁移，最后释放掉原来那部分的空间。如果发生这种情况，上面获取的不可变引用，它的指向是不会改变的，这样就指向了一片空的内存，是不安全的。所以编译器不允许这样的情况发生。</li>
</ul>
<p>​    然后再次试了一下使用Vector存放i64，放很多数据。然后发生了栈溢出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/**memory allocation of 8589934592 bytes failed</span><br><span class="hljs-comment"> *error: process didn&#x27;t exit successfully: `target\debug\stdvector.exe` (exit code: 0xc0000409,    	      *STATUS_STACK_BUFFER_OVERRUN)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1i64</span>);<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2i64</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">1000000000000000000i64</span>) &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, n1);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    换成String也会发生溢出。</p>
<p>​    然后查阅了相关资料，确定Vec是存放在栈上的。</p>
<h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5.遍历"></a>5.遍历</h3><p>​    通过for循环遍历，通过解引用*更新。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>        *num = *num + <span class="hljs-number">50</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-2-enum-amp-vector"><a href="#8-2-enum-amp-vector" class="headerlink" title="8.2 enum &amp; vector"></a>8.2 enum &amp; vector</h2><p>​    存放时直接存放就行，取出时需要根据类型取出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">InputKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>        InputKind::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">32</span>),<br>        InputKind::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">3.22222</span>),<br>        InputKind::<span class="hljs-title function_ invoke__">Text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hhhh&quot;</span>)),<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-3-String类型"><a href="#8-3-String类型" class="headerlink" title="8.3 String类型"></a>8.3 String类型</h2><h3 id="1-创建字符串"><a href="#1-创建字符串" class="headerlink" title="1.创建字符串"></a>1.创建字符串</h3><p>​    两种方法：</p>
<ul>
<li>字符串无初值，使用new关联函数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure>

<ul>
<li><p>字符串有初值：</p>
<ul>
<li>使用关联函数from</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hhh&quot;</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>使用to_String方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hhh&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(); <span class="hljs-comment">//这里的string是小写</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-更新-1"><a href="#2-更新-1" class="headerlink" title="2.更新"></a>2.更新</h3><p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220116152252174.png" alt="image-20220116152252174"></p>
<h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3.访问"></a>3.访问</h3><p>​    不支持索引访问，只能用切片来访问。</p>
<p>​    原因有两个：</p>
<ul>
<li>UTF8编码，一个Unicode值对应的字节数不是固定的。</li>
<li>索引操作应该消耗O(1)的时间复杂度，但是String无法保证。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello_world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, p);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-内部表示"><a href="#4-内部表示" class="headerlink" title="4.内部表示"></a>4.内部表示</h3><p>​    String时对Vec<u8>的包装，也就是一个可变字节数组。</u8></p>
<p>​    有一个len方法返回的是它的字节数。</p>
<p>​    String有一个大坑，String里面存储的是字节，但是字符都有它的Unicode标量值，一个Unicode值不一定就是一个字节。如下：</p>
<ul>
<li>汉字：1 Unicode – 3 Byte</li>
<li>英语：1 Unicode – 1 Byte</li>
<li>印度：1 Unicode – 2 Byte</li>
</ul>
<p>​    这个时候我们访问，用字符串切割也要看响应的场景了。</p>
<p>​    Rust里有三种看待字符串的方式（自底向上）：</p>
<ul>
<li>字节</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;नमस्ते&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">bytes</span>() &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &quot;</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//224 164 168 224 164 174 224 164 184 224 165 141 224 164 164 224 165 135 </span><br></code></pre></td></tr></table></figure>

<ul>
<li>标量值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;हेलो बास्टियन&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &quot;</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//न म स ् त े </span><br><span class="hljs-comment">//第四个和第六个是类似音调的东西，拆分开没有意义</span><br></code></pre></td></tr></table></figure>

<ul>
<li>字形簇：标准库里没有提供。</li>
</ul>
<h3 id="5-字符串切片的坑"><a href="#5-字符串切片的坑" class="headerlink" title="5.字符串切片的坑"></a>5.字符串切片的坑</h3><p>​    使用[min..max]来进行切片，从[min, max - 1]</p>
<p>​    如果切割的不是完整的Unicode编码，不会报错，但会发生恐慌</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;नमस्ते&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//thread &#x27;main&#x27; panicked at &#x27;byte index 1 is not a char boundary; it is inside &#x27;न&#x27; (bytes 0..3) of `नमस्ते`&#x27;, src\main.rs:3:14</span><br></code></pre></td></tr></table></figure>



<h3 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6.遍历"></a>6.遍历</h3><p>​    遍历在内部表示中提及。</p>
<h2 id="8-4-HashMap"><a href="#8-4-HashMap" class="headerlink" title="8.4 HashMap"></a>8.4 HashMap</h2><h3 id="1-创建及插入"><a href="#1-创建及插入" class="headerlink" title="1.创建及插入"></a>1.创建及插入</h3><ul>
<li>引入包</li>
<li>new创建</li>
<li>insert插入</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    map.<span class="hljs-title function_ invoke__">insert</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;001&quot;</span>), String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcy&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    HashMap是同构的，所有的key是一种类型，value也是一种类型</p>
<p>​    上面是常规的创建方法，还可以使用tuple来创建。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">12u8</span>, <span class="hljs-number">13u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = name.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(age.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    先创建两个Vector，然后用一个vec生成一个迭代器，再跟另外一个vec的迭代器进行一一映射。然后再用collect方法打包返回一个hashmap。</p>
<p>​    那个&lt;_, _&gt;是会自动推断的，但是不可以省去。</p>
<p>​    向HashMap中插入数据时，如果数据是实现了copy trait的话，数据会被复制一份。如果是是西安了drop trait的话，数据会被一觉，所有权也会转移，源数据也会失效。</p>
<p>​    但如果插入的是引用，就不会发生所有权的移交了。</p>
<p>​    下面是通过get获取map中的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = map.<span class="hljs-title function_ invoke__">get</span>(&amp;name[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(r) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>),<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//打印18</span><br></code></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = map.<span class="hljs-title function_ invoke__">get</span>(&amp;<span class="hljs-string">&quot;hhh&quot;</span>);<br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(r) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>),<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//打印 error</span><br></code></pre></td></tr></table></figure>

<h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><p>​    使用元组tuple和for-each进行遍历</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (k, v) <span class="hljs-keyword">in</span> map &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, k, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h3><p>​    当向map中插入数据时，可能有三种情况：</p>
<ul>
<li><p>数据不存在，直接插入即可。</p>
</li>
<li><p>数据存在</p>
<ul>
<li>忽略原来的数据v，用新的v替换掉它 – insert()方法就是这样的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcy&quot;</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s, <span class="hljs-number">0u8</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s, <span class="hljs-number">99u8</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, m);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;qcy&quot;: 99&#125;</span><br></code></pre></td></tr></table></figure>



<ul>
<li>保留现在的v，忽略新的v – 使用entry来判断是否存在，用or_insert(v)方法来插入，如果k不存在，执行；存在，不执行。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qqcy&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcwdfg&quot;</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s1, <span class="hljs-number">1u8</span>);<br>    m.<span class="hljs-title function_ invoke__">entry</span>(&amp;s2).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">122u8</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, m);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;qqcy&quot;: 1, &quot;qcwdfg&quot;: 122&#125;</span><br></code></pre></td></tr></table></figure>



<ul>
<li>合并旧的v和新的v – 还是使用or_insert(v)，来判断，若k存在会返回一个k的可变引用，可以对k进行修改。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span>: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">u32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;h h h h h a a x c v b g r e qw s f gf g h h &quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = text.<span class="hljs-title function_ invoke__">split_whitespace</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> res &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = map.<span class="hljs-title function_ invoke__">entry</span>((*i).<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br>        *num += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, map);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;h&quot;: 7, &quot;b&quot;: 1, &quot;x&quot;: 1, &quot;r&quot;: 1, &quot;e&quot;: 1, &quot;f&quot;: 1, &quot;gf&quot;: 1, &quot;g&quot;: 2, &quot;s&quot;: 1, &quot;c&quot;: 1, &quot;qw&quot;: 1, &quot;v&quot;: 1, &quot;a&quot;: 2&#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-Hash函数"><a href="#4-Hash函数" class="headerlink" title="4.Hash函数"></a>4.Hash函数</h3><p>​    一般默认情况下：</p>
<ul>
<li>可抵御Dos攻击 – 良好的安全性</li>
<li>并不是最快的 – 性能一般</li>
</ul>
<p>若是觉得性能不好，可以修改trait</p>
<h1 id="9-错误处理"><a href="#9-错误处理" class="headerlink" title="9.错误处理"></a>9.错误处理</h1><h2 id="1-不可恢复的错误与panic-宏"><a href="#1-不可恢复的错误与panic-宏" class="headerlink" title="1.不可恢复的错误与panic!宏"></a>1.不可恢复的错误与panic!宏</h2><p>​    大多编程语言在错误处理这方面提供了异常机制，没有对可恢复错误与不可恢复错误进行区分，而Rust没有异常机制，但他对错误处理进行了分类：</p>
<ul>
<li>可恢复错误：如文件找不到，可再次尝试<ul>
<li>使用Result&lt;T, E&gt;</li>
</ul>
</li>
<li>不可恢复错误：如Vec越界访问<ul>
<li>使用panic!宏进行处理</li>
</ul>
</li>
</ul>
<p>​    针对不可恢复的错误，我们有两种处理，展开或终止（abort）调用栈。</p>
<ul>
<li>展开调用栈：Rust沿着调用栈往回走，清理遇到每个函数中的数据。</li>
<li>终止调用栈：直接终止程序，不进行清理。但是需要由OS来清理。</li>
</ul>
<p>​    若想二进制文件更小，需要将默认的展开改成终止。</p>
<p>​    具体就是在cargo.toml中设置profile。</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;paniccccccc&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang/.org/cargo/reference/manifest.html</span><br><br><span class="hljs-section">[dependencies]</span><br><br><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&#x27;abort&#x27;</span><br></code></pre></td></tr></table></figure>

<p>main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2u8</span>];<br>    v[<span class="hljs-number">999</span>];<br>&#125;<br><span class="hljs-comment">//note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="hljs-comment">//通过set RUST_BACKTRACE=1 &amp;&amp; cargo run 进行栈回溯</span><br></code></pre></td></tr></table></figure>

<p>​    顺便再次复习一下，v.get(999)并不会报错，得到的返回值是None</p>
<h2 id="2-Result枚举与可恢复的错误"><a href="#2-Result枚举与可恢复的错误" class="headerlink" title="2.Result枚举与可恢复的错误"></a>2.Result枚举与可恢复的错误</h2><p>​    执行文件操作会返回一个Result的枚举变体，操作成功为Ok(T)，失败为Err(E)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, error);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    下面是针对不同的错误，通过match做的一些处理</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    fs::File,<br>    io::ErrorKind,<br>&#125;;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>() &#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(msg) =&gt; msg,<br>                <span class="hljs-title function_ invoke__">Err</span>(msg) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, msg),<br>            &#125;,<br>            OtherError =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, OtherError),<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-unwrap与expect替换match"><a href="#3-unwrap与expect替换match" class="headerlink" title="3.unwrap与expect替换match"></a>3.unwrap与expect替换match</h2><p>​    上面我们用了很多match，代码的可读性还行，但太臃肿了。</p>
<p>​    下面提供一种unwrap()方法。</p>
<p>​    使用unwrap打开文件</p>
<ul>
<li>如果文件不存在，程序恐慌</li>
<li>如果文件存在，返回文件</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用unwrap创建文件</p>
<ul>
<li>如果文件不存在，创建文件</li>
<li>如果文件存在，返回文件</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    但是有一个缺点，unwrap无法定位错误信息（所有unwrap返回的错误信息都是一样的），所以下面介绍expect</p>
<p>​    expect与unwrap一样，单数可以控制输出的错误信息，精确的定位到处错在哪一行。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;出错啦&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-通过函数将错误返回"><a href="#4-通过函数将错误返回" class="headerlink" title="4.通过函数将错误返回"></a>4.通过函数将错误返回</h2><p>​    将函数的返回值设置为一个Result枚举类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123; <span class="hljs-comment">//file必须是可变的，因为会执行读这个操作。</span><br>        <span class="hljs-title function_ invoke__">Ok</span>(f) =&gt; f,<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e) <span class="hljs-comment">//直接作为函数返回值</span><br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">match</span> f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(s),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-语法糖：”-”"><a href="#5-语法糖：”-”" class="headerlink" title="5.语法糖：”?”"></a>5.语法糖：”?”</h2><p>​    ?：执行一个操作</p>
<ul>
<li>如果是Ok的话，就把Ok里的值作为结果绑定到变量。</li>
<li>如果是Err的话，就直接返回错误（注意main函数没有返回值，所以如果要使用”?”的话，需要加东西）。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path)?;<br>    <span class="hljs-comment">// let mut f = match f &#123; //file必须是可变的，因为会执行读这个操作。</span><br>    <span class="hljs-comment">//     Ok(f) =&gt; f,</span><br>    <span class="hljs-comment">//     Err(e) =&gt; return Err(e) //直接作为函数返回值</span><br>    <span class="hljs-comment">// &#125;;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-comment">// match f.read_to_string(&amp;mut s) &#123;</span><br>    <span class="hljs-comment">//     Ok(_) =&gt; Ok(s),</span><br>    <span class="hljs-comment">//     Err(e) =&gt; Err(e),</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    删掉注释后效果如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    非常精简。</p>
<p>​    然后再进行链式调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    File::<span class="hljs-title function_ invoke__">open</span>(path)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-main函数中如何使用”-”运算符"><a href="#6-main函数中如何使用”-”运算符" class="headerlink" title="6.main函数中如何使用”?”运算符"></a>6.main函数中如何使用”?”运算符</h2><p>​    main的返回类型是()，也可以修改为Result，T对应的是()，E对应的是任意可能的错误类型（其实是一个trait对象7.）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-何时使用panic"><a href="#7-何时使用panic" class="headerlink" title="7.何时使用panic!"></a>7.何时使用panic!</h2><p>​    总体原则如下：</p>
<ul>
<li>尽量使用Result！将错误返回到代码的调用者，让他们决定如何去处理，如果我们觉得这个错误除了panic!，没有其它的解决办法，就直接使用panic!吧</li>
</ul>
<h1 id="10-泛型，trait，生命周期"><a href="#10-泛型，trait，生命周期" class="headerlink" title="10.泛型，trait，生命周期"></a>10.泛型，trait，生命周期</h1><h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h2><p>​    Rust对类型的命名采用的是驼峰命名而非蛇形命名。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DogAnimal</span> &#123;<span class="hljs-comment">//...&#125;</span><br></code></pre></td></tr></table></figure>

<p>​    泛型的声明</p>
<ul>
<li>结构</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Good</span>&lt;X, Y&gt; &#123;<br>    name: X,<br>    msg: Y,<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>函数</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hhh</span>&lt;X&gt;() &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>枚举（Option<T> 和 Result&lt;T, E&gt;）</T></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>方法</li>
</ul>
<p>​    注：针对具体的方法，impl后不需要接收泛型。如果是泛型方法，那么就需要</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Good</span>&lt;X, Y&gt; &#123;<br>    name: X,<br>    msg: Y,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;X, Y&gt; Good&lt;X, Y&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name: X, msg: Y) <span class="hljs-punctuation">-&gt;</span> Good&lt;X, Y&gt;&#123;<br>        Good&#123;<br>            name,<br>            msg,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Good</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">speak</span>(<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>​    使用泛型并不会影响性能。因为Rust使用了<em><strong>单态化</strong></em>，也就是编译的时候会将具体的类型带入到泛型参数里去，从而在运行时不需要额外的开销。</p>
<h2 id="2-trait"><a href="#2-trait" class="headerlink" title="2.trait"></a>2.trait</h2><ul>
<li>类似于接口，告诉编译器哪些类型可以具有相同的功能。</li>
<li>还有一个trait bound的特性：要求传进来的泛型参数必须实现了对应的trait</li>
</ul>
<p>​    trait的产生和接口是类似的，有些不同的类型会实现相同的方法。所以我们就把这些方法提取出来，实现一个trait。</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​    如下，只有方法签名，无具体实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Behavior</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat</span>(<span class="hljs-keyword">self</span>);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_money</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h3><p>my_lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Man</span> &#123;<br>        <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,<br>        <span class="hljs-keyword">pub</span> age: <span class="hljs-type">i8</span>,<br>        <span class="hljs-keyword">pub</span> money: <span class="hljs-type">i32</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Boy</span> &#123;<br>        <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,<br>        <span class="hljs-keyword">pub</span> age: <span class="hljs-type">i8</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Man</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>            <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;name is &#123;&#125;, age is &#123;&#125;, get money &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age, <span class="hljs-keyword">self</span>.money)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Boy</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>            <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;i am &#123;&#125;, age is &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> fanxingggggg::my_struct::&#123;<br>    Man,<br>    Boy,<br>&#125;;<br><span class="hljs-keyword">use</span> fanxingggggg::my_trait::Text;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Man &#123;<br>        name: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;father&quot;</span>),<br>        age: <span class="hljs-number">40</span>,<br>        money: <span class="hljs-number">100</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Boy &#123;<br>        name: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;boy&quot;</span>),<br>        age: <span class="hljs-number">18</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, m.<span class="hljs-title function_ invoke__">write</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b.<span class="hljs-title function_ invoke__">write</span>());<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    trait也可以使用默认实现，也就是在trait的定义时就实现trait。如果结构对trait的默认实现进行了重写的话，就不能再调用默认实现了。</p>
<h3 id="3-将trait作为参数"><a href="#3-将trait作为参数" class="headerlink" title="3.将trait作为参数"></a>3.将trait作为参数</h3><ul>
<li>参数类型为iml trait</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun1</span>(object: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> + Display) &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用trait bound</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;T: Text + Display&gt;(o: T) &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在返回类型后使用where</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;T&gt;(o: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">where</span> T: Text + <span class="hljs-built_in">Clone</span> + Display,<br>    &#123;<br>        String::<span class="hljs-title function_ invoke__">new</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h2><p>​    定义：让引用保持有效的作用域。</p>
<p>​    Rust有一个东西叫做借用检查器。会在编译的时候比较两个引用的生命周期的长短。</p>
<h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1.简单使用"></a>1.简单使用</h3><p>​    当你写了一个函数时，向里面传了多个引用，然后对其进行一系列操作，最后返回一个引用时。需要用到生命周期。</p>
<p>​    因为编译器需要确保传进来的生命周期，与传出去的生命周期一样，或者说大于。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">&quot;hello world!&quot;</span>; <span class="hljs-comment">//5</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sss&quot;</span>); <span class="hljs-comment">//3</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = <span class="hljs-title function_ invoke__">get_longer</span>(&amp;s1, &amp;s2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;res);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_longer</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s1: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, s2: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> s1.<span class="hljs-title function_ invoke__">len</span>() &gt; s2.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        s1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        s2<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>​    目的检查非法调用。</p>
<p>​    实际返回结果的生命周期是两个参数中生命周期较小的那一个。</p>
<p>​    我们看下面这个错误调用。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220119202214447.png" alt="image-20220119202214447"></p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220119202225682.png" alt="image-20220119202225682"></p>
<p>​    通过函数，res的生命这些周期被缩短到和s2一样了。这样在外部继续调用的话，就会发生错误。</p>
<p>​    再试试Java里的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.reptile;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestD</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br>        String res;<br>        &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sss&quot;</span>;<br>            res = s2;<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    res的值和s2是一样的，这意味着s2并没有被GC回收掉。</p>
<h3 id="2-函数的生命周期"><a href="#2-函数的生命周期" class="headerlink" title="2.函数的生命周期"></a>2.函数的生命周期</h3><p>​    函数的返回值的生命周期跟输入的参数的生命周期有关。</p>
<p>​    如果要返回一个引用，需要确保这个引用不会被回收（即不是本地变量）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s1: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, s2: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &amp;s <span class="hljs-comment">//报错，returns a reference to data owned by the current function</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    返回的引用指向的堆已经被drop掉了，所以不行。这个引用叫悬垂指针。在Rust里，只要提供了足够的信息（生命周期），就不会发生这种情况。</p>
<p>​    如果想要使用在函数里的变量，建议返回一个String，移交所有权，而不是返回一个引用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(arg: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Config, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> arg.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">3</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;arguments counts not good, find &#123;&#125;, need 2&quot;</span>, arg.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = &amp;arg[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = &amp;arg[<span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">Ok</span>(<br>        Config &#123;<br>            query: p1,<br>            file_path: p2,<br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-struct的生命周期"><a href="#3-struct的生命周期" class="headerlink" title="3.struct的生命周期"></a>3.struct的生命周期</h3><p>​    与函数类似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Man</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    name: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    这里生命周期的意思是：字段存活的时间必须比结构久，不然的话字段先被回收了，结构还在，就会发生内存泄漏。</p>
<p>​    即绑定给name的数据的生命周期的存活时间必须要覆盖这个结构的生命周期。</p>
<h3 id="4-生命周期省略的规则"><a href="#4-生命周期省略的规则" class="headerlink" title="4.生命周期省略的规则"></a>4.生命周期省略的规则</h3><ul>
<li>每个引用类型的参数都有自己的生命周期</li>
<li>如果只有一个输入生命周期参数，那么这个生命周期参数将被赋给输出生命周期参数</li>
<li>如果有多个输入生命周期参数，但是其中之一是<code>&amp;self or &amp;mut self</code>，那么self的生命周期将被赋给输出生命周期参数。</li>
</ul>
<h3 id="5-静态生命周期"><a href="#5-静态生命周期" class="headerlink" title="5.静态生命周期"></a>5.静态生命周期</h3><p>​    静态生命周期用&#96;static，表示，意思是比那辆的存活时间和程序的存活时间是一致的。也就是说编译器在编译的时候就把这一部分作为二进制值写进去了。</p>
<p>​    只有实现了copy trait的变量才可以声明static</p>
<h1 id="11-测试"><a href="#11-测试" class="headerlink" title="11.测试"></a>11.测试</h1><p>​    测试三个步骤，3A</p>
<ul>
<li><em><strong>准备数据</strong></em> </li>
<li><em><strong>运行测试代码</strong></em></li>
<li><em><strong>断言结果</strong></em></li>
</ul>
<h2 id="1-编写测试"><a href="#1-编写测试" class="headerlink" title="1.编写测试"></a>1.编写测试</h2><p>​    在函数的上方加上 属性（aattribute）<code>#[test]</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2.运行测试"></a>2.运行测试</h2><p>​    使用cargo test命令</p>
<h2 id="3-断言的作用"><a href="#3-断言的作用" class="headerlink" title="3.断言的作用"></a>3.断言的作用</h2><h3 id="1-assert"><a href="#1-assert" class="headerlink" title="1.assert!"></a>1.assert!</h3><p>​    断定此处为true！</p>
<p>​    可以接收一个bool类型，true通过，false则panic</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#[test]</span><br><span class="hljs-function">fn <span class="hljs-title">ppp</span>()</span> &#123;<br>    <span class="hljs-keyword">let</span> f = <span class="hljs-literal">false</span>;<br>    assert!(f);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-assert-eq"><a href="#2-assert-eq" class="headerlink" title="2.assert_eq!"></a>2.assert_eq!</h3><p>​    断定两个同类型的变量相等！</p>
<p>​    比如下面的assert_eq!，就是表明括号里面传入的参数肯定相等，不然就会报错。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    还可以接收字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(result, String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-assert-ne"><a href="#3-assert-ne" class="headerlink" title="3.assert_ne!"></a>3.assert_ne!</h3><p>​    与assert eq相反，ne的意思是not eq</p>
<h3 id="4-给断言添加自定义消息"><a href="#4-给断言添加自定义消息" class="headerlink" title="4.给断言添加自定义消息"></a>4.给断言添加自定义消息</h3><p>​        其实assert宏还有另外一个参数，可以传递字符串，而事实上这个字符串最终会传递给format宏。所以这个字符串里面可以添加占位符{}，并且后面可以带参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i1</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i2</span> = <span class="hljs-number">12</span>;<br>    <span class="hljs-built_in">assert_eq!</span>(i1, i2, <span class="hljs-string">&quot;&#123;&#125; is not eq &#123;&#125;&quot;</span>, i1, i2);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-属性should-panic"><a href="#4-属性should-panic" class="headerlink" title="4.属性should_panic"></a>4.属性should_panic</h2><p>​    在测试下面，函数上面再添加一条属性（attribute），叫<code>#[should_panic]</code></p>
<p>​    表示下面的测试函数应该恐慌，不恐慌测试就不会通过。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-meta">#[should_panic]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hello should_panic&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    可以通过在should_panic(expected &#x3D; “”)添加参数，让测试更加精确一点。如添加了字符串参数，然后如果恐慌信息里包含了这个expected参数，那么就测试通过；反之，如果不包含，那么测试失败。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-meta">#[should_panic(expected = <span class="hljs-string">&quot;hello&quot;</span>)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hello should_panic&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-使用Result枚举来进行测试"><a href="#5-使用Result枚举来进行测试" class="headerlink" title="5.使用Result枚举来进行测试"></a>5.使用Result枚举来进行测试</h2><p>​    无需panic。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Err</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;not eq&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="12-命令行项目"><a href="#12-命令行项目" class="headerlink" title="12.命令行项目"></a>12.命令行项目</h1><p>​    实现这样的功能：通过命令行，向程序中输入参数，一个是字符串，一个是文件绝对路径。然后找到这个绝对路径中跟字符串内容匹配的部分，并且打印出来。</p>
<h2 id="1-接收命令行参数"><a href="#1-接收命令行参数" class="headerlink" title="1.接收命令行参数"></a>1.接收命令行参数</h2><p>​    使用std::env下的args接收参数，并调用collect方法，返回一个Vec</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-comment">// let p1 = &amp;v[0];</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, v);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-读取文件内容"><a href="#2-读取文件内容" class="headerlink" title="2.读取文件内容"></a>2.读取文件内容</h2><p>​    使用std::fs下的read _to_string 来读取，会返回一个result，所以我们调用except来处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: python</span><br><span class="hljs-comment">path: C:\Users\User\Desktop\Typora快捷键.txt</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = &amp;v[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = &amp;v[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = std::fs::<span class="hljs-title function_ invoke__">read_to_string</span>(path).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, content);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="3-代码重构"><a href="#3-代码重构" class="headerlink" title="3.代码重构"></a>3.代码重构</h2><p>​    遵循一个函数一个功能的原则，main函数现在太臃肿了。</p>
<p>​    选择将main.rs拆分成main.rs和lib.rs，将业务逻辑的实现放在libl里。</p>
<p>​    具体如下：</p>
<ul>
<li>在main.rs里编写全部功能，可以忽略重构，忽略错误处理，只考虑理想情况。</li>
<li>将实现功能的业务逻辑抽取出来，独立成单个的函数。</li>
<li>在函数中进行错误处理，或者返回一个Result让main去处理。</li>
<li>最后将抽取出来的函数移动到lib里去</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;env, fs, process&#125;;<br><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> cmdddddd::&#123;Config, run&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: python</span><br><span class="hljs-comment">path: C:\Users\User\Desktop\Typora快捷键.txt</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">config</span> = Config::<span class="hljs-title function_ invoke__">new</span>(&amp;v).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error_msg| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;problem happened: &#123;&#125;&quot;</span>, error_msg);<br>        process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;);<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(&amp;config) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; (),<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;got some problem； &#123;:#?&#125;&quot;</span>, err);<br>            process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(config: &amp;Config) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">query</span> = config.<span class="hljs-title function_ invoke__">query</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = config.<span class="hljs-title function_ invoke__">file_path</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(path)?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,content);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    query: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>    file_path: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Config&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(arg: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Config, <span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> arg.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;arguments counts not good, find &#123;&#125;, need 2&quot;</span>, arg.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = &amp;arg[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = &amp;arg[<span class="hljs-number">2</span>];<br>        <span class="hljs-title function_ invoke__">Ok</span>(<br>            Config &#123;<br>                query: p1,<br>                file_path: p2,<br>            &#125;<br>        )<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">query</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.query<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">file_path</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.file_path<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-使用TDD在lib里进行查错"><a href="#4-使用TDD在lib里进行查错" class="headerlink" title="4.使用TDD在lib里进行查错"></a>4.使用TDD在lib里进行查错</h2><p>​    TDD：test driver development，测试驱动开发</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220120223838199.png" alt="image-20220120223838199"></p>
<p>​    测试部分</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_test</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-string">&quot;\n</span><br><span class="hljs-string">hi,\n</span><br><span class="hljs-string">rust-langn</span><br><span class="hljs-string">demo demo dododododod\n</span><br><span class="hljs-string">hello \n</span><br><span class="hljs-string">hhh\n</span><br><span class="hljs-string">s\n</span><br><span class="hljs-string">hhh\n</span><br><span class="hljs-string">hhh hanpi\n</span><br><span class="hljs-string">en\n&quot;</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">query</span> = <span class="hljs-string">&quot;hhh&quot;</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;demo demo dododododod&quot;</span>], <span class="hljs-title function_ invoke__">search</span>(<span class="hljs-string">&quot;demo&quot;</span>, content));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    被测试的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(query: &amp;<span class="hljs-type">str</span>, content: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lines</span> = content.<span class="hljs-title function_ invoke__">lines</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> lines &#123;<br>        <span class="hljs-keyword">if</span> line.<span class="hljs-title function_ invoke__">contains</span>(query) &#123;<br>            res.<span class="hljs-title function_ invoke__">push</span>(line);<br>        &#125;<br>    &#125;<br>    res<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​        以后使用TDD来进行测试。测试样例与功能实现分离开。</p>
<h2 id="5-使用环境变量进行选择"><a href="#5-使用环境变量进行选择" class="headerlink" title="5.使用环境变量进行选择"></a>5.使用环境变量进行选择</h2><p>​    方法如下：</p>
<p>​    程序中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">flag</span> = std::env::<span class="hljs-title function_ invoke__">var</span>(<span class="hljs-string">&quot;IGNORE_CASE&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>​    命令行中：IGNORE_CASE &#x3D; 1 cargo run</p>
<p>​    这样就可以在程序中读到环境变量了。</p>
<h2 id="6-进行错误信息定向输出"><a href="#6-进行错误信息定向输出" class="headerlink" title="6.进行错误信息定向输出"></a>6.进行错误信息定向输出</h2><p>​    我们可以使用cargo run &gt; output.txt 运行使得通过println!输出的内容定向到output.txt里面。</p>
<p>​    但是这样错误信息也输出到output里了。</p>
<p>​    可以使用eprintln!，将错误信息定向到控制台输出。</p>
<h1 id="13-迭代器-闭包"><a href="#13-迭代器-闭包" class="headerlink" title="13.迭代器 闭包"></a>13.迭代器 闭包</h1><h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h2><h3 id="1-闭包的定义"><a href="#1-闭包的定义" class="headerlink" title="1 闭包的定义"></a>1 闭包的定义</h3><p>​    定义：可以捕获其所在环境的匿名函数。</p>
<p>​    闭包是一个匿名函数，他是将一个函数的定义存放在一个变量中去，而不是函数的执行结果。这个闭包只有在遇到向里面传输参数的时候，才会去执行函数，得到返回结果。</p>
<p>​    闭包并不需要显式声明它的参数和返回值类型。因为闭包是在当前作用域内工作的，范围狭小，不是作为接口去调用的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bi_bao</span> = |num| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the num is &#123;&#125;&quot;</span>, num);<br>        num<br>    &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, <span class="hljs-title function_ invoke__">bi_bao</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">//调用bi_bao(3)的时候才是会真正执行闭包</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    将闭包绑定给变量后，变量的类型就是：<code>variable bi_bao: fn(&lt;unknown&gt;) -&gt; &lt;unknown&gt;</code></p>
<h3 id="2用结构来存储闭包"><a href="#2用结构来存储闭包" class="headerlink" title="2用结构来存储闭包"></a>2用结构来存储闭包</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cashe</span>&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    calculation: T,<br>    value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Cashe&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span><br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> Cashe&lt;T&gt; &#123;<br>        Cashe &#123;<br>            calculation,<br>            value: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, num: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.value &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(n) =&gt; n,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = (<span class="hljs-keyword">self</span>.calculation)(num);<br>                <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(res);<br>                res<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = Cashe::<span class="hljs-title function_ invoke__">new</span>(|num| num + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">32</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">92</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上面结构中的calculation，是一个泛型参数T，并且加上了限制，要求这个泛型参数是实现了Fn trait的一个闭包。</p>
<p>​    但是只能存储一次。</p>
<p>​    可以用hashmap来进行改进。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cashe</span>&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    calculation: T,<br>    value: HashMap&lt;<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Cashe&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span><br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> Cashe&lt;T&gt; &#123;<br>        Cashe &#123;<br>            calculation,<br>            value: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, num: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span> = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.value;<br>        <span class="hljs-keyword">match</span> map.<span class="hljs-title function_ invoke__">get</span>(&amp;num) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(res) =&gt; *res,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = (<span class="hljs-keyword">self</span>.calculation)(num);<br>                map.<span class="hljs-title function_ invoke__">insert</span>(num, res);<br>                res<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = Cashe::<span class="hljs-title function_ invoke__">new</span>(|num| num + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">32</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">92</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-使用闭包捕获外部变量"><a href="#3-使用闭包捕获外部变量" class="headerlink" title="3.使用闭包捕获外部变量"></a>3.使用闭包捕获外部变量</h3><p>​    闭包可以捕获和他定义于同一个作用域的变量。这是闭包独有的功能，而函数是没有的。</p>
<p>​    但是会产生额外的内存开销。</p>
<h3 id="4-闭包的trait"><a href="#4-闭包的trait" class="headerlink" title="4.闭包的trait"></a>4.闭包的trait</h3><ul>
<li>Fn            不可变借用</li>
<li>FnMut    可变借用</li>
<li>FnOnce   取得所有权</li>
</ul>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220121151726938.png" alt="image-20220121151726938"></p>
<p>​    可以使用move关键字将闭包外的所有权强行移动到闭包内。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bb</span> = <span class="hljs-keyword">move</span> ||v; <span class="hljs-comment">//移动所有权</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, v); <span class="hljs-comment">//这一行报错</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2.迭代器"></a>2.迭代器</h2><h3 id="1-iterator-trait"><a href="#1-iterator-trait" class="headerlink" title="1.iterator trait"></a>1.iterator trait</h3><p>​    实现next方法即可。</p>
<h3 id="2-几个迭代api"><a href="#2-几个迭代api" class="headerlink" title="2.几个迭代api"></a>2.几个迭代api</h3><ul>
<li>iter：在不可变引用上创建迭代器</li>
<li>into_iter：创建的迭代器会获取所有权 – 用一个数据引出迭代器，并且夺取了元数据的所有权。</li>
<li>iter_mut：迭代可变的引用 – 可以通过解引用修改其中的值。</li>
</ul>
<h3 id="3-消耗-x2F-产生-迭代器"><a href="#3-消耗-x2F-产生-迭代器" class="headerlink" title="3.消耗&#x2F;产生 迭代器"></a>3.消耗&#x2F;产生 迭代器</h3><h4 id="1-消耗（消耗性适配器）"><a href="#1-消耗（消耗性适配器）" class="headerlink" title="1.消耗（消耗性适配器）"></a>1.消耗（消耗性适配器）</h4><p>​    消耗迭代器：当调用迭代器的next方法时，会消耗迭代器，迭代器中的元素会被一个一个消除掉，这就是叫消耗的原因。rust里有些方法（针对于实现了iterator trait的类型），会自主调用next，从而消耗迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iterator</span> = v.<span class="hljs-title function_ invoke__">iter</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span>: <span class="hljs-type">i32</span> = iterator.<span class="hljs-title function_ invoke__">sum</span>(); <span class="hljs-comment">//sum消耗了迭代器</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220122155108279.png" alt="image-20220122155108279"></p>
<p>​    要调用sum这个方法，self必须实现Sizd这个trait，并且泛型参数必须实现了Sum这个trait。 </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.Sized trait: 要求这个类型必须有固定的长度，如i32，u32</span><br><span class="hljs-comment">2.Sum trait：可以进行求和</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h4 id="2-产生（迭代器适配器）"><a href="#2-产生（迭代器适配器）" class="headerlink" title="2.产生（迭代器适配器）"></a>2.产生（迭代器适配器）</h4><p>​    将一个迭代器转换成另一个迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iter1</span> = v1.<span class="hljs-title function_ invoke__">iter</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span> = iter1.<span class="hljs-title function_ invoke__">map</span>(|num| &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num)<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = map.<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iter2</span> = v2.<span class="hljs-title function_ invoke__">iter</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    map()方法：一个泛型方法，接收两个泛型参数，目的是将传进来的类型T更改成传出去的类型F。接收两个参数，第一个是self，要求实现了Sized这个trait。第二个参数是T，要求实现FnMut这个trait，也就是一个闭包，并且是可变引用，因为要对参数进行修改。</p>
<p>​    调用map方法后，迭代器的所有权被Move。</p>
<h4 id="3-迭代器-闭包-捕获环境"><a href="#3-迭代器-闭包-捕获环境" class="headerlink" title="3.迭代器+闭包 捕获环境"></a>3.迭代器+闭包 捕获环境</h4><p>​    使用filter()这个方法，一个迭代器适配器。接收一个闭包，这个闭包必须返回bool类型。若是返回true，则元素被加到迭代器里，最终作为这个方法的返回值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i1</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|num| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        **num &gt; <span class="hljs-number">90</span><br>    &#125;).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, i1);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    传进闭包后，要用collect进行收集,返回一个集合，不然闭包是不会执行的</p>
<h4 id="4-构建自定义的迭代器"><a href="#4-构建自定义的迭代器" class="headerlink" title="4.构建自定义的迭代器"></a>4.构建自定义的迭代器</h4><p>​    实现Iterator trait即可。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">e1</span> = Elem::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e1.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Elem</span> &#123;<br>    val: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Elem</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Elem &#123;<br>        Elem &#123;<br>            val: <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Elem</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">i32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    迭代器比for循环遍历要快一点。</p>
<p>​    用filter方法。</p>
<h1 id="14-发布"><a href="#14-发布" class="headerlink" title="14.发布"></a>14.发布</h1><h1 id="15-智能指针"><a href="#15-智能指针" class="headerlink" title="15.智能指针"></a>15.智能指针</h1><h2 id="1-Box-lt-T-gt"><a href="#1-Box-lt-T-gt" class="headerlink" title="1.Box&lt; T &gt;"></a>1.Box&lt; T &gt;</h2><p>​    Rust中所有的类型在编译时都会知道大小。</p>
<p>​    考虑C语言中的链表的实现，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    有两个类型，一个是int，一个是指针。这实际就是一个递归，只不过递归的是指针，并不是结构，如果是结构的话，就永远无法知道声明一个struct的时候应该分配多少大小了。所以用的是指针。指针存放在栈上，就是一个地址而已。</p>
<p>​    rust也是类似的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l</span> = Node &#123;<br>        value: <span class="hljs-number">1</span>,<br>        next: <span class="hljs-title function_ invoke__">Some</span>(Box::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>            value: <span class="hljs-number">2</span>,<br>            next: <span class="hljs-literal">None</span>,<br>        &#125;))<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, l);<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>    next: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    Box这个类型就是一个智能指针，实现了两个trait，deref的目的是确保Box可以被当成一个引用实现；drop则是确保Box在离开作用域时，其指针（栈内存）和指向的数据（堆内存）都会被释放。</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220123150617915.png" alt="image-20220123150617915"></p>
<h2 id="2-deref-trait"><a href="#2-deref-trait" class="headerlink" title="2.deref trait"></a>2.deref trait</h2><h3 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h3><p>​    实现这个trait后，可以确保类型被当成引用来使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Box::<span class="hljs-title function_ invoke__">new</span>(n);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, n);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, *m);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-实现Deref-trait"><a href="#2-实现Deref-trait" class="headerlink" title="2.实现Deref trait"></a>2.实现Deref trait</h3><p>​    给结构实现deref trait即可。</p>
<p>​    具体的话，就是指定一下类型，然后实现deref方法即可。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(m, *n);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt;(T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-deref-coercion"><a href="#3-deref-coercion" class="headerlink" title="3.deref coercion"></a>3.deref coercion</h3><p>​    假设实现了deref trait，然后传入的是引用，那么编译器就会自动调用deref方法，将&amp;Box<T> -&gt; &amp;T。</T></p>
<p>​    如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-title function_ invoke__">fun</span>(&amp;a);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>(s: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    首先将&amp;MyBox<String> -&gt; &amp;String，由于String类型实现了deref trait，所以 &amp;String -&gt; &amp;str，所以参数就匹配了。</String></p>
<p>​    并且，所有的这些操作，都是在编译期完成的，不会产生额外的运行时性能开销。</p>
<h2 id="3-drop-trait"><a href="#3-drop-trait" class="headerlink" title="3.drop trait"></a>3.drop trait</h2><p>​    变量在离开作用域时，会自动调用drop方法，来释放相关的资源。</p>
<p>​    不可以提前调用drop trait的drop方法，但是可以提前释放资源，使用另外一个drop方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-title function_ invoke__">drop</span>(s);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-Rc-lt-T-gt"><a href="#4-Rc-lt-T-gt" class="headerlink" title="4.Rc&lt; T &gt;"></a>4.Rc&lt; T &gt;</h2><p>​    引用计数智能指针</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;s1)); <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;s1)); <span class="hljs-comment">//3</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    为什么要有Rc<T>？</T></p>
<p>​    把Box<T>传进去之后，Box会夺取T的所有权，所以如果还想复用T的话，或者是在别的地方传入Box<T>，那么就会报错，因为T已经被移动了。</T></T></p>
<p>​    使用Rc就不一样了，如果函数接收的是Rc<T>，那么传入Rc::clone(&amp;T)就可以了，这个clone函数并不会深拷贝，只是增加引用计数，返回一个Rc<T>。</T></T></p>
<p>​    使用了Rc<T>，就相当于单个值有了多个所有者。</T></p>
<p>​    Rc使用的是不可变引用，如果是可变引用就会违反引用规则。并且，Rc只能在单线程下使用。</p>
<h2 id="5-RfCell-lt-T-gt"><a href="#5-RfCell-lt-T-gt" class="headerlink" title="5.RfCell&lt; T &gt;"></a>5.RfCell&lt; T &gt;</h2><p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220123172820248.png" alt="image-20220123172820248"></p>
<h1 id="16-并发"><a href="#16-并发" class="headerlink" title="16.并发"></a>16.并发</h1><h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><p>​    创建线程的两种方式：</p>
<ul>
<li>通过OS的api来创建 – 运行时小 – 1  : 1</li>
<li>语言自己实现的线程 – 运行时大 – M : N</li>
</ul>
<p>​    Rust提供的是1:1线程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread: &#123;&#125;&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;main: &#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    这样写，一旦主线程结束了，我们创建的线程也就停止了。可以通过join方法来阻塞主线程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread: &#123;&#125;&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;main: &#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br><br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">//只有j的线程结束后，才会恢复主线程的执行</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    可以使用move将主线程里的值的所有权强制移动到分线程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> v &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>        &#125;<br>    &#125;);<br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-通过channel实现线程通信"><a href="#2-通过channel实现线程通信" class="headerlink" title="2.通过channel实现线程通信"></a>2.通过channel实现线程通信</h2><p>​    通过mpsc的一个关联函数可以构造一个元组（send, receive）</p>
<p>​    mpsc的意思：多个生产者，一个消费者。multiple producer， single consumer</p>
<p>​    可以通过克隆来实现多个发送者。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (send, receive) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">send1</span> = send.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ss</span> = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> ss &#123;<br>            send.<span class="hljs-title function_ invoke__">send</span>(s).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ss</span> = [<span class="hljs-string">&quot;111hello&quot;</span>, <span class="hljs-string">&quot;111world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot;111from&quot;</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> ss &#123;<br>            send1.<span class="hljs-title function_ invoke__">send</span>(s).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">r</span> <span class="hljs-keyword">in</span> receive &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r);<br>    &#125;<br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    j1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-Mutex-lt-T-gt-共享内存"><a href="#3-Mutex-lt-T-gt-共享内存" class="headerlink" title="3.Mutex&lt; T &gt;共享内存"></a>3.Mutex&lt; T &gt;共享内存</h2><p>​        Mutex就是一个互斥锁，使用数据前需要先获取锁，然后使用完后需要释放锁。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;mpsc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = n.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num = <span class="hljs-number">7</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="hljs-comment">//n从5到7</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    mutex可能会产生死锁</p>
<h2 id="4-Arc-lt-T-gt-原子引用计数"><a href="#4-Arc-lt-T-gt-原子引用计数" class="headerlink" title="4.Arc&lt; T &gt;原子引用计数"></a>4.Arc&lt; T &gt;原子引用计数</h2><p>​    在外面克隆引用，然后把克隆的引用传进去。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, mpsc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l1</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;n);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = l1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num += <span class="hljs-number">999</span>;<br>    &#125;);<br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="hljs-comment">//1004</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>ceshi:</p>
<p><img src="/images/loading.png" srcset="/img/loading.gif" lazyload data-original="/2022/02/14/rust-lang/image-20220214142148258.png" alt="image-20220214142148258"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络-自顶向下</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/13/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
