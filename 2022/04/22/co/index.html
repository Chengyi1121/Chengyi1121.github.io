

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="计组  存储器  1.内存的基本概念（分类+性能指标）  1.按照硬件（存储介质）分类  半导体存储器 磁表面存储器 磁心存储器 光盘存储器  ​	其中磁心存储器已经淘汰。  2.按照存取方式分  随机存取存储器RAM：分SRAM（静态，作为cache），DRAM（动态，与ROM共同组成内存） 随机存，不可写ROM（只读存储器）：分为MROM（M代表mask，掩模式，只能厂家写，写入不可更改），P">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="http://example.com/2022/04/22/co/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="计组  存储器  1.内存的基本概念（分类+性能指标）  1.按照硬件（存储介质）分类  半导体存储器 磁表面存储器 磁心存储器 光盘存储器  ​	其中磁心存储器已经淘汰。  2.按照存取方式分  随机存取存储器RAM：分SRAM（静态，作为cache），DRAM（动态，与ROM共同组成内存） 随机存，不可写ROM（只读存储器）：分为MROM（M代表mask，掩模式，只能厂家写，写入不可更改），P">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220407201118709.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220417001008064.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220417000952835.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220417001027645.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220412000609194.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220417001603570.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220410224748684.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220410225933542.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220410230438645.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220410230453429.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220410230750911.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414145720038.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414150838093.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414150953000.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414151048639.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/biao3_5.gif">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220418155515136.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414143650227.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414143723371.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414143739699.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414143755146.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414143803492.png">
<meta property="og:image" content="http://example.com/2022/04/22/co/image-20220414143547117.png">
<meta property="article:published_time" content="2022-04-22T08:24:14.229Z">
<meta property="article:modified_time" content="2022-04-22T08:24:14.230Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/04/22/co/image-20220407201118709.png">
  
  
  <title>计算机组成原理 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计算机组成原理">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-22 16:24" pubdate>
        April 22, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.6k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      64 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机组成原理</h1>
            
            <div class="markdown-body">
              <p>计组</p>
<h1 id="存储器"><a class="markdownIt-Anchor" href="#存储器"></a> 存储器</h1>
<h2 id="1内存的基本概念分类性能指标"><a class="markdownIt-Anchor" href="#1内存的基本概念分类性能指标"></a> 1.内存的基本概念（分类+性能指标）</h2>
<h3 id="1按照硬件存储介质分类"><a class="markdownIt-Anchor" href="#1按照硬件存储介质分类"></a> 1.按照硬件（存储介质）分类</h3>
<ul>
<li>半导体存储器</li>
<li>磁表面存储器</li>
<li>磁心存储器</li>
<li>光盘存储器</li>
</ul>
<p>​	其中磁心存储器已经淘汰。</p>
<h3 id="2按照存取方式分"><a class="markdownIt-Anchor" href="#2按照存取方式分"></a> 2.按照存取方式分</h3>
<ul>
<li>随机存取存储器RAM：分SRAM（静态，作为cache），DRAM（动态，与ROM共同组成内存）</li>
<li>随机存，不可写ROM（只读存储器）：分为MROM（M代表mask，掩模式，只能厂家写，写入不可更改），PROM（可进行一次编程，由用户），EPROM（有限次编程，可擦除），EEPROM（可多次编程，电擦除），flash闪存（快速擦除，只读）。</li>
<li>串行访问存储器
<ul>
<li>顺序存取：磁带</li>
<li>直接存取：磁盘，先寻磁道（随机），然后在磁道中旋转（顺序），找到有用的信息</li>
</ul>
</li>
</ul>
<p>​	ps：flash闪存很快，且r速度&gt;w速度，因为写的话首先得进行擦除，所以慢</p>
<h3 id="3性能指标"><a class="markdownIt-Anchor" href="#3性能指标"></a> 3.性能指标</h3>
<ul>
<li>价格</li>
<li>容量</li>
<li>速度（性能）</li>
</ul>
<p>​	ps：在速度上，区分一下存储时间和存储周期。</p>
<ul>
<li>存储时间：从写开始到写结束</li>
<li>存储周期：从写开始到下一次写开始</li>
</ul>
<p>​	一般，存储时间&lt;存储周期，因为当存储结束后，此次存储操作并没有结束，如要进行刷新等操作，所以慢。</p>
<p>​	但肯定的是，地址信号存在，存储周期存在，地址信号结束，存储周期结束。</p>
<h2 id="2分层结构"><a class="markdownIt-Anchor" href="#2分层结构"></a> 2.分层结构</h2>
<p>​	分层为了解决：大容量，低价格，高速度三者之间的矛盾问题。这是分层的核心。</p>
<p>​	所有的存储分层，都可以归纳两个方面：</p>
<ul>
<li>cache-主存：解决了cpu速度与贮存速度不匹配的问题</li>
<li>主存-辅存：解决了主存容量小的问题。</li>
</ul>
<p>​	两者都解决了低价格的问题。</p>
<p>ps：cpu可以和cache，主存直接交换信息，而辅存只能通过主存和cpu，cache交换信息。同时，高层相当于是低层的副本，高层（cache）的内容在低层中都能找到。另外，cache-主存由硬件完成，主存-辅存由OS+硬件完成（回顾分页中的页表寄存器和调入调出算法）</p>
<h2 id="3半导体随机存取存储器"><a class="markdownIt-Anchor" href="#3半导体随机存取存储器"></a> 3.半导体随机存取存储器</h2>
<p>​	记录SRAM和DRAM。功能是：读数据，写数据，存储数据。</p>
<p>PS：这里对集成度做一个说明。<strong>集成度</strong>，是指图形中最小线条宽度，<strong>集成</strong>电路的<strong>集成度</strong>是指单块芯片上所容纳的元件数目，<strong>集成度</strong>越高，所容纳的元件数目越多，为此对传统的光刻方法进行了很多改进以满足分辨率的要求，增加<strong>集成</strong>电路的<strong>集成度</strong>。</p>
<ul>
<li>集成度越高，单块芯片上就能容纳更多的原件，容量越大</li>
<li>集成度越低，单块芯片容纳的元件越少，容量越低。</li>
</ul>
<p>​	所以DRAM要耗费更多的硅和更大的体积（要达到相同的容量）。</p>
<h3 id="1sram"><a class="markdownIt-Anchor" href="#1sram"></a> 1.SRAM</h3>
<p>​	动态随机存取存储器。</p>
<p>​	这个很贵，由MOS和触发器构成。MOS进行控制，触发器存储数据。</p>
<p>​	SRAM由触发器存储二进制位，故不需要刷新（再生），但是掉电会丢失原数据，所以属于易失型存储器。</p>
<p>​	SRAM的集成度低，价格昂贵，常用作cache。</p>
<h3 id="2dram"><a class="markdownIt-Anchor" href="#2dram"></a> 2.DRAM</h3>
<p>​	DRAM是通过电容来存储一位二进制位的，通过一个MOS来控制，起到开关作用。所以造价便宜。</p>
<p>​	但是由于电容会自己放电，所以需要进行刷新操作来保持位的持久性。</p>
<p>​	<img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220407201118709.png" alt="image-20220407201118709"></p>
<p>​</p>
<p>​	红色的是MOS，作为开关使用，当输入5V时，导通，电路接通，可以进行读写数据。</p>
<ul>
<li>读数据：读1就是高电平，读0就是低电平。</li>
<li>写数据：写1高电平，写0低电平</li>
</ul>
<p>​	另外，读写时间都是小于读写周期的。</p>
<p>​	然后，DRAM如果采用地址复用技术（时分复用），假设存储芯片规格为2K*8b。那么就是11根地址线，我们采用时分复用的话，就是11 = 5 + 6，所以行数5，列数6，所以只需要6根地址线，分两次运送到MAR中即可。**为什么行数是5？**因为刷新是按行刷新的，行数越少，刷新周期越短。</p>
<h3 id="3dram的刷新"><a class="markdownIt-Anchor" href="#3dram的刷新"></a> 3.DRAM的刷新</h3>
<p>​	DRAM刷新一般是先读出数据，然后再写入回去，这样算下来就是两个周期，也就是2T。但是实际做题中，若无特别说明，我们把刷新时间记为T。（除非题目说明刷新时间既有读也有写）</p>
<p><strong>ps：这是天勤上的解释，并不准确！</strong></p>
<p>​	课本上的解释（王道也是这么说的）是说，DRAM的再生是，先读出存储单元中的信息，然后通过刷新放大器形成原信息后再写回去，而刷新放大器是位于DRAM芯片内部集成的。<strong>综上所述：一般认为DRAM的刷新周期为一个存储周期，除非特殊说明。</strong></p>
<p>​	首先我们要了解<strong>刷新周期</strong>，每个存储单元的刷新时间一般是2ms，而一次读写周期一般是us级别。所以一次刷新周期内可以进行多次读写操作。最后，我们将一次完整的读写周期所消耗的时间称为<strong>存储周期</strong>。</p>
<p>​	然后是为什么要刷新：</p>
<p>定时刷新的原因：由于存储单元的访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的读/写操作，其存储单元内的原信息将会慢慢消失，为此，必须采用定时刷新的方法，它规定在一定的时间内，对动态RAM的全部基本单元电路必作一次刷新，一般取2ms，即刷新周期（再生周期）。</p>
<p>刷新与行地址有关。刷新时一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本单元电路的逐行刷新，才能保证DRAM内的信息不丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。<br>
①刷新周期为2ms<br>
②存取周期为0.5μs，即刷新1行的时间为0.5μs（刷新时间是等于存取周期的。因为刷新的过程与一次存取相同，只是没有在总线上输入输出。存取周期＞真正用于存取的时间，因为存取周期内、存取操作结束后仍然需要一些时间来更改状态。对于SRAM也是这样，对于DRAM更是如此）。<br>
③对128×128的矩阵的存储芯片进行刷新，按存储单元(1B/单元)分为128行128列，即128×128×1B/单元=2^14个单元×1B/单元 = 16KB内存。 （如果是64×64的矩阵，则为64×64×1B/单元=2^12个单元×1B/单元 = 4KB内存）</p>
<p>​	下面是三种刷新方式：</p>
<ul>
<li>集中刷新：在一个刷新的最后一段时间内，暂停读写，进行集中刷新。
<ul>
<li>缺点：有死区（死时间）</li>
</ul>
</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220417001008064.png" alt="image-20220417001008064"></p>
<ul>
<li>分散刷新：将存储周期变异，变异后的存储周期为“<strong>一次存储周期+刷新一行的时间</strong>”。
<ul>
<li>缺点：没有死区。但是大大降低了读写性能。（同时这个没有死区有点自欺欺人，下面会详细说）</li>
</ul>
</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220417000952835.png" alt="image-20220417000952835"></p>
<ul>
<li>异步刷新：将所有行的刷新时间平均到一次刷新周期内。假设刷新周期2ms，芯片128字数（行数）*128存储字长。所以就是再一次刷新周期内，每隔2ms/128=15.6us刷新一行。</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220417001027645.png" alt="image-20220417001027645"></p>
<ul>
<li>死时间：死时间的定义给出，在存储周期之外不能进行读写操作，并且是用来<strong>进行刷新操作的时间</strong>。同时，这段时间要求是连续的不能积累</li>
</ul>
<p>PS：为何刷新与存取不能并行？因为内存就一套地址译码和片选装置，刷新与存取有相似的过程，它要选中一行——这期间片选线、地址线、地址译码器全被占用着。同理，刷新操作之间也不能并行——意味着一次只能刷一行。</p>
<h2 id="4存储器与cpu的连接"><a class="markdownIt-Anchor" href="#4存储器与cpu的连接"></a> 4.存储器与CPU的连接</h2>
<h3 id="1存储器的扩展"><a class="markdownIt-Anchor" href="#1存储器的扩展"></a> 1.存储器的扩展</h3>
<h4 id="1位扩展扩展存储字长"><a class="markdownIt-Anchor" href="#1位扩展扩展存储字长"></a> 1.位扩展（扩展存储字长）</h4>
<p>​	两片并联在一起，共享地址A，片选CS，读写WE线。输出的数据，一个作为高位，一个低位。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220412000609194.png" alt="image-20220412000609194"></p>
<h4 id="2字扩展扩展存储单元数"><a class="markdownIt-Anchor" href="#2字扩展扩展存储单元数"></a> 2.字扩展（扩展存储单元数）</h4>
<p>​	地址线分为两部分，一部分就是直接连接到存储体上的，选中存储单元。另外一部分就是进行片选，有两种片选方式：</p>
<ul>
<li>线选法：直接通过地址线片选，n根地址线可以片选n片</li>
<li>译码片选法：利用译码器片选，n根地址线可以片选2^n片。</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220417001603570.png" alt="image-20220417001603570"></p>
<h4 id="3字位扩展"><a class="markdownIt-Anchor" href="#3字位扩展"></a> 3.字位扩展</h4>
<p>​	同时拓展。</p>
<h3 id="2存储器与cpu的连接"><a class="markdownIt-Anchor" href="#2存储器与cpu的连接"></a> 2.存储器与CPU的连接</h3>
<h3 id="3提高访存的措施"><a class="markdownIt-Anchor" href="#3提高访存的措施"></a> 3.提高访存的措施</h3>
<h4 id="1双端口ram"><a class="markdownIt-Anchor" href="#1双端口ram"></a> 1.双端口RAM</h4>
<p>为了解决多核系统设计出的一种模型。</p>
<p>RAM存储体上有两个端口，可以与两个CPU交换信息，有两套控制线，地址线，数据线等</p>
<ul>
<li>对同一地址单元，两读：ok</li>
<li>对不同地址单元，任何操作：ok</li>
<li>对同一地址单元，一读一写：read err，会给出busy信号</li>
<li>对同一地址单元，两写：write err，会给出busy信号。</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220410224748684.png" alt="image-20220410224748684"></p>
<h4 id="2单体多字系统"><a class="markdownIt-Anchor" href="#2单体多字系统"></a> 2.单体多字系统</h4>
<p>一个存取周期内，能取出多个存储字。但要求数据和指令在存储器中的存放是连续的。能显著提高存储器的带宽与速度，但是限制大。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220410225933542.png" alt="image-20220410225933542"></p>
<h4 id="3多体并行系统"><a class="markdownIt-Anchor" href="#3多体并行系统"></a> 3.多体并行系统</h4>
<h5 id="1高位交叉编址"><a class="markdownIt-Anchor" href="#1高位交叉编址"></a> 1.高位交叉编址</h5>
<p>​	顺序存储，一个访存周期中，对存储单元的访问很短，也就是说cpu的利用率很短，大部分时间在等待存储单元数据的恢复。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220410230438645.png" alt="image-20220410230438645"></p>
<p>​	高位交叉编址，也可以叫顺序编址，这种方案只能顺序的访存，并且若一个存储体working，其它的存储体不能进行访存。因此，不符合局部性原理。</p>
<p>若一个存储体损坏，则其它存储体可以正常工作。</p>
<h5 id="2低位交叉编址"><a class="markdownIt-Anchor" href="#2低位交叉编址"></a> 2.低位交叉编址</h5>
<p>交叉存储，可以使用流水线技术，提高cpu和存储器的利用率。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220410230453429.png" alt="image-20220410230453429"></p>
<p>​	结合坐标图：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220410230750911.png" alt="image-20220410230750911"></p>
<p>采用流水线技术并行访存，能够在一个存储周期内取出多个存储单元。因此，在访问某一块时，可以访问周围的几块，是满足局部性原理的。另外，一次访存周期只能从M0开始取出，不能从中间取出。</p>
<h2 id="5cache"><a class="markdownIt-Anchor" href="#5cache"></a> 5.cache</h2>
<p>cache的出现背景：</p>
<ul>
<li>io访存优先级&gt;cpu访存</li>
<li>sram的速度增长赶不上cpu速度的增长（cpu每年提升60%，sram每年提升7%）</li>
</ul>
<p>​	因此，在cpu与内存间增加高速缓存，以解决这种冲突。</p>
<h3 id="1局部性原理"><a class="markdownIt-Anchor" href="#1局部性原理"></a> 1.局部性原理</h3>
<ul>
<li>时间局部性：正在使用的数据，在未来也很可能会继续使用</li>
<li>空间局部性：未来要使用的信息，可能与现在使用的信息是相邻存放的。</li>
</ul>
<p>PS：根据局部性原理，容易得到，for循环遍历二维数组，按行比按列快，原因是高速缓存的存在。</p>
<h3 id="2cache结构"><a class="markdownIt-Anchor" href="#2cache结构"></a> 2.cache结构</h3>
<p>​	cache是SRAM组成的，和内存一样，也是按块划分的，并且块的大小是一样的。只不过cache昂贵，集成度低，所以比较小。所以cache中的块数也少于内存中的块，只是用来存放程序中近期要使用的代码数据。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414145720038.png" alt="image-20220414145720038"></p>
<h3 id="3cache-主存的映射方式"><a class="markdownIt-Anchor" href="#3cache-主存的映射方式"></a> 3.cache-主存的映射方式</h3>
<p>​	首先内存地址，是分块的，是有内存块号和块内地址组成的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">内存块号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>​	CPU给出的是内存地址，但是我们想要先去缓存中寻找（或者缓存内存并行寻找），所以首先要解决的问题就是：如何由内存地址，在缓冲区的地址空间中找到正确的块？</p>
<p>​	我们需要从内存地址中提炼出一些信息便于寻找，这和我们的映射方式有关。</p>
<h4 id="1直接映射"><a class="markdownIt-Anchor" href="#1直接映射"></a> 1.直接映射</h4>
<p>​	直接映射的原理是：给出一个内存地址，从低到高依次是，块内地址，块号。块内地址是无需改变的。选择<strong>将内存块号细化为两部分：tag和cache块号</strong>，对cache块的数量进行mod运算，得到两部分，余数是低位，选择余数作为主存块对应cache的块号；而商，作为tag标记位，当根据cache行号找到cache行后，还需比较标记位和有效位是否满足。</p>
<p>​	即：内存块号划分两部分，tag + cache块号，低位是块号，高位是标记。</p>
<ul>
<li>cache块号：用于在cache中找到对应的cache块</li>
<li>tag：找到cache后，需要用tag进行对比，其中这个tag存放在一张表（地址映射表）中。</li>
</ul>
<p>​	综上，在直接映射方式中，内存对应的地址结构为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标记tag</th>
<th style="text-align:center">cache块号</th>
<th style="text-align:center">块内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>​	cache中的地址结构为：</p>
<table>
<thead>
<tr>
<th>cache块号</th>
<th>cache块内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<ul>
<li>缺点：抖动，cache利用率低。</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414150838093.png" alt="image-20220414150838093"></p>
<h4 id="2全相联映射"><a class="markdownIt-Anchor" href="#2全相联映射"></a> 2.全相联映射</h4>
<p>​	原理：内存块可以放到任意的cache行上。</p>
<p>​	内存的地址结构：</p>
<table>
<thead>
<tr>
<th>内存块号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>​	cache的地址结构：</p>
<table>
<thead>
<tr>
<th>tag标记</th>
<th>块内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>​	也就是说内存块号对应着cache地址映射表中的tag</p>
<p>​	我们可以看到，这样的话，要想访问内存块，需要先在缓存中对tag进行一个一个的比较，时间消耗大，但是对比直接映射，大大提高了cache的利用率。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414150953000.png" alt="image-20220414150953000"></p>
<h4 id="3组相联映射"><a class="markdownIt-Anchor" href="#3组相联映射"></a> 3.组相联映射</h4>
<p>​	综上，我们能不能综合两个映射方式的优点，弱化缺点，既能提高cache利用率，也能快速查找。所以，我们选择对cache进行分组，每个分组采用直接映射的思想，分组内部采用全相联映射的思想。这样，既能快速查找到对应的分组，也能提高每个分组内部cache行的利用率，并且分组内查找的速度也不是很慢。</p>
<p>​	内存的地址结构：</p>
<table>
<thead>
<tr>
<th>内存块号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>​	组相联映射下cache的地址结构：</p>
<table>
<thead>
<tr>
<th>tag</th>
<th>cache组号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody></tbody>
</table>
<p>​	假设cache中分八组，也就是组0~组7，那么main memory里面的内存块就对8进行mod运算，得到的商和余数，商即是内存块所在的组号，余数就是内存块在cache中的块号。</p>
<p>PS：核心是算出<strong>cache的分组数</strong>目。例如分组为2路的，那么就是每组两个cache块，依次可以算出cache的分组数。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414151048639.png" alt="image-20220414151048639"></p>
<h4 id="4映射策略引入的冗余"><a class="markdownIt-Anchor" href="#4映射策略引入的冗余"></a> 4.映射策略引入的冗余</h4>
<p>​	按理说cache行中只存放数据部分是最理想的状况。但实际情况下，需要寻址，校验等过程，所以需要在cache行中引入额外的比特消耗。</p>
<ul>
<li>直接映射：引入了<strong>tag标记</strong>和<strong>有效位</strong></li>
<li>全相联映射：只引入了<strong>tag标记</strong></li>
<li>组相联映射：<strong>tag标记</strong>和<strong>cache组号</strong></li>
</ul>
<p>PS：为何没引入cache块号？因为cache块号一般默认是从0开始的，cache行也是从0开始算的，所以不需要额外引入这个字段。</p>
<p>PS：以上只是做题和看书得出的总结，事实上还有更多的额外比特，参考下表：</p>
<table>
<thead>
<tr>
<th>有效位</th>
<th>脏位</th>
<th>替换控制位</th>
<th>标记位tag</th>
</tr>
</thead>
<tbody></tbody>
</table>
<h3 id="4cache的替换算法"><a class="markdownIt-Anchor" href="#4cache的替换算法"></a> 4.cache的替换算法</h3>
<h4 id="1三种替换算法"><a class="markdownIt-Anchor" href="#1三种替换算法"></a> 1.三种替换算法</h4>
<p>​	当出现内存块替换cache中的块时，需要使用到替换算法。</p>
<p>PS：若是直接映射，内存块映射到固定的cache行上，则不需要替换算法</p>
<ul>
<li>随机算法</li>
<li>先进先出算法</li>
<li>近期最少使用算法LRU</li>
</ul>
<p>​		其中LRU需要重点掌握，因为这个最难，下面是LRU的解释及解题过程：</p>
<table>
<thead>
<tr>
<th>第三章 存储系统</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>2、LRU算法及其实现</strong>  　　最久没有使用算法（LRU算法）在虚拟存储器中是使用最普遍的一种算法。这种算法选择最久没有被访问的块作为被替换的块，显然，这是一种比较合理的做法。因为到目前为止最久没有被访问的块，很可能也是将来最少访问的块。因此，LRU算法既利用了历史上Cache中块地址流的调度情况，又正确反映了程序的局部性特点。 　　为了实现LRU算法，要在块表中为每一块设置一个计数器。计数器的长度与上面介绍的轮换法相同。 　　计数器的使用及管理规则是： 　　被装入或被替换的块，其对应的计数器清为&quot;0&quot;，同组中其它所有块所属的计数器都加&quot;1&quot;。 　　命中的块，其对应的计数器清为&quot;0&quot;。同组中其它所有计数器中，凡是计数器的值小于命中块所属计数器原来值的，都加&quot;1&quot;，其它计数器不变。 　　需要替换时，在同组的所有计数器中选择计数值最大（一般为全1）的计数器，它所对应的块就是要被替换的块。 　　例如，IBM 370/165机的Cache采用组相联映象方式。每组有4块，为了实现LRU替换算法，在块表中为每一块设置一个2位的计数器。在访问Cache的过程中，块的装入、替换及命中时，计数器的工作情况如表3.5所示。<strong>表3.5 LRU替换算法的工作情况</strong> <img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/biao3_5.gif" alt="img">　　LRU算法与前面介绍的两种轮换法相比，它的控制逻辑要复杂些，增加了判断和处理命中的情况。然而，由于它既能够比较正确地利用程序的局部性特点，又能比较充分地利用历史上块地址流的分布情况。因此，LRU算法的命中率是比较高的。在虚拟存储器的页面替换算法中，曾经说明过LRU算法是一种堆栈型算法。随着每一组的块数增加，Cache的命中率能够单调上升。</td>
</tr>
</tbody>
</table>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220418155515136.png" alt="image-20220418155515136"></p>
<h4 id="2替换算法引入的冗余"><a class="markdownIt-Anchor" href="#2替换算法引入的冗余"></a> 2.替换算法引入的冗余</h4>
<ul>
<li>随机算法：无</li>
<li>先进先出算法：无</li>
<li>LRU算法：引入计数器，计数器的位数与cache的组数有关，两组时为1，4组时为2…，即log2(组数)</li>
</ul>
<h3 id="5cache写策略"><a class="markdownIt-Anchor" href="#5cache写策略"></a> 5.cache写策略</h3>
<p>​	一般是两种组合方式：</p>
<ul>
<li>全写法 + 非写分配法</li>
<li>回写法 + 写分配法</li>
</ul>
<h4 id="1写命中"><a class="markdownIt-Anchor" href="#1写命中"></a> 1.写命中</h4>
<h5 id="1全写法"><a class="markdownIt-Anchor" href="#1全写法"></a> 1.全写法</h5>
<p>​	当cpu写命中时：在cache和主存中都进行重写入。</p>
<p>​	当需要替换cache块时，直接覆盖cache中的块即可，不用回写内存中去。</p>
<h5 id="2回写法"><a class="markdownIt-Anchor" href="#2回写法"></a> 2.回写法</h5>
<p>​	当cache写命中时，直接写入cache中即可，并且给cache增加一个脏位，用于在cache覆盖时，判断cache是否被修改过，是的话就需要回写内存。</p>
<h4 id="2写不命中"><a class="markdownIt-Anchor" href="#2写不命中"></a> 2.写不命中</h4>
<p>​	对于写不命中时，有以下策略：</p>
<h5 id="1写分配法"><a class="markdownIt-Anchor" href="#1写分配法"></a> 1.写分配法</h5>
<p>​	cpu去内存中对内存块进行写操作，并且把更新完的内存块调入cache</p>
<h5 id="2非写分配法"><a class="markdownIt-Anchor" href="#2非写分配法"></a> 2.非写分配法</h5>
<p>​	只写内存，不调入cache</p>
<h4 id="3写策略引入的冗余"><a class="markdownIt-Anchor" href="#3写策略引入的冗余"></a> 3.写策略引入的冗余</h4>
<p>​	回写法要设置一个脏位</p>
<h2 id="6外存"><a class="markdownIt-Anchor" href="#6外存"></a> 6.外存</h2>
<h3 id="1磁盘hdd"><a class="markdownIt-Anchor" href="#1磁盘hdd"></a> 1.磁盘HDD</h3>
<p>​	<strong>磁盘的组成</strong>：磁盘驱动器，磁盘控制器，盘片：</p>
<ul>
<li>磁盘驱动器：磁头组件 + 盘片组件</li>
<li>磁盘控制器：硬盘和主机的接口</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414143650227.png" alt="image-20220414143650227"></p>
<p>​	<strong>磁盘的存储区域</strong>：一块硬盘有几个记录面，一个记录面有若干磁道，每条磁道划分为多条扇区。扇区（块）是磁盘的最小读写单位。</p>
<ul>
<li>磁道：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。</li>
<li>盘片：盘片用来存储数据，被密封在硬盘内部，运用其上附着的磁性物质达到读写数据的目的</li>
<li>磁面：在一块硬盘中并不是只有一张盘片，而是有多个盘片，每个盘片的上、下两个面一般都会用来存储数据，即有效盘面，通常称为磁面</li>
<li>柱面：硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的0开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。</li>
<li>扇区：从外圈磁道开始取一定长度作为一个扇区，然后从外向里一个一个编号下去。这个编号就是扇区的地址，要确定文件在哪里全靠这个地址</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414143723371.png" alt="image-20220414143723371"></p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414143739699.png" alt="image-20220414143739699"></p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414143755146.png" alt="image-20220414143755146"></p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414143803492.png" alt="image-20220414143803492"></p>
<p>​	磁盘的性能指标：</p>
<ul>
<li>记录密度</li>
<li>容量</li>
<li>平均存取时间</li>
<li>数据传输率</li>
</ul>
<p>​	其中平均存取时间是我们需要计算的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs c">平均存取时间 = 寻道时间 + 延迟时间 + 传输时间<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>平均寻道时间</strong>：一般会给出磁盘转速，由此可以求出转一圈的时间，而这里取平均，就是半圈，所以取一般即可。</li>
<li><strong>延迟时间</strong>：题目给出</li>
<li><strong>传输时间</strong>：磁头扫过一个扇区的用时。磁盘转一周的时间÷扇区个数。</li>
</ul>
<h3 id="2磁盘阵列"><a class="markdownIt-Anchor" href="#2磁盘阵列"></a> 2.磁盘阵列</h3>
<p>​	将物理上隔离的几个磁盘逻辑上组成在一起，数据在物理盘上交叉存储，并行访问。</p>
<p>​	磁盘阵列的简写是RAID，有几种不同的RAID分级：</p>
<ul>
<li>RAID0：无冗余无校验，不能容错</li>
<li>RAID1：镜像存储，容量减小一半，但换来了可靠性</li>
<li>RAID2：纠错海明码</li>
<li>RAID3：位交叉奇偶校验</li>
<li>RAID4：块交叉奇偶校验</li>
<li>RAID5：。。。</li>
</ul>
<p>​	RAID通过组织多个物理磁盘成为一个逻辑盘，即并行存取提高了存取速度，还能够通过镜像，纠错提高可靠性。</p>
<p>PS：RAID分级做到 的优点只有：<strong>并行存取 + 可靠（镜像/纠错）</strong>。只有这两个，其他的是无稽之谈。</p>
<h3 id="3固态硬盘ssd"><a class="markdownIt-Anchor" href="#3固态硬盘ssd"></a> 3.固态硬盘SSD</h3>
<p>​	明确的是，SSD是基于闪存的，也就是一种ROM。</p>
<p>​	闪存由多个闪存芯片和闪存翻译层组成（闪存芯片替代的是机械硬盘中的机械驱动器。PS：参考磁盘驱动器）。闪存翻译层负责将cpu发出的信号翻译对闪存的读写信号。</p>
<p>​	SSD中的存储部分由很多快组成，每块分为很多页。共同组成了闪存。然后要想写一个页，这个页所属的块必须是新的（被擦除过的）；若不是新的，那么就得把这个页所属的块拷贝到另一个新的块中去，然后再擦除块，再对目标页进行写。</p>
<ul>
<li>优点：半导体器件，很快，能耗低。</li>
<li>缺点
<ul>
<li>反复写后，闪存块会磨损</li>
<li>随机写慢：1.先要擦除块，比较慢，比读页慢一个数量级。2.如果写的页中已有数据，那么就得拷贝+擦除后，才能写。</li>
</ul>
</li>
</ul>
<p>​	但是，针对块磨损，SSD的翻译层中有一个平均磨损逻辑，可以通过将擦除平均分配到所有的块上，来最大化每个块的寿命</p>
<p>PS：这里可以适当回顾一下 异步刷新的思想，也是将集中刷新的死时间均分到一个刷新周期内，分摊处理。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/co/image-20220414143547117.png" alt="image-20220414143547117"></p>
<h1 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h1>
<script>
    if("qcy20011121"==prompt("请输入文档密码"))
    {
        alert("密码正确");
    }
    else
    {
        alert("密码错误返回主页");
        location="/";
    }
</script>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/22/cn/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/22/os/">
                        <span class="hidden-mobile">操作系统</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
