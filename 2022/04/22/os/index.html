

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="操作系统  1.概述  1.1 操作系统简介 ​	定义：位于用户层和底层硬件之间的一层，目的是：  1.管理底层的硬件资源，协调硬件的资源，使得不同的部分组合在一起拥有更强大的功能。  文件管理 内存管理 进程管理 设备管理   2.提供给用户&#x2F;程序员接口：  用户：  GUI – 图形界面 命令接口  cmd：联机命令接口 bat文件：脱机命令接口     程序员：系统调用     1.2操作系">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2022/04/22/os/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="操作系统  1.概述  1.1 操作系统简介 ​	定义：位于用户层和底层硬件之间的一层，目的是：  1.管理底层的硬件资源，协调硬件的资源，使得不同的部分组合在一起拥有更强大的功能。  文件管理 内存管理 进程管理 设备管理   2.提供给用户&#x2F;程序员接口：  用户：  GUI – 图形界面 命令接口  cmd：联机命令接口 bat文件：脱机命令接口     程序员：系统调用     1.2操作系">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220212094555081.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220212112201718.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220212113442182.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220212113701444.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220212225124372.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213123547242.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213132126787.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213135040011.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213144610261.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213144600005.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213160142949.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213160229617.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213160431015.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213161125817.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213203126361.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213213321140.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213213205942.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213213144911.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220213213547855.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220214152243194.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220214152418712.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220216135453421.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220216135516015.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220216160443781.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220216135453421.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220216160744082.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220222140146396.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220216224519450.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217131301076.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217131528537.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217134451809.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217134516010.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217134741323.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217135230778.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217135541187.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217145920857.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217151933613.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217163226310.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217171449701.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217164522871.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217200756406.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217201605705.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217201925891.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217210936059.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217211633525.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217212356936.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217213142621.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220217213615777.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220222143554497.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220222160607537.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220222174325114.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220222175044830.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220223144206227.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220223150450389.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220223152742899.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226200716639.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220223164619982.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220223172514669.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220223175452973.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226202656336.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226210834039.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226212649974.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226212846059.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226213041235.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226222820084.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225172840008.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220224174301343.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220224174611948.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220224174843865.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225151532192.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225152803650.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225153554829.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225153649798.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225155011445.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225172615881.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225172659810.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225173214318.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225173344576.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225173411773.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225174007163.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225222725226.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225223003099.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225225158866.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225225410138.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225231543501.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225232059460.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225232233910.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225232520024.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225232500526.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220225232800878.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226143743531.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226144029599.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226144258904.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226182114645.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226182425500.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226184000148.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226190327446.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226191120332.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226191533322.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226193459917.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226195439387.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226200309401.png">
<meta property="og:image" content="http://example.com/2022/04/22/os/image-20220226200523696.png">
<meta property="article:published_time" content="2022-04-22T08:07:42.605Z">
<meta property="article:modified_time" content="2022-04-21T12:45:23.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/04/22/os/image-20220212094555081.png">
  
  
  <title>操作系统 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="操作系统">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-22 16:07" pubdate>
        April 22, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      154 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统</h1>
            
            <div class="markdown-body">
              <p>操作系统</p>
<h1 id="1概述"><a class="markdownIt-Anchor" href="#1概述"></a> 1.概述</h1>
<h2 id="11-操作系统简介"><a class="markdownIt-Anchor" href="#11-操作系统简介"></a> 1.1 操作系统简介</h2>
<p>​	定义：位于用户层和底层硬件之间的一层，目的是：</p>
<ul>
<li>1.管理底层的硬件资源，协调硬件的资源，使得不同的部分组合在一起拥有更强大的功能。
<ul>
<li>文件管理</li>
<li>内存管理</li>
<li>进程管理</li>
<li>设备管理</li>
</ul>
</li>
<li>2.提供给用户/程序员接口：
<ul>
<li>用户：
<ul>
<li>GUI – 图形界面</li>
<li>命令接口
<ul>
<li>cmd：联机命令接口</li>
<li>bat文件：脱机命令接口</li>
</ul>
</li>
</ul>
</li>
<li>程序员：系统调用</li>
</ul>
</li>
</ul>
<h2 id="12操作系统的特征"><a class="markdownIt-Anchor" href="#12操作系统的特征"></a> 1.2操作系统的特征</h2>
<p>​	四个特性：</p>
<ul>
<li>并发</li>
<li>共享</li>
<li>虚拟</li>
<li>异步</li>
</ul>
<p>​	其中并发和共享是基础。</p>
<p>​	区分两个概念：</p>
<ul>
<li>并发：多个程序交替执行，是时分复用的思想</li>
<li>并行：多个程序同时执行</li>
</ul>
<h2 id="13操作系统的分类"><a class="markdownIt-Anchor" href="#13操作系统的分类"></a> 1.3操作系统的分类</h2>
<p>​	大致分一下几个阶段：</p>
<ul>
<li>手工操作机器：写纸袋 – 输入纸袋 – 读取纸袋 – 计算 –  写出纸袋 – 输出纸袋 – 取纸袋。缺点是利用率太低了，各个阶段，无论是cpu还是io</li>
<li>批处理阶段
<ul>
<li>单道批处理系统：类似于bat文件，将程序直接写好，用外围机将纸袋转换成磁带 ，然后用户输入磁带，等待机器计算完后输出磁带。具体的不住：输入磁带 – 计算 – 输出磁带。利用的技术是：脱机输入输出技术。也有缺点，资源利用率低，cpu计算时io是空闲的。</li>
<li>多道批处理系统：利用了流水线技术。缺点：无人机交互功能，一旦提交程序就无法修改或输入参数</li>
</ul>
</li>
<li>分时操作系统：时间片轮转为用户提供作业，用户可通过终端与计算机进行交互。缺点是OS太公平了，没有优先级之分，没人得到的任务时间都是一样的，无法处理紧急任务</li>
<li>实时操作系统:
<ul>
<li>硬实时操作系统：导弹发射 – 严格执行，对ddl的要求很严格</li>
<li>软实时操作系统：订火车票 – 偶尔违反</li>
</ul>
</li>
<li>其它：网络操作系统，分布式操作系统，个人操作系统</li>
</ul>
<h2 id="14操作系统的运行机制"><a class="markdownIt-Anchor" href="#14操作系统的运行机制"></a> 1.4操作系统的运行机制</h2>
<p>​	<img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220212094555081.png" alt="image-20220212094555081"></p>
<h2 id="15中断和异常"><a class="markdownIt-Anchor" href="#15中断和异常"></a> 1.5中断和异常</h2>
<p>​	中断是唯一一种内核夺回cpu控制权的途径</p>
<p>​	中断分类：</p>
<ul>
<li>内中断：中断与当前执行的指令有关，也称为异常
<ul>
<li>产生内中断的方式：执行非法的用户指令或参数非法，执行陷入指令（请求系统调用的时候会进行）</li>
</ul>
</li>
<li>外中断：与当前执行的指令无关
<ul>
<li>产生外中断的方式：时钟中断（并发的实现），io中断（打印机打印完成）</li>
</ul>
</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220212112201718.png" alt="image-20220212112201718"></p>
<p>​	其中，内中断，故障是指可以被系统修复的中断。而终止就属于系统不能修复的中断，于是OS会终止进程</p>
<h2 id="16系统调用与函数"><a class="markdownIt-Anchor" href="#16系统调用与函数"></a> 1.6系统调用与函数</h2>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220212113442182.png" alt="image-20220212113442182"></p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220212113701444.png" alt="image-20220212113701444"></p>
<p>​	系统调用能更好的去管理资源，因为很多资源的请求都是有条件的，共享也是在互斥的条件下才能共享的。</p>
<p>​	库函数是暴露给上层程序员的接口，而系统调用则是某些库函数在进行资源请求时的接口。</p>
<p>​	系统调用的过程：</p>
<ul>
<li>用户态：应用程序向寄存器中传入参数，指明想要那种系统调用</li>
<li>用户态：应用程序执行陷入指令，由用户态切换内核态</li>
<li>内核态：运行系统调用入口程序，检查寄存器中的参数，准备运行相对应的系统调用</li>
<li>内核态：运行响应的系统调用程序</li>
<li>用户态：返回用户态</li>
</ul>
<p>​	陷入指令 = trap指令 = 访管指令</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220212225124372.png" alt="image-20220212225124372"></p>
<h2 id="17操作系统体系结构"><a class="markdownIt-Anchor" href="#17操作系统体系结构"></a> 1.7操作系统体系结构</h2>
<ul>
<li>大内核 / 单内核 / 宏内核</li>
<li>微内核</li>
</ul>
<p>微内核和大内核的一个比较重要的区别：微内核向OS请求服务需要经过6次状态改变，而大内核只需要经过2次状态改变</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213123547242.png" alt="image-20220213123547242"></p>
<p>​	所以微内核的性能比较低，但是内核维护的资源少一点</p>
<h1 id="2进程管理"><a class="markdownIt-Anchor" href="#2进程管理"></a> 2.进程管理</h1>
<script>
    if("qcy20011121"==prompt("请输入文档密码"))
    {
        alert("密码正确");
    }
    else
    {
        alert("密码错误返回主页");
        location="/";
    }
</script>
<h2 id="1进程-程序-进程实体"><a class="markdownIt-Anchor" href="#1进程-程序-进程实体"></a> 1.进程 &amp; 程序 &amp; 进程实体</h2>
<p>​	概念 – 组成 – 特征</p>
<p>​	进程和程序的区别：</p>
<ul>
<li>程序：是我们写死的，一系列的指令的集和，表示为一个可执行文件，是静态的</li>
<li>进程：是程序的一次执行，是动态的</li>
</ul>
<p>​	进程的组成：</p>
<ul>
<li>PCB（程序管理块）：OS管理用的</li>
<li>程序段：进程自己用的，程序代码</li>
<li>数据段：进程自己用的，程序运行产生的数据</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213132126787.png" alt="image-20220213132126787"></p>
<p>​	进程是程序的一次执行，是动态的，而进程实体，是在某一时刻进程的状态，包括PCB，程序段，数据段，这是静态的。</p>
<p>​	于是可以给进程下定义：进程是进程实体的整个运行过程，是系统进行资源分配与调度的基本单位</p>
<p>​	进程还有一些特征，不记录了</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213135040011.png" alt="image-20220213135040011"></p>
<h2 id="2进程的状态与转换"><a class="markdownIt-Anchor" href="#2进程的状态与转换"></a> 2.进程的状态与转换</h2>
<p>​	可以分为以下状态：</p>
<ul>
<li>创建状态：创建PCB，分配资源</li>
<li>就绪状态：资源1，处理机（CPU）0</li>
<li>运行状态：资源1，处理机1</li>
<li>阻塞状态：资源0，处理机0</li>
<li>终止状态：资源回收</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213144610261.png" alt="image-20220213144610261"></p>
<p>​	进程的管理有两种方法，一是队列的形式（指针），二是索引的形式</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213144600005.png" alt="image-20220213144600005"></p>
<h2 id="3进程控制"><a class="markdownIt-Anchor" href="#3进程控制"></a> 3.进程控制</h2>
<p>​	进程控制的工作：创建进程，撤销进程，进程状态转换。</p>
<p>​	用原语实现</p>
<p>​	原语的 原子性如何实现：通过“开 / 关中断指令”。一旦执行了关中断指令，系统就不会去响应中断信号了。类似中断屏蔽机制。</p>
<h3 id="1创建进程的原语"><a class="markdownIt-Anchor" href="#1创建进程的原语"></a> 1.创建进程的原语</h3>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213160142949.png" alt="image-20220213160142949"></p>
<h3 id="2撤销进程的原语"><a class="markdownIt-Anchor" href="#2撤销进程的原语"></a> 2.撤销进程的原语</h3>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213160229617.png" alt="image-20220213160229617"></p>
<h3 id="3阻塞-唤醒进程的原语"><a class="markdownIt-Anchor" href="#3阻塞-唤醒进程的原语"></a> 3.阻塞 / 唤醒进程的原语</h3>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213160431015.png" alt="image-20220213160431015"></p>
<h3 id="4切换进程原语"><a class="markdownIt-Anchor" href="#4切换进程原语"></a> 4.切换进程原语</h3>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213161125817.png" alt="image-20220213161125817"></p>
<h2 id="4进程通信"><a class="markdownIt-Anchor" href="#4进程通信"></a> 4.进程通信</h2>
<p>​	通过：共享存储，消息传递，管道通信实现</p>
<h3 id="1共享存储"><a class="markdownIt-Anchor" href="#1共享存储"></a> 1.共享存储</h3>
<p>​	进程之间的内存地址是只能有自己访问的。要想进程通信，可以再开辟一个单独的空间，归通信的进程所有，细分为两类。</p>
<ul>
<li>共享数据结构：只能存放一种特定的数据结构，通信慢，低级</li>
<li>共享存储区：在内存中单独分配一份空间，数据的类型，存放的位置由应用程序决定，不由OS决定，高速，高级</li>
</ul>
<p>​	无论哪种，进程对共享内存的访问都需要是互斥的</p>
<h3 id="2管道通信"><a class="markdownIt-Anchor" href="#2管道通信"></a> 2.管道通信</h3>
<p>​	以下几点：</p>
<ul>
<li>互斥访问</li>
<li>一个pipe只能半双工，要实现双工需要两个pipe</li>
<li>写满了会阻塞，只有写满了才能读，pipe不空不许写</li>
<li>最多一个进程读</li>
</ul>
<h3 id="3消息传递"><a class="markdownIt-Anchor" href="#3消息传递"></a> 3.消息传递</h3>
<ul>
<li>直接通信：直接将消息体加上消息头打包发出，然后OS给到对应进程的消息队列中去</li>
<li>间接通信（邮箱）：类似于web邮箱</li>
</ul>
<h2 id="5线程"><a class="markdownIt-Anchor" href="#5线程"></a> 5.线程</h2>
<h3 id="1引入多线程"><a class="markdownIt-Anchor" href="#1引入多线程"></a> 1.引入多线程</h3>
<p>​	进程的出现是为了增加系统的并发度。多线程出现后，线程成为了系统调度的基本单位，进程只用于资源分配</p>
<p>​	线程和进程类似，有TCB（thread control block），TID（thread id）</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213203126361.png" alt="image-20220213203126361"></p>
<p>​	多线程引入后，相同进程的线程切换，开销少；不同进程的线程切换，开销依然大。</p>
<h3 id="2线程的实现"><a class="markdownIt-Anchor" href="#2线程的实现"></a> 2.线程的实现</h3>
<ul>
<li>用户级线程（ULT）：用户自己来实现，并不由OS调度，通过app &amp; 线程库来对线程进行调度。
<ul>
<li>优点：开销少，无需状态的切换</li>
<li>缺点：只能并发不能并行。并且单核多核一个样，因为核的调度单位是线程。然后若是碰上阻塞，那就阻塞了。</li>
</ul>
</li>
<li>内核级线程（kernel-level thread）：OS可以看到的线程，由OS调度
<ul>
<li>优点：并发高，就算某线程阻塞了，可以通过内核的调度，去执行其它的线程</li>
<li>缺点：开销高，切换线程需要对应状态的改变。</li>
</ul>
</li>
</ul>
<h3 id="3多线程模型"><a class="markdownIt-Anchor" href="#3多线程模型"></a> 3.多线程模型</h3>
<ul>
<li>一对一：一个用户级对应一个内核级</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213213321140.png" alt="image-20220213213321140"></p>
<ul>
<li>多对一：多个用户级对应一个内核级，通过引入线程库实现。通过牺牲并发性来提高效率，一旦被阻塞就会over</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213213205942.png" alt="image-20220213213205942"></p>
<ul>
<li>多对多（n : m）：n个用户及对应m个内核级，其中n&gt;=m，这样就算某一个用户级线程被阻塞，其他用户线程也不会被阻塞。</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213213144911.png" alt="image-20220213213144911"></p>
<p>​	总览：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220213213547855.png" alt="image-20220213213547855"></p>
<h2 id="6处理机调度"><a class="markdownIt-Anchor" href="#6处理机调度"></a> 6.处理机调度</h2>
<h3 id="1作业"><a class="markdownIt-Anchor" href="#1作业"></a> 1.作业</h3>
<p>​	作业就是任务。</p>
<p>​	当我们向OS提交一个作业，就是让OS启动一个程序。</p>
<p>​	三种调度方式。</p>
<h3 id="2高级调度"><a class="markdownIt-Anchor" href="#2高级调度"></a> 2.高级调度</h3>
<p>​	又称<strong>作业调度</strong>。</p>
<p>​	我们进行一个作业时，需要把程序从外存加载到内存，这个时候，首先将程序添加到外存 的<strong>准备队列（后备队列）<strong>中去进行排队，然后再按照</strong>调度算法</strong>将队列中的程序加载到内存，并且创建进程。</p>
<p>​	作业调入内存时会创建一次PCB，调出内存时撤销PCB。调入调出操作只执行一次</p>
<h3 id="3低级调度"><a class="markdownIt-Anchor" href="#3低级调度"></a> 3.低级调度</h3>
<p>​	又称<strong>进程调度 / 处理机调度</strong></p>
<p>​	前面的高级调度一般是在程序运行前。而低级调度是程序已经启动，操作对象是正在运行的进程 / 进程实体。</p>
<p>​	具体是，根据<strong>调度算法</strong>选取进程就绪队列中的某一个进程，然后将CPU分配给它。</p>
<p>​	进程调度的使用频率很高，几十毫秒一次，是实现并发的关键。</p>
<h3 id="4中级调度"><a class="markdownIt-Anchor" href="#4中级调度"></a> 4.中级调度</h3>
<p>​	又称外<strong>内存调度</strong>。</p>
<p>​	引用场景是当OS发现内存不够了，会将后台暂时没有运行的进程挂到外存中去。被挂起的进程的PCB会形成挂起队列。等到要运行时OS再根据<strong>调度算法</strong>将队列中的PCB还回来，并且分配处理机。</p>
<p>​	中级调度发生的频率也比高级调度高。</p>
<h3 id="5进程的7状态模型-5状态模型对比"><a class="markdownIt-Anchor" href="#5进程的7状态模型-5状态模型对比"></a> 5.进程的7状态模型 &amp;5状态模型对比</h3>
<h4 id="7状态"><a class="markdownIt-Anchor" href="#7状态"></a> 7状态</h4>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220214152243194.png" alt="image-20220214152243194"></p>
<h4 id="5状态"><a class="markdownIt-Anchor" href="#5状态"></a> 5状态</h4>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220214152418712.png" alt="image-20220214152418712"></p>
<h3 id="6调度总结"><a class="markdownIt-Anchor" href="#6调度总结"></a> 6.调度总结</h3>
<ul>
<li>高级调度：作业调度，频率低，外存 --&gt; 内存</li>
<li>低级调度：进程调度，频率高，内存 --&gt; CPU</li>
<li>中级调度：内存调度，频率中，内存 &lt; – &gt; 外存</li>
</ul>
<h2 id="7进程调度详解"><a class="markdownIt-Anchor" href="#7进程调度详解"></a> 7.进程调度详解</h2>
<h3 id="1进程调度的时机"><a class="markdownIt-Anchor" href="#1进程调度的时机"></a> 1.进程调度的时机</h3>
<h4 id="1需要进行进程调度的情况"><a class="markdownIt-Anchor" href="#1需要进行进程调度的情况"></a> 1.需要进行进程调度的情况</h4>
<ul>
<li>主动放弃CPU：
<ul>
<li>进程正常终止</li>
<li>运行产生异常</li>
<li>io阻塞</li>
</ul>
</li>
<li>被动放弃CPU：
<ul>
<li>时钟（时间片用完了）</li>
<li>更紧急的事件需要处理</li>
<li>更高优先级的进程进入就绪队列等待</li>
</ul>
</li>
</ul>
<h4 id="2不能进行进程调度的情况"><a class="markdownIt-Anchor" href="#2不能进行进程调度的情况"></a> 2.不能进行进程调度的情况</h4>
<ul>
<li>处理中断</li>
<li>进程在操作系统内核程序临界区</li>
<li>原语（原子操作）</li>
</ul>
<p>​	临界资源：指一个时间段之内，只允许一个进程访问的资源。也就是需要互斥访问的资源。</p>
<p>​	临界区：访问临界资源的那一段代码。当访问临界资源时，代码会对临界资源进行上锁，确保其它进程不能同时访问临界资源；当进程离开临界区后，会对临界资源解锁。</p>
<p>​	内核临界区：一般是访问内核的某一个数据结构的代码，比如就绪队列。</p>
<p>​	所以，在内核资源临界区时不能进程调度，在普通临界区时是可以进程调度。考虑下面两个例子：</p>
<ul>
<li>进程在对内核中的队列进行操作（就绪队列，阻塞队列，阻塞挂起队列，就绪挂起队列）时，如果此时进行进程调度，夺取cpu，那么新来的进程要想进行工作，肯定也要对队列进行操作，如果是同一个队列，那么上锁了就产生了死锁。</li>
<li>进程等待打印机打印完成时，打印机时临界资源，也需要上锁。但是这时就可以进行进程调度了，因为不调度会空转cpu，调度的话也不会影响内核的工作，所以是ok的</li>
</ul>
<p>​	所以能否进行进程调度，关键问题还是之前的工作是否会对调度后的工作产生影响。（中断的话是在内核进行的，而原语也是内核的部分服务）</p>
<p>​	有的OS只能进程主动放弃CPU，有的OS会强制要求进程放弃CPU</p>
<h3 id="2进程调度的方式"><a class="markdownIt-Anchor" href="#2进程调度的方式"></a> 2.进程调度的方式</h3>
<p>​	分为非剥夺调度方式和剥夺调度方式。</p>
<ul>
<li>非剥夺调度方式：非抢占式，只能进程自己放弃cpu，这种实现简单，开销少，但无法处理紧急任务。适合于批处理系统</li>
<li>剥夺调度方式：抢占式，可以由内核剥夺os，如果有优先级更高的或者时间片用完了。适合于分时，实时操作系统。</li>
</ul>
<h3 id="3进程切换和进程调度"><a class="markdownIt-Anchor" href="#3进程切换和进程调度"></a> 3.进程切换和进程调度</h3>
<p>​	三个概念：</p>
<ul>
<li>进程切换：一个进程让出cpu，另一个进程得到cpu，注意，；俩进程不同</li>
<li>狭义进程调度：从就绪队列中选出一个进程，将cpu给到它。注意，这个进程可以是新的进程，也可以是原来被剥夺cpu的进程</li>
<li>广义进程调度：剥夺进程a的cpu，从就绪队列中选择一个进程b，将cpu赋予b</li>
</ul>
<p>​	进程切换的工作：</p>
<ul>
<li>保存剥夺cpu进程的pcb</li>
<li>恢复赋予cpu进程的pcb</li>
</ul>
<p>​	pcb中包含程序状态字，计数器，还有各种寄存器的信息。</p>
<p>​	从上看来，进程调度还是很有代价的。如果过于频繁的切换进程的话，系统的效率会下降。</p>
<h2 id="8调度算法的性能指标"><a class="markdownIt-Anchor" href="#8调度算法的性能指标"></a> 8.调度算法的性能指标</h2>
<h3 id="1cpu利用率"><a class="markdownIt-Anchor" href="#1cpu利用率"></a> 1.cpu利用率</h3>
<p>​	计算：忙碌时间➗总运行时间</p>
<p>​	io设备的利用率也是这样算的。</p>
<h3 id="2系统吞吐量"><a class="markdownIt-Anchor" href="#2系统吞吐量"></a> 2.系统吞吐量</h3>
<p>​	定义：单位时间完成作业的数量。</p>
<p>​	计算：总共完成多少道作业➗总花费时间</p>
<h3 id="3周转时间"><a class="markdownIt-Anchor" href="#3周转时间"></a> 3.周转时间</h3>
<p>​	定义：作业被提交到系统开始，到完成作业为止的时间。</p>
<p>​	计算：作业完成时间 - 作业提交时间</p>
<p>​	平均值计算：作业周转时间之和 ➗ 作业数</p>
<p>​	注意，周转时间包含了等待的时间在里面。</p>
<p>​	我们引出了带权周转时间：</p>
<p>​	计算：作业周转时间 ➗ 作业实际运行时间，注意，这个值大于等于1，越接近1对用户而言体验越好。</p>
<p>​	也有平均带权周转时间，计算类似前面。</p>
<h3 id="4等待时间"><a class="markdownIt-Anchor" href="#4等待时间"></a> 4.等待时间</h3>
<p>​	定义：作业等待处理机所消耗的时间。注意！这里严格的来讲不能将处理机视作cpu，因为处理机既可以是cpu核心，也可以是io设备，如打印机等。</p>
<p>​	这对进程和作业而言是两种计算：</p>
<ul>
<li>进程：指的是进程被建立后，从进入就绪队列开始，到进程结束，等待处理机服务的总时间。包括在就绪队列的时间，但不包括等待io的时间。如进程等待打印机打印，进程实际是被打印机服务的，所以不算等待时间。</li>
<li>作业：除了进程的等待时间，还要算上作业在从外存加入内存前，在后备队列上等待高级调度（作业调度）的时间。</li>
</ul>
<h3 id="5响应时间"><a class="markdownIt-Anchor" href="#5响应时间"></a> 5.响应时间</h3>
<p>​	定义：用户从首次提交请求到首次得到响应的时间，算作一次响应时间。</p>
<h2 id="9调度算法上"><a class="markdownIt-Anchor" href="#9调度算法上"></a> 9.调度算法（上）</h2>
<p>​	调度算法学习思路：</p>
<ul>
<li>算法思想</li>
<li>算法规划</li>
<li>用于作业调度还是进程调度</li>
<li>抢占式还是非抢占式</li>
<li>优缺点</li>
<li>是否导致饥饿（进程 / 作业长时间得不到处理机）</li>
</ul>
<h3 id="1先来先服务fcfs"><a class="markdownIt-Anchor" href="#1先来先服务fcfs"></a> 1.先来先服务（FCFS）</h3>
<h4 id="例子求性能指标"><a class="markdownIt-Anchor" href="#例子求性能指标"></a> 例子：求性能指标：</h4>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220216135453421.png" alt="image-20220216135453421"></p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220216135516015.png" alt="image-20220216135516015"></p>
<ul>
<li>算法思想：公平的角度，排队服务</li>
<li>算法规划：按照作业 / 进程到达后备队列 / 就绪队列的顺序依次服务</li>
<li>用于作业调度还是进程调度：都可以，针对不同的队列即可</li>
<li>抢占式还是非抢占式：一般用于非抢占式</li>
<li>优缺点：对长作业友好，短作业不友好</li>
<li>是否导致饥饿：不会，只要进程一直等待，总会轮到它的</li>
</ul>
<h3 id="2短作业优先sjf"><a class="markdownIt-Anchor" href="#2短作业优先sjf"></a> 2.短作业优先（SJF）</h3>
<ul>
<li>算法思想：追求最少的平均等待，周转，带全周转时间</li>
<li>算法规划：最短的作业/进程优先得到处理机</li>
<li>用于作业调度还是进程调度：都可以，用于进程调度时称为SPF</li>
<li>抢占式还是非抢占式：一般是非抢占式，也有抢占式：最短剩余时间优先算法（SRTN）</li>
<li>优缺点：优点时是最短的平均时间，缺点是不公平，对短作业友好</li>
<li>是否导致饥饿：会，如果源源不断的来短作业进来，那么长作业一直得不到处理机，可能会饥饿甚至饿死</li>
</ul>
<h3 id="3高响应比优先hrrn"><a class="markdownIt-Anchor" href="#3高响应比优先hrrn"></a> 3.高响应比优先（HRRN）</h3>
<ul>
<li>算法思想：综合考虑进程的等待时间与要求服务时间</li>
<li>算法规划：引入响应比 = （等待时间 + 要求服务时间）➗要求服务时间 = 1 + 等待时间➗要求服务时间 &gt;= 1。响应比越高，等待时间越长，优先级越高</li>
<li>用于作业调度还是进程调度: 都可以</li>
<li>抢占式还是非抢占式：非抢占式</li>
<li>优缺点：短作业优先，等待时间长的优先</li>
<li>是否导致饥饿：不会</li>
</ul>
<h3 id="4总结"><a class="markdownIt-Anchor" href="#4总结"></a> 4.总结</h3>
<p>​	三种算法是逐渐完善的过程：FCFS只是考虑了等待时间，SJF只是考虑了运行时间，然后最后HRRN结合了两者，用公式计算出高响应比，权衡等待时间与运行时间来排队。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220216160443781.png" alt="image-20220216160443781"></p>
<p>​	上面击中算法适合批处理系统，侧重的是提升几个时间</p>
<p>​	然后可能考计算题，结合性能指标计算或者是考选择概念题。</p>
<p>​	就是下面这个图，计算它的周转时间，带权周转时间，等待时间，以及平均值</p>
<p>​	<img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220216135453421.png" alt="image-20220216135453421"></p>
<p>公式如下：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220216160744082.png" alt="image-20220216160744082"></p>
<h2 id="10调度算法下"><a class="markdownIt-Anchor" href="#10调度算法下"></a> 10.调度算法（下）</h2>
<h3 id="1时间片轮转调度算法rr"><a class="markdownIt-Anchor" href="#1时间片轮转调度算法rr"></a> 1.时间片轮转调度算法（RR）</h3>
<ul>
<li>算法思想：公平的轮流为每个进程服务，每个进程在一定时间内都能得到响应</li>
<li>算法规划：按照进程在就绪队列中的次序，选出一个进程，服务100ms，然后归还到就绪队列的队尾</li>
<li>用于作业调度还是进程调度：进程调度</li>
<li>抢占式还是非抢占式：抢占式</li>
<li>优缺点：公平，适合于分时操作系统。缺点与时间片的选择有关，然后不会区分任务的紧急程度。
<ul>
<li>时间片大：退化成先来先服务调度算法</li>
<li>时间片小：频繁的切换进程，降低性能了</li>
</ul>
</li>
<li>是否导致饥饿：否</li>
</ul>
<h3 id="2优先级调度算法"><a class="markdownIt-Anchor" href="#2优先级调度算法"></a> 2.优先级调度算法</h3>
<ul>
<li>算法思想：根据任务的优先级来决定处理顺序</li>
<li>算法规划：为进程/作业设置优先级，调度时选择优先级最高的那一个</li>
<li>用于作业调度还是进程调度：都可以</li>
<li>抢占式还是非抢占式：都有</li>
<li>优缺点：优点是可以根据优先级来进行工作，适合实时操作系统；缺点是可能会饥饿</li>
<li>是否导致饥饿：会</li>
</ul>
<p>​	补充：</p>
<ul>
<li>优先级会变吗？静态优先级和动态优先级之分。</li>
<li>优先级如何划分？
<ul>
<li>系统进程 &gt; 用户进程</li>
<li>前台进程 &gt; 后台进程</li>
<li>io进程（io繁忙型进程） &gt; 计算型进程（cpu繁忙型进程）</li>
</ul>
</li>
<li>动态优先级什么时候应该调整？
<ul>
<li>进程在队列中呆了很久了，响应比变大</li>
<li>进程占用处理机很久了</li>
<li>进程频繁进行io操作</li>
</ul>
</li>
</ul>
<h3 id="3多级反馈队列调度算法"><a class="markdownIt-Anchor" href="#3多级反馈队列调度算法"></a> 3.多级反馈队列调度算法</h3>
<ul>
<li>算法思想：对其它算法的权衡</li>
<li>算法规划：有多个队列，优先级从高到低，时间片从低到高。进程经过作业调度后，先进入一级队列（高优先级，低时间片），然后时间片轮转，剥夺处理机，进入二级队列队尾；若有优先级更高的进程进来，终止当前进程，剥夺处理机，然后给到优先级高的进程。若进程到了最后一级队列，没有下一级队列，运行完了就继续加在当前队列的队尾。</li>
<li>用于作业调度还是进程调度：进程调度</li>
<li>抢占式还是非抢占式：抢占式</li>
<li>优缺点：结合了各种调度算法的优点
<ul>
<li>对各类进程公平（FCFS 先来先服务）</li>
<li>进程到达很快就能得到响应（RR 时间片轮转）</li>
<li>段进程只用很少的时间就能完成（SPF 短进程优先）</li>
<li>还可以调整偏好，对计算型进程或io进程都有策略（若进程io阻塞，io恢复后会回到原优先级队列，而不是下一级）</li>
</ul>
</li>
<li>是否导致饥饿：会</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220222140146396.png" alt="image-20220222140146396"></p>
<h3 id="4总结-2"><a class="markdownIt-Anchor" href="#4总结-2"></a> 4.总结</h3>
<p>​	时间片轮转只是考虑了公平，而没有考虑优先级；优先级调度只是考虑了优先级；而多级反馈队列是综合了两者。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220216224519450.png" alt="image-20220216224519450"></p>
<p>​	这几种调度算法适合于交互式系统，如unix使用的就是多级反馈队列调度算法</p>
<p>​	这几种算法设计的最终目的是：提高公平性，响应时间，平衡性</p>
<h2 id="11进程同步互斥"><a class="markdownIt-Anchor" href="#11进程同步互斥"></a> 11.进程同步，互斥</h2>
<h3 id="1进程同步"><a class="markdownIt-Anchor" href="#1进程同步"></a> 1.进程同步</h3>
<p>​	进程是具有异步性的，也就是会以不同的，不可预知的速度执行下去。</p>
<p>​	但某些时候我们想要进程能够按照我们的规划去执行。这个时候就需要进程同步机制，来协调进程执行的顺序。</p>
<h3 id="2进程互斥"><a class="markdownIt-Anchor" href="#2进程互斥"></a> 2.进程互斥</h3>
<p>​	进程互斥指的是进程在访问共享资源（互斥共享方式，同时共享方式）时是互斥访问的。</p>
<p>​	复习：把同一时间只能由一个进程访问的资源称为临界资源，访问临界资源的代码称为临界区</p>
<p>​	对临界资源的访问可以分为以下几个部分：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217131301076.png" alt="image-20220217131301076"></p>
<p>​	实现临界资源访问（进程互斥）的原则</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217131528537.png" alt="image-20220217131528537"></p>
<h2 id="12进程互斥的软件实现方法"><a class="markdownIt-Anchor" href="#12进程互斥的软件实现方法"></a> 12.进程互斥的软件实现方法</h2>
<h3 id="1单标志法"><a class="markdownIt-Anchor" href="#1单标志法"></a> 1.单标志法</h3>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217134451809.png" alt="image-20220217134451809"></p>
<p>​	用一个turn变量表示当前允许进入的进程编号。在进入区时需要用一个while循环来判断。在退出区将turn的值设置为下一个进程的进程编号</p>
<p>​	问题：当进程a让出临界资源给另一个进程b时，若b一直不访问临界资源，那么就没人能继续访问临界资源了。<strong>违反了空闲让进原则</strong></p>
<h3 id="2双标志先检查"><a class="markdownIt-Anchor" href="#2双标志先检查"></a> 2.双标志先检查</h3>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217134516010.png" alt="image-20220217134516010"></p>
<p>​	可能碰上并发的bug，两个进程同时对临界资源访问。<strong>违反了忙则等待原则</strong></p>
<p>​	并发bug执行顺序：1526</p>
<h3 id="3双标志后检查"><a class="markdownIt-Anchor" href="#3双标志后检查"></a> 3.双标志后检查</h3>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217134741323.png" alt="image-20220217134741323"></p>
<p>​	先上锁后检查。</p>
<p>​	可能出现都上锁了然后都不能进去。对进程，进程一直等待；对空闲资源，空闲资源一直空闲。<strong>违背了空闲让进和有限等待原则</strong></p>
<p>​	并发情况：1526</p>
<h3 id="4peterson算法"><a class="markdownIt-Anchor" href="#4peterson算法"></a> 4.Peterson算法</h3>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217135230778.png" alt="image-20220217135230778"></p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217135541187.png" alt="image-20220217135541187"></p>
<p>​		如果是16278顺序并发执行的话，那么两个进程都想进去，但是第二个进程最后也谦让了，把turn设置为了第一个进程的次序，所以可以并发执行的。</p>
<p>​	最后谁设置的turn值，谁就丧失了优先权。</p>
<p>​	peterson算法<strong>实现了空闲让进，忙则等待，有限等待</strong>的原则，但<strong>没有实现让权等待</strong>原则</p>
<p>​	问题：让权等待，一直占用处理机。如果没有进程设置turn，会一直while循环</p>
<h2 id="13进程互斥的硬件实现方法"><a class="markdownIt-Anchor" href="#13进程互斥的硬件实现方法"></a> 13.进程互斥的硬件实现方法</h2>
<h3 id="1中断屏蔽方法"><a class="markdownIt-Anchor" href="#1中断屏蔽方法"></a> 1.中断屏蔽方法</h3>
<p>​	执行开关中断指令。（原语的实现思想）</p>
<p>​	问题：</p>
<ul>
<li>开关中断只适合于内核进程，不适用用户进程，因为是特权指令</li>
<li>不适用多核处理器，因为开关指令只针对于当前处理机，并发情况下会出问题。</li>
</ul>
<h3 id="2testandsetts指令tsl指令"><a class="markdownIt-Anchor" href="#2testandsetts指令tsl指令"></a> 2.TestAndSet（TS指令，TSL指令）</h3>
<p>​	代码实现逻辑：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217145920857.png" alt="image-20220217145920857"></p>
<p>​	事实上这个逻辑是由纯硬件实现的，并且不允许中断。</p>
<p>​	算法实现是：和单标志法一样的，检查所锁加锁</p>
<p>​	优缺点</p>
<ul>
<li>优点：实现了原子操作，同时适用于多处理机</li>
<li>缺点：不满足让权等待</li>
</ul>
<h3 id="3swap指令xchg指令"><a class="markdownIt-Anchor" href="#3swap指令xchg指令"></a> 3.Swap指令（XCHG指令）</h3>
<p>​	逻辑实现：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217151933613.png" alt="image-20220217151933613"></p>
<p>​	实现和优缺点和TestAndSet是一样的。</p>
<h2 id="14信号量机制"><a class="markdownIt-Anchor" href="#14信号量机制"></a> 14.信号量机制</h2>
<p>​	信号量想要解决的问题：</p>
<ul>
<li>让权等待</li>
<li>检查上锁一气呵成</li>
</ul>
<h3 id="1整型信号量"><a class="markdownIt-Anchor" href="#1整型信号量"></a> 1.整型信号量</h3>
<p>​	用一个变量表示临界资源的数量，然后使用的时候先检查在上锁（和双标志先检查一摸一样）。唯一的区别就是实现的过程使用的是原语，也就是说不会被打断。</p>
<p>​	下面是c实现：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217163226310.png" alt="image-20220217163226310"></p>
<p>​	存在的问题就是：<strong>没遵守让权等待原则</strong>。存在忙等</p>
<p>​	ps：上述代码存在问题，并且因为是原子操作，所以等待的过程中会一直霸占处理机。这段代码只是助于我们理解pv操作，现实中不会这么写并且这样写也是错误的。</p>
<h3 id="2记录型信号量"><a class="markdownIt-Anchor" href="#2记录型信号量"></a> 2.记录型信号量 ※</h3>
<p>​	为了解决忙等（等待死循环）而产生得。</p>
<p>​	代码：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217171449701.png" alt="image-20220217171449701"></p>
<ul>
<li>wait函数（p操作）：先对val进行减减，然后在判断是否由可用资源，没有的话就将进程天机到阻塞队列中去。</li>
<li>signal函数（v操作）：先对val进行加加，若加一后可用资源为负数，说明阻塞队列中有进程需要资源，然后从队列中将资源唤醒</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217164522871.png" alt="image-20220217164522871"></p>
<p>​	p操作中的自我阻塞，就实现了让权等待，而不是忙等。</p>
<h2 id="15用信号量实现进程的互斥同步前驱关系"><a class="markdownIt-Anchor" href="#15用信号量实现进程的互斥同步前驱关系"></a> 15.用信号量实现进程的互斥，同步，前驱关系</h2>
<h3 id="1实现进程互斥"><a class="markdownIt-Anchor" href="#1实现进程互斥"></a> 1.实现进程互斥</h3>
<ul>
<li>设置互斥信号量mutex = 1</li>
<li>进入临界区前执行P(mutex)</li>
<li>出临界区前执行V(mutex)</li>
</ul>
<p>下面是进程的实现：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217200756406.png" alt="image-20220217200756406"></p>
<h3 id="2实现进程同步"><a class="markdownIt-Anchor" href="#2实现进程同步"></a> 2.实现进程同步</h3>
<p>​	先V后P原则（先生产，后消费，我们人的逻辑如此。）</p>
<p>​	先实现信号量数据结构，给val设置初值0，然后设置两个进程，各自持有pv操作。先执行的进程执行在离开临界资源时执行v操作，后访问临界资源的访问时需要执行p操作</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217201605705.png" alt="image-20220217201605705"></p>
<h3 id="3前驱关系的实现"><a class="markdownIt-Anchor" href="#3前驱关系的实现"></a> 3.前驱关系的实现</h3>
<p>​	进程同步套个娃</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217201925891.png" alt="image-20220217201925891"></p>
<h2 id="16生产者消费者问题"><a class="markdownIt-Anchor" href="#16生产者消费者问题"></a> 16.生产者消费者问题</h2>
<p>​	问题描述：系统中有一组生产者进程和一组消费者进程,生产者进程每次生产一个产品放入缓冲区,消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)生产者、消费者共享一个初始为空、大小为n的缓冲区。只有缓冲区没满时,生产者才能把产品放入缓冲区,否则必须等待。</p>
<p>​	分析有几组pv操作：</p>
<ul>
<li>缓冲区没满，生产者可以生产，否则阻塞，同步关系</li>
<li>缓冲区没空，消费者可以消费，否则阻塞， 同步关系</li>
<li>对缓冲区进行读写时需要上锁，互斥关系（无论是多个消费者，多个生产者，或者是消费者生产者同时存在，都不行，同一时间只能有一个进程访问共享资源）</li>
</ul>
<p>​	一般而言，互斥信号量设置1，同步信号量看初始值。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217210936059.png" alt="image-20220217210936059"></p>
<p>​	p操作不能随便换，可能会产值死锁的。如下：</p>
<p>​	当缓冲区满时，也就是empty = 0 &amp; full = n</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217211633525.png" alt="image-20220217211633525"></p>
<p>​	结论：实现互斥的操作要在实现同步的操作后面，特指P操作。而V操作的话，因为不会导致进程阻塞，所以不会导致死锁。</p>
<p>​	还有一个注意的是：临界区的代码尽量要短</p>
<h2 id="17多生产者多消费者问题"><a class="markdownIt-Anchor" href="#17多生产者多消费者问题"></a> 17.多生产者多消费者问题</h2>
<p>​	问题描述：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217212356936.png" alt="image-20220217212356936"></p>
<p>​	代码实现：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217213142621.png" alt="image-20220217213142621"></p>
<p>​	注意：</p>
<ul>
<li>先处理同步信号量，再处理互斥信号量</li>
<li>缓冲区＞1时需要互斥信号量，不能省略，不然的话会出现缓冲区同一块数据被多次写入（覆盖）</li>
</ul>
<p>​	下面是一个错误例子：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220217213615777.png" alt="image-20220217213615777"></p>
<p>​	左边是错误的，原因是将进程作为处理对象考虑了。</p>
<p>​	应当将事件作为触发对象，在此例子中就是：盘子增加了一个水果，盘子减少了一个水果。</p>
<h2 id="18单生产者多消费者问题吸烟者问题"><a class="markdownIt-Anchor" href="#18单生产者多消费者问题吸烟者问题"></a> 18.单生产者多消费者问题（吸烟者问题）</h2>
<p>​	假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中,第一个拥有烟草第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者进程一个信号告诉完成了,供应者就会放另外两种材料再桌上,这个过程一直重复(让三个抽烟者轮流地抽烟)</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220222143554497.png" alt="image-20220222143554497"></p>
<ol>
<li>找出互斥关系（缓冲区大小）</li>
<li>找出同步关系（先后事件）</li>
<li>用while循环＋变量自增实现轮流消费</li>
</ol>
<p>变量定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c">semaphore offer1 = <span class="hljs-number">0</span>;<span class="hljs-comment">// 同步信号量1</span><br>semaphore offer2 = <span class="hljs-number">0</span>;<span class="hljs-comment">// 同步信号量2</span><br>semaphore offer3 = <span class="hljs-number">0</span>;<span class="hljs-comment">// 同步信号量3</span><br>semaphore mutex = <span class="hljs-number">1</span>;<span class="hljs-comment">// 缓冲区大小，是个互斥量</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">// 实现轮流消费</span><br></code></pre></td></tr></table></figure>
<p>生产者描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">provider</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">// 检查抽烟是否完成，完成了就可以进行生产</span><br>			P(finish);<br>			<span class="hljs-comment">// 为消费者1提供服务</span><br>			V(offer1);<br>			P(mutex);<br>			<span class="hljs-comment">// 生产组合1...</span><br>			V(mutex);<br>		&#125;<br>		<span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) &#123;<br>			P(finish);<br>			V(offer2);<br>			P(mutex);<br>			V(mutex);<br>		&#125;<br>		<span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>) &#123;<br>			P(finish);<br>			V(offer3);<br>			P(mutex);<br>			V(mutex);<br>		&#125;<br>		i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>消费者描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">custerom1</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-comment">// 准备使用组合1</span><br>		P(offer1);<br>		<span class="hljs-comment">// 访问缓冲区</span><br>		P(mutex);<br>		<span class="hljs-comment">// 缓冲区解锁</span><br>		V(mutex);<br>		<span class="hljs-comment">// 传递完成时的信号量</span><br>		V(finish);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="19复杂互斥问题读者写者问题"><a class="markdownIt-Anchor" href="#19复杂互斥问题读者写者问题"></a> 19.复杂互斥问题（读者写者问题）</h2>
<p>​	有读者和写者两组并发进程,共享一个文件,当两个或两个以上的读进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求:①允许多个读者可以同时对文件执行读操作;②只允许一个写者往文件中写信息;③任一写者在完成写操作之前不允许其他读者或写者工作;④写者执行写操作前,应让已有的读者和写者全部退出。</p>
<p>​	互斥关系：</p>
<ol>
<li>读者 - 写者互斥</li>
<li>写者 - 写者互斥</li>
</ol>
<p>​	同步关系：</p>
<p>​	没有明确的同步关系。</p>
<h3 id="1最简单的读写关系"><a class="markdownIt-Anchor" href="#1最简单的读写关系"></a> 1.最简单的读写关系</h3>
<p>设置变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex_rw = <span class="hljs-number">1</span>;<span class="hljs-comment">// 读者写者互斥的信号量</span><br></code></pre></td></tr></table></figure>
<p>写者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>    P(mutex_rw);<br>    <span class="hljs-comment">// 执行写操作</span><br>    V(mutex_rw);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>读者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>    P(mutex_rw);<br>    <span class="hljs-comment">// 执行读操作</span><br>    V(mutex_rw);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>问题：读者读者也互斥了</p>
<h3 id="2解决读者互斥"><a class="markdownIt-Anchor" href="#2解决读者互斥"></a> 2.解决读者互斥</h3>
<p>设置变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex_rw = <span class="hljs-number">1</span>;<span class="hljs-comment">// 读者写者互斥的信号量</span><br><span class="hljs-type">int</span> count_r = <span class="hljs-number">0</span>;<span class="hljs-comment">// 读者计数器</span><br></code></pre></td></tr></table></figure>
<p>写者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>    P(mutex_rw);<br>    <span class="hljs-comment">// 执行写操作</span><br>    V(mutex_rw);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>读者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(count_r == <span class="hljs-number">0</span>)<br>    	P(mutex_rw);<br>    count++;<br>    <span class="hljs-comment">// 执行读操作</span><br>    <span class="hljs-keyword">if</span>(count_r == <span class="hljs-number">0</span>)<br>    	V(mutex_rw);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>问题：用if来对count进行判断会有并发问题（参考单标志法）。</p>
<h3 id="3解决并发问题"><a class="markdownIt-Anchor" href="#3解决并发问题"></a> 3.解决并发问题</h3>
<p>设置变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex_rw = <span class="hljs-number">1</span>;<span class="hljs-comment">// 读者写者互斥的信号量</span><br><span class="hljs-type">int</span> count_r = <span class="hljs-number">0</span>;<span class="hljs-comment">// 读者计数器</span><br>semaphore mutex_count = <span class="hljs-number">1</span>;<span class="hljs-comment">// 设置对count的互斥访问</span><br></code></pre></td></tr></table></figure>
<p>写者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>    P(mutex_rw);<br>    <span class="hljs-comment">// 执行写操作</span><br>    V(mutex_rw);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>读者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>    P(count_r);<br>    <span class="hljs-keyword">if</span>(count_r == <span class="hljs-number">0</span>)<br>    	P(mutex_rw);<br>    count++;<br>    V(count_r);<br>    <span class="hljs-comment">// 执行读操作</span><br>    <span class="hljs-keyword">if</span>(count_r == <span class="hljs-number">0</span>)<br>    	V(mutex_rw);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4总结-3"><a class="markdownIt-Anchor" href="#4总结-3"></a> 4.总结</h3>
<ol>
<li>复杂的互斥问题时向读者写者问题靠拢</li>
<li>设置计数器count</li>
<li>对计数器的访问增加互斥变量来实现互斥操作</li>
</ol>
<h2 id="20多个临界资源死锁问题哲学家进餐"><a class="markdownIt-Anchor" href="#20多个临界资源死锁问题哲学家进餐"></a> 20.多个临界资源，死锁问题（哲学家进餐）</h2>
<p>​	一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220222160607537.png" alt="image-20220222160607537"></p>
<p>​	互斥关系：</p>
<ol>
<li>每个哲学家拿起左右两根筷子时，其它哲学家不能使用这两根筷子。</li>
</ol>
<h3 id="1无脑错解"><a class="markdownIt-Anchor" href="#1无脑错解"></a> 1.无脑错解</h3>
<p>变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chop[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">// 5个互斥量，分别表示5根筷子</span><br></code></pre></td></tr></table></figure>
<p>哲学家：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">thinkingPeople</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)&#123;<br>        P(i);<br>        P((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 吃饭</span><br>        V(i);<br>        V((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 思考</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>问题：并发，当5个哲学家同时拿起一根筷子时，产生死锁。</p>
<p>解决方案：</p>
<ol>
<li>最多只有4个哲学家就餐 – 设置缓冲区信号量，容量为4</li>
<li>奇数哲学家先拿左边后拿右边，偶数哲学家相反</li>
</ol>
<h3 id="2限制-最多4哲学家同时就餐"><a class="markdownIt-Anchor" href="#2限制-最多4哲学家同时就餐"></a> 2.限制 - 最多4哲学家同时就餐</h3>
<p>变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chop[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">// 5个互斥量，分别表示5根筷子</span><br>semaphore cap = <span class="hljs-number">4</span>;<span class="hljs-comment">// 最多同时就餐的哲学家人数</span><br></code></pre></td></tr></table></figure>
<p>哲学家：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">thinkingPeople</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)&#123;<br>        P(cap);<br>        P(i);<br>        P((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 吃饭</span><br>        V(i);<br>        V((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>        V(cap);<br>        <span class="hljs-comment">// 思考</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3限制-分奇偶哲学家"><a class="markdownIt-Anchor" href="#3限制-分奇偶哲学家"></a> 3.限制 - 分奇偶哲学家</h3>
<p>变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chop[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">// 5个互斥量，分别表示5根筷子</span><br></code></pre></td></tr></table></figure>
<p>哲学家：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">thinkingPeople</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            P(i);<br>        	P((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            P((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>            P(i);<br>        &#125;<br>        <span class="hljs-comment">// 吃饭</span><br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            V(i);<br>        	V((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            V((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>            V(i);<br>        &#125;<br>        <span class="hljs-comment">// 思考</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4限制-同时最多只有一人拿起筷子"><a class="markdownIt-Anchor" href="#4限制-同时最多只有一人拿起筷子"></a> 4.限制-同时最多只有一人拿起筷子</h3>
<p>变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chop[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">// 5个互斥量，分别表示5根筷子</span><br>semaphore mutex = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>哲学家：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">thinkingPeople</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span> == <span class="hljs-number">1</span>)&#123;<br>        P(mutex);<br>        P(i);<br>        P((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 吃饭</span><br>        V(i);<br>        V((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>        V(mutex);<br>        <span class="hljs-comment">// 思考</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="21管程"><a class="markdownIt-Anchor" href="#21管程"></a> 21.管程</h2>
<p>​	管程是一种特殊的软件模块。包含了：共享数据（一些数据结构，如缓冲区），定义在管程中的操作（方法，操作共享数据的入口）</p>
<p>​	管程的互斥同步由编译器实现。我们直接调用即可。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220222174325114.png" alt="image-20220222174325114"></p>
<p>​	java中的管程</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220222175044830.png" alt="image-20220222175044830"></p>
<h2 id="22死锁"><a class="markdownIt-Anchor" href="#22死锁"></a> 22.死锁</h2>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220223144206227.png" alt="image-20220223144206227"></p>
<h3 id="1死锁的必要条件"><a class="markdownIt-Anchor" href="#1死锁的必要条件"></a> 1.死锁的必要条件</h3>
<ul>
<li><strong>互斥条件</strong>：对资源的持有是互斥的。</li>
<li><strong>不可剥夺条件</strong>：进程持有的临界资源不可被剥夺</li>
<li><strong>请求和保持条件</strong>：陷入死锁的进程会持有谋一份临界资源，同时请求另一份临界资源</li>
<li><strong>循环等待条件</strong>：存在一条循环等待链 – 进程持有一份资源并且这份资源是被另一个进程所请求的</li>
</ul>
<p>​	这是必要条件而不是充分条件。</p>
<p>​	如果请求链中的谋一份资源不只一份，也就是说不是死锁了，有解。</p>
<h3 id="2死锁的发生"><a class="markdownIt-Anchor" href="#2死锁的发生"></a> 2.死锁的发生</h3>
<p>​	对不可剥夺的资源的不合理分配可能会导致死锁。具体如下：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220223150450389.png" alt="image-20220223150450389"></p>
<h3 id="3死锁的处理策略"><a class="markdownIt-Anchor" href="#3死锁的处理策略"></a> 3.死锁的处理策略</h3>
<ul>
<li>预防：破坏死锁的必要条件中的一个或者几个</li>
<li>避免：用某种方法防止系统进入不安全的状态</li>
<li>死锁的检查和解除：允许死锁，但OS会对死锁进行检测，检测到后会采取某种策略解除死锁</li>
</ul>
<h2 id="23预防死锁"><a class="markdownIt-Anchor" href="#23预防死锁"></a> 23.预防死锁</h2>
<ul>
<li>破环互斥条件：比如采用SPOOLing技术</li>
<li>破坏不剥夺条件：进程主动释放 or 根据优先级由OS进行强行剥夺</li>
<li>破坏请求和保持条件：采用静态分配（在进程投入运行前先申请完全部资源，若是不能全部申请，就不投入运行进程）</li>
<li>破坏循环等待条件：顺序资源分配法</li>
</ul>
<h2 id="24避免死锁"><a class="markdownIt-Anchor" href="#24避免死锁"></a> 24.避免死锁</h2>
<p>​	找出<strong>安全序列</strong>。按照安全序列执行顺序，系统就一定处于<strong>安全状态</strong>。</p>
<p>​	处于安全状态，系统一定不会发生死锁；处于不安全状态，系统可能发生死锁。</p>
<p>​	银行家算法：</p>
<p>​	核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>
<p>​	将银行家算法推广到多维（很多个共享资源）的情况下，我们可以得出安全性算法。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220223152742899.png" alt="image-20220223152742899"></p>
<h2 id="25死锁的检测和解除"><a class="markdownIt-Anchor" href="#25死锁的检测和解除"></a> 25.死锁的检测和解除</h2>
<p>​	使用图数据结构。</p>
<p>​	若是能够消除所有有向边，也就是这个图可完全简化，那么就是一定不会发生死锁。</p>
<p>​	死锁定理：如果某时刻系统的资源分配图是不可化简的，那么就会产生死锁。</p>
<p>​	解除死锁的方法：</p>
<ul>
<li>资源剥夺法：将进程挂起到外存中去，并剥夺资源</li>
<li>撤销进程法：直接杀死进程</li>
<li>进程回退法：设置还原点，直接回退</li>
</ul>
<p>​	如何选择要解除对哪个进程‘动手’？</p>
<ul>
<li>进程优先级</li>
<li>进程运行时间</li>
<li>进程占有的资源</li>
<li>交互式 or 批处理式进程</li>
</ul>
<h1 id="3内存管理"><a class="markdownIt-Anchor" href="#3内存管理"></a> 3.内存管理</h1>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226200716639.png" alt="image-20220226200716639"></p>
<h2 id="1基础知识"><a class="markdownIt-Anchor" href="#1基础知识"></a> 1.基础知识</h2>
<h3 id="1内存的划分"><a class="markdownIt-Anchor" href="#1内存的划分"></a> 1.内存的划分</h3>
<p>​	内存中可存放数据，程序运行前需要先从外存加载到内存中。</p>
<p>​	内存中会进行划分。即有<strong>地址</strong>和<strong>存储单元</strong>。</p>
<p>​	每个地址对应一个存储单元，存储单元可以是按字节编址（一个存储单元1B），也可可以按字编址（一个存储单元1word）</p>
<h3 id="2指令-逻辑地址-物理地址"><a class="markdownIt-Anchor" href="#2指令-逻辑地址-物理地址"></a> 2.指令 &amp; 逻辑地址 &amp; 物理地址</h3>
<p>​	进程 = 程序段 + 数据段 + PCB</p>
<p>​	程序段和数据段都是存放在内存中的某一块空间的。其中程序段就是语言编译后转换成的机器指令，而数据段就是程序在运行时产生的变量存放的地方。都是在内存中。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220223164619982.png" alt="image-20220223164619982"></p>
<p>​	执行x = x + 1</p>
<ul>
<li>找到x在数据段中的地址，然后取到一个寄存器中去</li>
<li>对寄存器中的值执行加一操作</li>
<li>将寄存器中的值写回数据段中x对应的存放位置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 4GB = 4 * 2^30 = 2^32 =&gt; 地址是32位的</span><br><span class="hljs-comment">// 8GB = 8 * 2^30 = 2^33 =&gt; 地址32位不够，64位地址</span><br><span class="hljs-comment">// 64bit 2^64B = (4G * 4G)B =&gt; 128bit可能很久都不会来了</span><br></code></pre></td></tr></table></figure>
<p>​	拿go来讲，go写完代码后，build出一个可执行文件，我们称之为装入模块（装入到内存中去）。这个可执行文件里数据段和程序段都是写死的，放在哪个地址上编译器都规定好了。这里的地址是逻辑地址，因为每次程序运行时开始的起始位置都是不同的，真正运行时的物理地址时在逻辑地址上做一个运算算出来的。这样就很安全。</p>
<h3 id="3逻辑地址-物理地址"><a class="markdownIt-Anchor" href="#3逻辑地址-物理地址"></a> 3.逻辑地址 -&gt; 物理地址</h3>
<h4 id="1绝对装入"><a class="markdownIt-Anchor" href="#1绝对装入"></a> 1.绝对装入</h4>
<p>​	在编译时就知道程序将从哪个起始地址开始运行，这样的话编译出的装入模块中的地址就是绝对地址。</p>
<h4 id="2可重定向装入静态重定位"><a class="markdownIt-Anchor" href="#2可重定向装入静态重定位"></a> 2.可重定向装入（静态重定位）</h4>
<p>​	编译时还是将起始地址设置为，在装入模块要被装入内存中去时，会给出一个起始地址，这个时候再将要装入的模块的地址进行重定向。</p>
<p>​	在执行前就必须<strong>分配全部的内存</strong>空间，并且空间需要是<strong>连续</strong>的。</p>
<p>​	在运行时就<strong>不能移动</strong>了，也<strong>不能继续再申请空间</strong>。</p>
<h4 id="3动态运行时装入动态重定位"><a class="markdownIt-Anchor" href="#3动态运行时装入动态重定位"></a> 3.动态运行时装入（动态重定位）</h4>
<p>​	与静态重定位不同，动态重定位直到程序运行，cpu加载某一条指令时，才会进行重定向。这时，有一个寄存器叫<strong>重定位寄存器</strong>，存放程序的初始地址，cpu会将重定位寄存器中的值加上逻辑地址得到真正的物理地址。</p>
<p>​	这种方法在运行时可以进行一定，只需要修改重定位寄存器中的值即可，也可以动态申请空间。</p>
<h3 id="4从代码到程序"><a class="markdownIt-Anchor" href="#4从代码到程序"></a> 4.从代码到程序</h3>
<p>​	<img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220223172514669.png" alt="image-20220223172514669"></p>
<h3 id="5三种链接方式"><a class="markdownIt-Anchor" href="#5三种链接方式"></a> 5.三种链接方式</h3>
<ul>
<li>静态链接：上一节中的链接方式，编译后直接链接产生可执行文件，也就是最终装入模块。</li>
<li>装入时动态链接：运行前进行链接，然后装入内存中</li>
<li>运行时动态链接：运行某一个模块时再链接，增大了运行时开销。</li>
</ul>
<h2 id="2内存管理的概念"><a class="markdownIt-Anchor" href="#2内存管理的概念"></a> 2.内存管理的概念</h2>
<ul>
<li>内存空间的分配与回收</li>
<li>内存空间的拓展：虚拟技术</li>
<li>地址转换：逻辑地址到物理地址</li>
<li>内存保护
<ul>
<li>设置<strong>上下限寄存器</strong>，设置进程能访问的空间的边界</li>
<li>使用**重定位寄存器（基址寄存器）<strong>和</strong>界地址寄存器（限长寄存器）**判断操作是否越界</li>
</ul>
</li>
</ul>
<h2 id="3内存拓展"><a class="markdownIt-Anchor" href="#3内存拓展"></a> 3.内存拓展</h2>
<h3 id="1覆盖技术"><a class="markdownIt-Anchor" href="#1覆盖技术"></a> 1.覆盖技术</h3>
<p>​	解决的问题：程序比内存大的情况。</p>
<p>​	思想：将程序分段，常用段常驻内存，不常用的段就在需要时调入内存。</p>
<p>​	实现：在内存中划分两种区：固定区和覆盖区</p>
<ul>
<li>固定区：存放常驻程序段</li>
<li>覆盖区：存放不常驻程序段，不用了就可能被覆盖。</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220223175452973.png" alt="image-20220223175452973"></p>
<h3 id="2交换技术"><a class="markdownIt-Anchor" href="#2交换技术"></a> 2.交换技术</h3>
<p>​	交换技术：中级调度（内存调度）</p>
<p>​	交换技术中，PCB会常驻内存。</p>
<h4 id="1交换技术的实现"><a class="markdownIt-Anchor" href="#1交换技术的实现"></a> 1.交换技术的实现</h4>
<p>​	外存可以划分为对换区和文件区：</p>
<ul>
<li>对换区：侧重于提高io速度，所以采用连续存储方式</li>
<li>文件区：侧重磁盘利用率，所以采用离散分配方式</li>
</ul>
<p>​	被交换技术交换出的进程数据就放在对换区。</p>
<h4 id="2交换技术什么时候发生"><a class="markdownIt-Anchor" href="#2交换技术什么时候发生"></a> 2.交换技术什么时候发生</h4>
<p>​	内存紧张，如多进程运行时缺页。</p>
<h4 id="3选择换出哪些进程"><a class="markdownIt-Anchor" href="#3选择换出哪些进程"></a> 3.选择换出哪些进程</h4>
<p>​	阻塞进程，优先级低的进程优先。</p>
<h3 id="3虚拟技术在分配与回收之后"><a class="markdownIt-Anchor" href="#3虚拟技术在分配与回收之后"></a> 3.虚拟技术（在分配与回收之后）</h3>
<h4 id="1传统存储方式的特征与缺点"><a class="markdownIt-Anchor" href="#1传统存储方式的特征与缺点"></a> 1.传统存储方式的特征与缺点</h4>
<ul>
<li>一次性：必须将作业完整装入内存中去</li>
<li>驻留性：作业一旦被装入内存，就会一直占据内存，但事实是，同一时刻，只需要访问少量的数据即可。大量的无用的数据驻留在内存中。</li>
</ul>
<h4 id="2虚拟内存的定义与特征"><a class="markdownIt-Anchor" href="#2虚拟内存的定义与特征"></a> 2.虚拟内存的定义与特征</h4>
<p>​	定义：在将作业装载到内存时，能很快的将需要用到的部分装载到内存中去，而不用的留在外存。若是内存不够，可以将内存中暂时不需要的部分调出内存；若是在内存中没有发现需要的部分，再将外存中需要的部分装入内存。</p>
<p>​	特征：</p>
<ul>
<li>多次性：作业通过多次调入内存，而不是一次装入</li>
<li>对换性：作业并不会常驻内存，而是根据需要，将某些部分调入调出内存</li>
<li>虚拟性：物理空间并没有增加，但是用户看来时增加了。</li>
</ul>
<h4 id="3实现"><a class="markdownIt-Anchor" href="#3实现"></a> 3.实现</h4>
<p>​	建立在离散分配管理的基础上。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226202656336.png" alt="image-20220226202656336"></p>
<p>​	调入内存：请求调页/段</p>
<p>​	换出内存：页面/段置换</p>
<h5 id="1请求分页管理方式"><a class="markdownIt-Anchor" href="#1请求分页管理方式"></a> 1.请求分页管理方式</h5>
<p>​	需要提供两个功能：请求调页&amp;页置换</p>
<h6 id="1页表"><a class="markdownIt-Anchor" href="#1页表"></a> 1.页表</h6>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226210834039.png" alt="image-20220226210834039"></p>
<p>​	请求页表中新增了四个字段。为了实现调入和换出的功能。</p>
<h6 id="2缺页中断机构"><a class="markdownIt-Anchor" href="#2缺页中断机构"></a> 2.缺页中断机构</h6>
<ul>
<li>逻辑地址（页号， 偏移量）</li>
<li>根据页号访问对应页面，检查状态位
<ul>
<li>若页面在内存中，直接得到逻辑地址</li>
<li>若页面不再内存中
<ul>
<li>有空闲页框：将页面从外存调入内存</li>
<li>无空闲页框：根据<strong>算法</strong>，选择一个页面换出外存，并将需要的页面调入内存。检查被换出的页面在页表中的修改位。
<ul>
<li>0：不需要写入外存（外存中有该页面的拷贝，并且页面没有变化，无需更改）</li>
<li>1：覆盖外存的页面。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>更新页表的字段</li>
</ul>
<p>​	缺页中断属于<strong>内中断</strong>。</p>
<h6 id="3地址转换image-20220226212649974"><a class="markdownIt-Anchor" href="#3地址转换image-20220226212649974"></a> 3.地址转换<img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226212649974.png" alt="image-20220226212649974"></h6>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226212846059.png" alt="image-20220226212846059"></p>
<h5 id="2页面置换算法"><a class="markdownIt-Anchor" href="#2页面置换算法"></a> 2.页面置换算法</h5>
<p>​	页面置换算法只有在需要进行页面置换的时候才会发生。</p>
<p>​	指标：缺页率 = 缺页中断发生次数/访问页面次数</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226213041235.png" alt="image-20220226213041235"></p>
<h6 id="1最佳置换算法opt"><a class="markdownIt-Anchor" href="#1最佳置换算法opt"></a> 1.最佳置换算法（OPT）：</h6>
<ul>
<li>思想：淘汰以后用不使用，或者最长时间不会使用的页面，需要统计后面出现的页面。</li>
<li>实现：无法实现，理想算法。</li>
</ul>
<h6 id="2先进先出算法fifo"><a class="markdownIt-Anchor" href="#2先进先出算法fifo"></a> 2.先进先出算法（FIFO）：</h6>
<ul>
<li>思想：淘汰最早进入内存的页面</li>
<li>实现：队列</li>
<li>缺点：没有规律，性能差</li>
</ul>
<h6 id="3最近最久未使用算法lru"><a class="markdownIt-Anchor" href="#3最近最久未使用算法lru"></a> 3.最近最久未使用算法（LRU）</h6>
<ul>
<li>思想：淘汰的页面是最近醉酒没使用的页面</li>
<li>实现：用访问字段记录该页面自从上次访问以来经历的时间t，选出最大的t淘汰即可。</li>
<li>优点：性能好</li>
<li>缺点：实现困难，需要硬件支持，开销大</li>
</ul>
<h6 id="4时钟置换算法clock最近未用算法nru"><a class="markdownIt-Anchor" href="#4时钟置换算法clock最近未用算法nru"></a> 4.时钟置换算法（CLOCK）/最近未用算法（NRU）</h6>
<ul>
<li>思想：设置访问位</li>
<li>实现：当页面被访问时，访问位置1。将页表项用指针形成一个循环队列，然后进行扫面，若访问位为0，就可以换出。若访问位为1，则将其置0，然后扫描下一项。如果全是1，那么第二轮的第一个就会被淘汰。所以最多会进行两轮扫描</li>
</ul>
<h6 id="5改进型时钟置换算法"><a class="markdownIt-Anchor" href="#5改进型时钟置换算法"></a> 5.改进型时钟置换算法</h6>
<ul>
<li>思想：设置一个元组，(访问位， 修改位)</li>
<li>实现：如果一个页面没有被修改过，那么淘汰的时候就不需要换出外存，直接删除即可。所以我们同时考虑访问位和修改位。
<ul>
<li>第一轮：找出淘汰(0, 0)。找不到进行第二轮</li>
<li>第二轮：找出淘汰(0, 1)。对遍历过的页表项，修改访问位0。找不到进行下一轮</li>
<li>第三轮：找出淘汰(0, 0)</li>
<li>第四轮：找出淘汰(0, 1)</li>
</ul>
</li>
</ul>
<p>​	最多进行四轮扫描。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226222820084.png" alt="image-20220226222820084"></p>
<h5 id="3页面分配策略"><a class="markdownIt-Anchor" href="#3页面分配策略"></a> 3.页面分配策略</h5>
<p>​</p>
<h2 id="4内存空间的分配与回收"><a class="markdownIt-Anchor" href="#4内存空间的分配与回收"></a> 4.内存空间的分配与回收</h2>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225172840008.png" alt="image-20220225172840008"></p>
<p>​	连续的意思是OS为系统进程分配连续的一块空间。</p>
<h3 id="1连续分配管理方式"><a class="markdownIt-Anchor" href="#1连续分配管理方式"></a> 1.连续分配管理方式</h3>
<h4 id="1单一连续分配"><a class="markdownIt-Anchor" href="#1单一连续分配"></a> 1.单一连续分配</h4>
<p>​	内存划分为系统区+用户区。</p>
<p>​	只能运行一道程序。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220224174301343.png" alt="image-20220224174301343"></p>
<p>​	没有得到利用的用户区叫内存碎片。</p>
<ul>
<li>优点：实现简单，无外部碎片</li>
<li>缺点：内存利用率低，会产生外部碎片。不支持并发。</li>
</ul>
<h4 id="2固定分区分配"><a class="markdownIt-Anchor" href="#2固定分区分配"></a> 2.固定分区分配</h4>
<p>​	细分为：</p>
<ul>
<li>分区大小相等：不灵活</li>
<li>分区大小不等：灵活</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220224174611948.png" alt="image-20220224174611948"></p>
<p>​	通过分区说明表（数据结构）来管理分区：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220224174843865.png" alt="image-20220224174843865"></p>
<ul>
<li>优点：实现简单，无外部碎片</li>
<li>缺点：有内部碎片，对大进程无法满足</li>
</ul>
<h4 id="3动态分区分配"><a class="markdownIt-Anchor" href="#3动态分区分配"></a> 3.动态分区分配</h4>
<p>​	不会预先分区，而是在作业加入时，根据程序大小，动态的建立分区。</p>
<ul>
<li>
<p>数据结构：</p>
<ul>
<li>空闲分区表</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225151532192.png" alt="image-20220225151532192"></p>
<ul>
<li>空闲分区链</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225152803650.png" alt="image-20220225152803650"></p>
</li>
<li>
<p>多个空闲分区时，如何选择 =&gt;  动态分区分配算法</p>
</li>
<li>
<p>分区的分配与回收</p>
<ul>
<li>分配：减小分区表中的分区大小 || 删除分区表的某一行（设置为非空闲）</li>
<li>回收：相邻分区合并 || 增加表项</li>
</ul>
</li>
</ul>
<p>​	在这里给出内部碎片和外部碎片的定义：</p>
<ul>
<li>内部碎片：分配给进程但是没有利用到的空间</li>
<li>外部碎片：因为太小了不能分配给进程的空间</li>
</ul>
<p>​	下面时外部碎片的例子：内存中无法满足进程1</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225153554829.png" alt="image-20220225153554829"></p>
<p>​	可以用紧凑（拼凑）技术解决问题：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225153649798.png" alt="image-20220225153649798"></p>
<h4 id="4动态分配分区算法"><a class="markdownIt-Anchor" href="#4动态分配分区算法"></a> 4.动态分配分区算法</h4>
<h5 id="1首次适应算法"><a class="markdownIt-Anchor" href="#1首次适应算法"></a> 1.首次适应算法</h5>
<p>​	思想：从低地址开始找</p>
<p>​	实现：查找分区表或分区链，找到第一个满足的分区即可。</p>
<h5 id="2最佳适应算法"><a class="markdownIt-Anchor" href="#2最佳适应算法"></a> 2.最佳适应算法</h5>
<p>​	思想：优先使用小的空闲分区</p>
<p>​	实现：空闲分区表/链按照大小递增的方式链接，然后找到第一个满足的分区就可以</p>
<p>​	缺点：会产生很多的外部碎片</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225155011445.png" alt="image-20220225155011445"></p>
<h5 id="3最坏适应算法"><a class="markdownIt-Anchor" href="#3最坏适应算法"></a> 3.最坏适应算法</h5>
<p>​	思想：优先使用大的分区</p>
<p>​	实现：将链/表按照容量递减的顺序排列，找到第一个</p>
<p>​	缺点：对大进程不友好</p>
<h5 id="4邻近适应算法"><a class="markdownIt-Anchor" href="#4邻近适应算法"></a> 4.邻近适应算法</h5>
<p>​	思想：每次查找从上次查找结束的位置开始查找</p>
<p>​	实现：循环链表</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225172615881.png" alt="image-20220225172615881"></p>
<h5 id="5总结"><a class="markdownIt-Anchor" href="#5总结"></a> 5.总结</h5>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225172659810.png" alt="image-20220225172659810"></p>
<h3 id="2非连续分配管理方式"><a class="markdownIt-Anchor" href="#2非连续分配管理方式"></a> 2.非连续分配管理方式</h3>
<h4 id="1基本分页存储管理"><a class="markdownIt-Anchor" href="#1基本分页存储管理"></a> 1.基本分页存储管理</h4>
<p>​	内存被划分成页，而不是区</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225173214318.png" alt="image-20220225173214318"></p>
<p>​	如果内存是按页划分的，那么进程也可以划分为与页框大小相等的部分，称为页面，然后放到对应的页框中区。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225173344576.png" alt="image-20220225173344576"></p>
<p>​	进程在内存中的真实组织方式：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225173411773.png" alt="image-20220225173411773"></p>
<p>​	区分：</p>
<ul>
<li>页框：也叫页帧，内存块，物理块，物理页面。内存逻辑上的划分。</li>
<li>页面：也叫页。 进程逻辑上的划分</li>
</ul>
<p>​	通过一种叫页表的数据结构，将页面和页框组织起来。一般页表是放在PCB当中的。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225174007163.png" alt="image-20220225174007163"></p>
<h5 id="1页表的存储大小计算"><a class="markdownIt-Anchor" href="#1页表的存储大小计算"></a> 1.页表的存储大小计算</h5>
<p>​	假设内存4GB，页框大小4KB</p>
<p>=&gt;页框数目 = 4GB / 4KB = 2^20</p>
<p>=&gt;块号的取值范围：0~2^20-1，20bits，所以占空间3B = 24bits</p>
<p>=&gt;页号不需要占空间</p>
<p>=&gt;若是像知道i号页表项的存储地址，在已知页表的起始地址X时，只需要计算X + 3*i即可，单位是B</p>
<p>=&gt;页表的总存储地址是3*(n + 1)</p>
<p>=&gt;若是已知内存块的块号，求内存块的起始地址：i*内存块大小</p>
<h5 id="2逻辑地址到物理地址的转换"><a class="markdownIt-Anchor" href="#2逻辑地址到物理地址的转换"></a> 2.逻辑地址到物理地址的转换</h5>
<p>​	页号 = 逻辑地址 / 页面大小</p>
<p>​	页内偏移量 = 逻辑地址%页面大小</p>
<p>​	将页面大小设置为2的整数次幂比较好计算。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225222725226.png" alt="image-20220225222725226"></p>
<p>​	原理很简单，就是算术左右移。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225223003099.png" alt="image-20220225223003099"></p>
<p>​	这样可以通过查表，通过页号得到块号，根据块号和偏移量计算出物理地址。</p>
<h5 id="3基本地址变换机构"><a class="markdownIt-Anchor" href="#3基本地址变换机构"></a> 3.基本地址变换机构</h5>
<p>​	通过硬件，实现逻辑地址到物理地址的转换。</p>
<p>​	页表寄存器（PTR），存放页表在内存中的<strong>起始地址F</strong>和<strong>页表长度M</strong>。进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器PTR中。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225225158866.png" alt="image-20220225225158866"></p>
<p>​	文字描述：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225225410138.png" alt="image-20220225225410138"></p>
<h5 id="4页表项的进一步优化"><a class="markdownIt-Anchor" href="#4页表项的进一步优化"></a> 4.页表项的进一步优化</h5>
<p>​	4Gb内存，4KB页表大小，一共拥有2^20的页表项。所以页表项长度为3B。</p>
<p>​	但是当页表项长度3B时，一个页表不能放下整数大小的页表项，所以我们把页表项长度设置为4B，这样便于页号页表的查找。</p>
<h5 id="5具有快表的地址变换机构"><a class="markdownIt-Anchor" href="#5具有快表的地址变换机构"></a> 5.具有快表的地址变换机构</h5>
<p>​	快表，联想寄存器（TLB），是一种访问速度比内存快很多的高速缓存。用来存放最近访问的页表项的副本。</p>
<p>​	可以成内存块中的页表项为慢表。</p>
<p>​	快表是一个专门的硬件设施。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225231543501.png" alt="image-20220225231543501"></p>
<p>​	有了快表后，访问逻辑地址的流程：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225232059460.png" alt="image-20220225232059460"></p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225232233910.png" alt="image-20220225232233910"></p>
<p>​	例题：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225232520024.png" alt="image-20220225232520024"></p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225232500526.png" alt="image-20220225232500526"></p>
<h5 id="6快表能提升系统效能的原因"><a class="markdownIt-Anchor" href="#6快表能提升系统效能的原因"></a> 6.快表能提升系统效能的原因</h5>
<p>​	局部性原理：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220225232800878.png" alt="image-20220225232800878"></p>
<h5 id="7两级页表"><a class="markdownIt-Anchor" href="#7两级页表"></a> 7.两级页表</h5>
<p>​	单级页表存在的问题：</p>
<p>​	假设页框大小为4KB，计算机按字节寻址，32位，所以4KB = 2<sup>12，需要12bit来表示页框内的地址，所以32位地址中表示页号的地址是20位。所以最大的页表项数目为2</sup>20，页表项大小为4B，页表的占据的存储空间为2<sup>22B，而页框的大小为2</sup>12B，所以需要连续的2^10 = 1024个页框去存放页表。一个进程的页表就需要这么多空间。</p>
<p>​	离散存储（非连续）方式就是为了节省空间，提高空间利用率，所以采用单极页表并不划算。</p>
<p>​	同时，只需要让进程进程使用的页表项常驻内存就可以了(局部性原理)，没必要将所有的页表项都放到内存中。</p>
<p>​	综上，两个问题：</p>
<ul>
<li>页表太大，并且需要连续存储</li>
<li>并不需要那么多的页表常驻内存</li>
</ul>
<p>​	参考前面，如何解决进程在内存中连续存放的问题 =&gt; 采用离散存储的方式，并且建立页表。这里也可以采用类似的思想解决：将页表分组，每组页表的大小刚好能能够塞满一个内存块。然后将各个页表分组离散存储，再建立一页表，用于找这些分组。</p>
<p>​	称新建立的页表为：<strong>页目录表</strong>（外层页表，顶层页表）</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226143743531.png" alt="image-20220226143743531"></p>
<p>​	寻址的例子：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226144029599.png" alt="image-20220226144029599"></p>
<p>​	解决了问题1，连续存储变成了离散存储，通过增加一张表。</p>
<p>​	问题2需要通过虚拟技术来解决。可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226144258904.png" alt="image-20220226144258904"></p>
<p>​	n级页表的访存次数为n+1次，虽然多级页表解决了连续问题，但是需要通过增加访存次数来弥补。</p>
<p>​	页表的大小<strong>不应该</strong>超过内存块的大小！</p>
<h4 id="2基本分段存储管理"><a class="markdownIt-Anchor" href="#2基本分段存储管理"></a> 2.基本分段存储管理</h4>
<h5 id="1进程分段"><a class="markdownIt-Anchor" href="#1进程分段"></a> 1.进程分段</h5>
<p>​	进程分段：按照程序自身的逻辑关系划分为若干个段。每个段有一个段名，在低级语言中可以根据段名来编程。</p>
<p>​	段占用的是连续空间，但段段之间可以不相邻。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226182114645.png" alt="image-20220226182114645"></p>
<p>​	地址被划分为段号加段内地址（段内偏移量）</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226182425500.png" alt="image-20220226182425500"></p>
<table>
<thead>
<tr>
<th>分页</th>
<th>分段</th>
</tr>
</thead>
<tbody>
<tr>
<td>页号</td>
<td>段号</td>
</tr>
<tr>
<td>页内偏移量</td>
<td>段内偏移量</td>
</tr>
<tr>
<td>页表</td>
<td>段表</td>
</tr>
</tbody>
</table>
<h5 id="2段表"><a class="markdownIt-Anchor" href="#2段表"></a> 2.段表</h5>
<p>​	段表的组成：</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226184000148.png" alt="image-20220226184000148"></p>
<p>​		不像分页中的那样，分页的页框大小是固定的，一般是4KB。而分段的大小，由于是按照程序的逻辑来划分的，所以每个分段的大小都不一样，所以不仅要记录分段的基址，还需要分段的段长。</p>
<p>​		但是每个段表项的长度是相同的，并且段号可以不记录，不占空间。要想求得第n个段表项的起始地址，只需要加将段表的起始地址+段表项大小*n</p>
<p>​		假设内存4GB，逻辑地址：段号16位（程序最大大小为2<sup>32B=4GB），段内地址16位（最大段长是16位，也就是2</sup>16B=64KB）。由内存可得到，物理地址是32位的，所以段表项是32（基址）+16（段长）=48位。所以要存放段表项，需要6B。</p>
<h5 id="3段表存储的寻址过程"><a class="markdownIt-Anchor" href="#3段表存储的寻址过程"></a> 3.段表存储的寻址过程</h5>
<ul>
<li>2次访存：段表项&amp;物理地址</li>
<li>2次检查越界：段号是否超出段表长度&amp;段内偏移地址是否超过段长。</li>
</ul>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226190327446.png" alt="image-20220226190327446"></p>
<h5 id="4分段分页对比"><a class="markdownIt-Anchor" href="#4分段分页对比"></a> 4.分段分页对比</h5>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226191120332.png" alt="image-20220226191120332"></p>
<p>​	分段更容易实现信息的共享：</p>
<p>​		假如生产者消费者中使用分段存储：段表项指向同一片物理空间</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226191533322.png" alt="image-20220226191533322"></p>
<p>​</p>
<p>​	若是进程采用分页存储，那么页表项指向某一页就没有任何意义。</p>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226193459917.png" alt="image-20220226193459917"></p>
<h5 id="5快表"><a class="markdownIt-Anchor" href="#5快表"></a> 5.快表</h5>
<p>​	也可以添加高速缓存快表。</p>
<p>​	若快表命中就不需要进行一次访存。</p>
<h4 id="3段页式存储管理"><a class="markdownIt-Anchor" href="#3段页式存储管理"></a> 3.段页式存储管理</h4>
<p>​	分段与分页的结合。</p>
<h5 id="1分段分页的最优缺点"><a class="markdownIt-Anchor" href="#1分段分页的最优缺点"></a> 1.分段分页的最优缺点</h5>
<ul>
<li>分页：
<ul>
<li>优点：内存利用率高，不会产生外部碎片，少量的页内碎片</li>
<li>缺点：不能很好的实现信息的共享</li>
</ul>
</li>
<li>分段：
<ul>
<li>优点：很好的实现信息的共享与保护</li>
<li>缺点：段长过大，分配长的连续空间很不方便。同时可能会产生外部碎片。</li>
</ul>
</li>
</ul>
<h5 id="2段页式存储管理"><a class="markdownIt-Anchor" href="#2段页式存储管理"></a> 2.段页式存储管理</h5>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226195439387.png" alt="image-20220226195439387"></p>
<p>​	段号：决定进程最多多少段。</p>
<p>​	页号：决定每段最多多少页。</p>
<p>​	页内偏移量：决定页面的大小。</p>
<p>​	图中，段号16，所以最多2<sup>16=64K段。页号4，最多2</sup>4=8页。页内偏移量12，页框大小2^12=4KB。</p>
<p>​	所以进程的最大大小位64K * 8 * 4KB=4GB，RAM是4GB</p>
<h5 id="3段表页表"><a class="markdownIt-Anchor" href="#3段表页表"></a> 3.段表页表</h5>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226200309401.png" alt="image-20220226200309401"></p>
<h5 id="4地址转换"><a class="markdownIt-Anchor" href="#4地址转换"></a> 4.地址转换</h5>
<p><img src="/img/avatar.png" srcset="/img/loading.gif" lazyload data-original="/2022/04/22/os/image-20220226200523696.png" alt="image-20220226200523696"></p>
<p>​	三次访存：段表&amp;页表&amp;物理地址</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/22/co/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机组成原理</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/22/leetcode/">
                        <span class="hidden-mobile">leetcode每日一题</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
