<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rust-lang</title>
    <link href="/2022/02/14/rust-lang/"/>
    <url>/2022/02/14/rust-lang/</url>
    
    <content type="html"><![CDATA[<h1 id="0-基本操作"><a href="#0-基本操作" class="headerlink" title="0.基本操作"></a>0.基本操作</h1><h2 id="1-使用Clion开发Rust"><a href="#1-使用Clion开发Rust" class="headerlink" title="1.使用Clion开发Rust"></a>1.使用Clion开发Rust</h2><p>​    需要在系统的path里添加clion的bin路径，然后就可以通过命令行使用clion .来打开项目了。</p><h2 id="2-使用cargo创建库项目"><a href="#2-使用cargo创建库项目" class="headerlink" title="2.使用cargo创建库项目"></a>2.使用cargo创建库项目</h2><p>​    cargo new add –lib</p><h2 id="3-打印地址"><a href="#3-打印地址" class="headerlink" title="3.打印地址"></a>3.打印地址</h2><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">o</span> = Obj::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">adr</span> = &amp;o <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> Obj <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0x&#123;:x&#125;&quot;</span>, adr);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Obj</span> &#123;<br>    val1: <span class="hljs-type">u8</span>,<br>    val2: <span class="hljs-type">u8</span>,<br>    val3: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Obj</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(v1: <span class="hljs-type">u8</span>, v2: <span class="hljs-type">u8</span>, v3: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> Obj &#123;<br>        Obj &#123;<br>            val1: v1,<br>            val2: v2,<br>            val3: v3,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1-rust简介"><a href="#1-rust简介" class="headerlink" title="1 rust简介"></a>1 rust简介</h1><h2 id="1-1-基本特性"><a href="#1-1-基本特性" class="headerlink" title="1.1 基本特性"></a>1.1 基本特性</h2><p>特性</p><ul><li><p>运行时速度快</p></li><li><p>内存安全</p></li><li><p>并发</p><p>  rust是一门安全的语言，表现在类型安全和内存安全（横向对比c&#x2F;c++），同时性能也很好，因为没有GC（对比java），同时在设计的时候就考虑了多核处理器，支持并发，火狐公司的一个内核就是用rust写的，全并发执行。</p><p>  rust采的命名方法是：蛇形命名法，也就是字母小写单词之间加下划线</p><p>  rust的命令有rustc和rustup，rustc后面的c的意思是编译器。</p></li></ul><h2 id="1-2-命令行-vscode构建项目"><a href="#1-2-命令行-vscode构建项目" class="headerlink" title="1.2 命令行+vscode构建项目"></a>1.2 命令行+vscode构建项目</h2><p>步骤</p><ul><li>mkdir hello_rust创建工程目录</li><li>cd h*进入目录</li><li>code .用vscode打开该工程</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">常用的windows cmd命令<br><span class="hljs-number">1</span>. cd / -<span class="hljs-punctuation">-&gt;</span> 进入首盘，如c盘d盘<br><span class="hljs-number">2</span>. cd .. -<span class="hljs-punctuation">-&gt;</span> 进入上一级目录<br><span class="hljs-number">3</span>. dir -<span class="hljs-punctuation">-&gt;</span> 查看当当前目录下的文件 dir /a 是查看所有文件，包括隐藏文件<br><span class="hljs-number">4</span>. 可以用help cd查看cd的用法<br></code></pre></td></tr></table></figure><h2 id="1-3-编写hello-world程序"><a href="#1-3-编写hello-world程序" class="headerlink" title="1.3 编写hello world程序"></a>1.3 编写hello world程序</h2><ul><li>fn表示函数声明</li><li>rust采用的缩进不是tab，而是四个空格</li><li>println!是rust的宏，也就是rust micro</li><li>rust是预先编译的语言，也就是先编译好，然后生成二进制文件，可直接交给别人使用，而无需rust环境</li><li>rustc只适用于简单的rust文件，用cargo</li></ul><h2 id="1-4-cargo创建工程"><a href="#1-4-cargo创建工程" class="headerlink" title="1.4 cargo创建工程"></a>1.4 cargo创建工程</h2><div class="code-wrapper"><pre><code class="hljs">cargo是rust的创建及包管理工具rust里代码的包称为crate</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">windows cmd<br><span class="hljs-number">1</span>.rmdir xxx -- remove dir<br><span class="hljs-number">2</span>.del xxx -- delete file<br></code></pre></td></tr></table></figure><p>cargo.toml文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.toml是cargo的配置文件<br><span class="hljs-number">2</span>.前一部分是项目的信息，如项目名称，package，版本信息作者等<br><span class="hljs-number">3</span>.后部分是项目依赖<br></code></pre></td></tr></table></figure><p>顶层目录可放置的信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.README文件<br><span class="hljs-number">2</span>.许可信息<br><span class="hljs-number">3</span>.配置文件<br><span class="hljs-number">4</span>.其它与源程序无关的东西<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">当没有用cargo创建工程时，可以直接把文件拷贝到src下，然后再在顶层目录下编写一个cargo.toml文件即可</code></pre></div><p>cargo.lock</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.负责追寻项目依赖的准确版本<br><span class="hljs-number">2</span>.不需要去修改这个文件<br></code></pre></td></tr></table></figure><p>使用cargo运行项目</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.cargo run会编译当前工程的main.rs及相关文件，然后再运行生成的exe文件<br><span class="hljs-number">2</span>.如果源代码没有更改过的话，就不编译了，之既然运行exe<br></code></pre></td></tr></table></figure><p>cargo check调试检查项目</p><div class="code-wrapper"><pre><code class="hljs">一般在开发的时候都是用的这个命令来进行检查调试，因为更快。只有要生成文件的时候才会使用run/build指令如果要发布的话，使用cargo build --release，这样编译的时候时间更久，会进行优化，提高编译出来的程序的性能</code></pre></div><br><h1 id="2-rust基本语法"><a href="#2-rust基本语法" class="headerlink" title="2 rust基本语法"></a>2 rust基本语法</h1><h2 id="2-1-获取控制台输入"><a href="#2-1-获取控制台输入" class="headerlink" title="2.1 获取控制台输入"></a>2.1 获取控制台输入</h2><h3 id="1-输入"><a href="#1-输入" class="headerlink" title="1.输入"></a>1.输入</h3><div class="code-wrapper"><pre><code class="hljs">std里提供了一个io，也就是标准输入输出，然后io里有一个关联函数叫stdin，是io里关于输入输出的输入那一部分，会返回一个句柄。然后stdin里有一个方法是read_line，读取命令行中的一行，这个方法可能抛出异常，所以该有一个except函数。read_line会返回一个io::Result类型，也就是枚举类型，有两个值，一个是OK，另一个是Err，如果返回Err的话，就会中断当前程序，执行except那一部分。</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::io::stdin.<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> string).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;exception message&quot;</span>);<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">关联函数类似于java中的静态方法。</code></pre></div><h3 id="2-输出"><a href="#2-输出" class="headerlink" title="2.输出"></a>2.输出</h3><div class="code-wrapper"><pre><code class="hljs">println!宏</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;这是一个数字：&#123;&#125;&quot;</span>, number);<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">&#123;&#125;中的就是number。</code></pre></div><h2 id="2-2-添加外部依赖包rand（修改toml文件）"><a href="#2-2-添加外部依赖包rand（修改toml文件）" class="headerlink" title="2.2 添加外部依赖包rand（修改toml文件）"></a>2.2 添加外部依赖包rand（修改toml文件）</h2><div class="code-wrapper"><pre><code class="hljs">在cargo.toml中添加bin结点。</code></pre></div><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;guess_game&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang/.org/cargo/reference/manifest.html</span><br><span class="hljs-comment"># 下面的部分是添加的代码，其中name是你的项目名称</span><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;guess_game&quot;</span><br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;src/test.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">rand</span> = <span class="hljs-string">&quot;0.5.0&quot;</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">然后cargo就会自动下载依赖包了。为什么会自动下载包？其实，是因为打开了rust server，这样就会自动去扫描toml里的依赖，检查版本并且及时下载对应的版本。如果我们关闭这个server，那么更新toml中的依赖，工程文件中的包并不会更新，因为工程文件会去lock文件中去找到并使用对应的版本。这个时候不仅要修改toml，还要进行生级，也就是输入指令：cargo update。但事实上使用这个指令需要换源，因为直接用的话，会提示超时，因为下载的源好像是github，需要用steam++加速或者换源。</code></pre></div><h2 id="2-3-使用枚举进行比较"><a href="#2-3-使用枚举进行比较" class="headerlink" title="2.3 使用枚举进行比较"></a>2.3 使用枚举进行比较</h2><div class="code-wrapper"><pre><code class="hljs">进行比较需要用到std下的cmp中的Ordering这个枚举类型。</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">进行枚举时需要注意一下两个问题：</code></pre></div><ul><li>类型一致</li><li>使用时大小等都得写全</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num2</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">match</span> num1.<span class="hljs-title function_ invoke__">cmp</span>(&amp;num2) &#123;<br>    Ordering::Equal =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;=&quot;</span>),<br>    Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt;&quot;</span>),<br>    Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&lt;&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-处理异常"><a href="#2-4-处理异常" class="headerlink" title="2.4 处理异常"></a>2.4 处理异常</h2><div class="code-wrapper"><pre><code class="hljs">前面我们使用的是except方法来处理异常，如parse将字符串转换成数字时，会返回一个Result，根据这个类型是OK还是Err来判断是否执行except中的内容。如果Result中判定为Err的话，会直接中断当前程序，然后程序结束（崩溃）。这样我们的程序一遇到非法输入就崩溃，并不健壮。所以这里我们用了上一节中的match模式匹配来处理这个问题。如果是OK的话，就执行ok的代码块，如果是Rrr的话再做相应的应对措施（如提示用户重新输入）</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> num.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>    <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is not valid input, try again&quot;</span>, num.<span class="hljs-title function_ invoke__">trim</span>());<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;,<br>&#125;; <span class="hljs-comment">//将字符串转为u32类型，无符号整数32位</span><br></code></pre></td></tr></table></figure><h1 id="3-变量及控制流"><a href="#3-变量及控制流" class="headerlink" title="3 变量及控制流"></a>3 变量及控制流</h1><h2 id="3-1变量"><a href="#3-1变量" class="headerlink" title="3.1变量"></a>3.1变量</h2><h3 id="3-1-1-不可变变量"><a href="#3-1-1-不可变变量" class="headerlink" title="3.1.1 不可变变量"></a>3.1.1 不可变变量</h3><p>​    使用let关键字声明，将等号右边的值绑定到等号左侧。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = -<span class="hljs-number">1</span>;<br><span class="hljs-comment">// num = 2;错误，不可变变量无法二次绑定</span><br></code></pre></td></tr></table></figure><h3 id="3-1-2-可变变量"><a href="#3-1-2-可变变量" class="headerlink" title="3.1.2 可变变量"></a>3.1.2 可变变量</h3><p>​    mutable，可变化的，还是使用let声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">1</span>;<br>num = num + <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h3 id="3-1-3-常量"><a href="#3-1-3-常量" class="headerlink" title="3.1.3 常量"></a>3.1.3 常量</h3><p>​        常量用const声明（constant的意思），常量必须显式声明数据类型，无法自动推断。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> MAX_LEN: <span class="hljs-type">u8</span> = <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure><p>​    其实工程中大多数都是不可变类型的变量。</p><h2 id="3-2-shadow机制"><a href="#3-2-shadow机制" class="headerlink" title="3.2 shadow机制"></a>3.2 shadow机制</h2><p>​    变量可以被隐藏。如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-string">&quot;ssss&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = string.<span class="hljs-title function_ invoke__">len</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = string + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;string is &#123;&#125;&quot;</span>, string);<br></code></pre></td></tr></table></figure><p>​    此机制是为了避免以下情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name_string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jack&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">name_length</span> <span class="hljs-operator">=</span> name_string.length();<br></code></pre></td></tr></table></figure><h2 id="3-3-标量类型"><a href="#3-3-标量类型" class="headerlink" title="3.3 标量类型"></a>3.3 标量类型</h2><h3 id="3-3-1-整数"><a href="#3-3-1-整数" class="headerlink" title="3.3.1 整数"></a>3.3.1 整数</h3><p>​    整数的类型：</p><p>​                                                     <img src="/2022/02/14/rust-lang/image-20220114153100948.png" alt="image-20220114153100948"></p><p>​    其中isize和usize和机器的位数有关，一般不用。</p><p>​    整数的字面量表示：</p><p><img src="/2022/02/14/rust-lang/image-20220114153226641.png" alt="image-20220114153226641"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">adr</span> = <span class="hljs-number">0x1234_5678u64</span><span class="hljs-comment">//无符号64位16进制数</span><br></code></pre></td></tr></table></figure><p>​    整数的默认类型一般是i32，比较快。    </p><p>​    下面是整数溢出的情况：</p><ul><li>调试模式下：会发生panic（恐慌）</li><li>发布模式：不发生panic，选择环绕操作，即256&#x3D;0</li></ul><h3 id="3-3-2-浮点"><a href="#3-3-2-浮点" class="headerlink" title="3.3.2 浮点"></a>3.3.2 浮点</h3><p>​    两种类型：</p><ul><li>f64</li><li>f32</li></ul><p>​    一般是采用f64</p><h3 id="3-3-3-bool类型"><a href="#3-3-3-bool类型" class="headerlink" title="3.3.3 bool类型"></a>3.3.3 bool类型</h3><p>​    true或者false。</p><p>​    占用大小一个Byte</p><p>​    为什么不用一个bit？因为如果用一位的话不利于存储，会产生内存碎片。</p><h3 id="3-3-4-字符类型"><a href="#3-3-4-字符类型" class="headerlink" title="3.3.4 字符类型"></a>3.3.4 字符类型</h3><p>​    char</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">yeye</span> = &#x27;👴&#x27;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, yeye);<br></code></pre></td></tr></table></figure><h2 id="3-4-复合类型"><a href="#3-4-复合类型" class="headerlink" title="3.4 复合类型"></a>3.4 复合类型</h2><h3 id="3-4-1-元组Tuple"><a href="#3-4-1-元组Tuple" class="headerlink" title="3.4.1 元组Tuple"></a>3.4.1 元组Tuple</h3><p>​    每个位置对应一个类型，类型不必相同。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tp</span> = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, tp.<span class="hljs-number">0</span>, tp.<span class="hljs-number">1</span>, tp.<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>​    元组赋值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tp</span> = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>);<br><span class="hljs-comment">// println!(&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;, tp.0, tp.1, tp.2);</span><br><span class="hljs-keyword">let</span> (x, y, z) = tp;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, x, y, z);<br></code></pre></td></tr></table></figure><h3 id="3-4-2-数组"><a href="#3-4-2-数组" class="headerlink" title="3.4.2 数组"></a>3.4.2 数组</h3><p>​    和其他语言类似</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h3 id="3-4-5-Vector"><a href="#3-4-5-Vector" class="headerlink" title="3.4.5 Vector"></a>3.4.5 Vector</h3><p>​    大小可变，用的更多。</p><h2 id="3-5-函数"><a href="#3-5-函数" class="headerlink" title="3.5 函数"></a>3.5 函数</h2><p>​    函数声明，函数名，参数列表，返回值。这是声明函数的全过程。</p><p>​    代码块里的最后一行没加分号，代表是返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">32</span>, <span class="hljs-number">2</span>))<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    x + y<br>&#125;<br></code></pre></td></tr></table></figure><p>​    或者这样也行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-if-else"><a href="#3-6-if-else" class="headerlink" title="3.6 if-else"></a>3.6 if-else</h2><p>​    第一种用法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">if</span> cdt &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure><p>​    第二种：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>;<br><span class="hljs-keyword">if</span> cdt &#123;<br>    num = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure><p>​    如果ifelse嵌套太多，使用模式匹配吧。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">match</span> cdt &#123;<br>    <span class="hljs-literal">true</span> =&gt; <span class="hljs-number">1</span>,<br>    <span class="hljs-literal">false</span> =&gt; <span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure><h2 id="3-7-循环"><a href="#3-7-循环" class="headerlink" title="3.7 循环"></a>3.7 循环</h2><h3 id="3-7-1-loop"><a href="#3-7-1-loop" class="headerlink" title="3.7.1 loop"></a>3.7.1 loop</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">loop</span> &#123;<br>    count = count + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, count);<br>    <span class="hljs-keyword">if</span> count &gt;<span class="hljs-number">100</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7-2-while"><a href="#3-7-2-while" class="headerlink" title="3.7.2 while"></a>3.7.2 while</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">100</span> &#123;<br>    count = count + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7-3-for-each"><a href="#3-7-3-for-each" class="headerlink" title="3.7.3 for - each"></a>3.7.3 for - each</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> arr &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> arr.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure><p>60s倒计时</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">e</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">61</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-所有权"><a href="#4-所有权" class="headerlink" title="4 所有权"></a>4 所有权</h1><p>​    rust采用所有权系统来管理内存。并且，是在编译时检查，这样就不会减慢程序运行的速度。无运行时开销。</p><p><img src="/2022/02/14/rust-lang/image-20220114182046202.png" alt="image-20220114182046202"></p><h2 id="4-1-栈内存与堆内存"><a href="#4-1-栈内存与堆内存" class="headerlink" title="4.1 栈内存与堆内存"></a>4.1 栈内存与堆内存</h2><ul><li>堆栈：LIFO，last in first out，后进先出</li><li>堆：OS给用户在heap上找到一块足够大的区域，标记为在用，然后返回给用户。这就是在堆上分配内存。</li></ul><p><img src="/2022/02/14/rust-lang/image-20220114181038063.png" alt="image-20220114181038063"></p><p>​    堆是通过分配来得到内存，而栈不同，栈是直接将数据存放到那一个格子就行了，不需要分配。</p><p>​    栈上分配的内存是固定不变的，如数组。而堆上分配的内存可以动态变化，也就是可变数组，像C语言里的动态内存分配，就是在堆上分配空间，然后返回一个指针给用户（malloc函数返回指针）。而这个指针由于是固定大小，所以可以存到栈上去。</p><p>​    在堆上分配空间更慢，因为OS需要找到一块足够大的空间。而在栈上就比较快了，因为这个空间肯定在栈的顶端。</p><p>​    在堆上访问数据也慢，因为需要通过指针寻址来访问，是间接访问，需要跳转，从栈-&gt;堆，比较慢；而从栈上访问数据就不一样了，因为是栈-&gt;栈，所以快。</p><p><img src="/2022/02/14/rust-lang/image-20220114181940185.png" alt="image-20220114181940185"></p><h2 id="4-2-所有权规则"><a href="#4-2-所有权规则" class="headerlink" title="4.2 所有权规则"></a>4.2 所有权规则</h2><p><img src="/2022/02/14/rust-lang/image-20220114182405990.png" alt="image-20220114182405990"></p><p>​    简化：在一个时间内，每个值有且只有一个变量，并且当所有者超出作用域时，所有者及其值将被删除。</p><h2 id="4-3-初识String"><a href="#4-3-初识String" class="headerlink" title="4.3 初识String"></a>4.3 初识String</h2><p>​    之前的标量数据类型都是存储在stack上的，一旦离开作用域就会被弹出。</p><p>​    而String是一种存放在heap上的数据类型。    </p><p>​    String可以代表std中复杂的数据类型，或者是我们自己创建的数据类型。</p><p>​    在程序运行中，有两种字符串：</p><ul><li>字符串字面量：是不可变的。在程序运行之前，即在编译期间，就可以知道其内容了，所以直接硬编码到可执行文件中了。所以在运行期间就不需要额外的内存了，高效。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">//hello就是一个字符串字面量</span><br></code></pre></td></tr></table></figure><ul><li>String类型：可变的，如获取用户的输入是，是不可预知的，用的就是String。String是在运行期间才会在heap上分配内存，通过from函数向OS申请内存。然后变变量超出作用域后，救会通过drop函数回收内存（自动的）。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//从字符串字面量创建一个String类型</span><br></code></pre></td></tr></table></figure><p>​    下面解释一段程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br></code></pre></td></tr></table></figure><p>​    第一行向heap申请了一块内存。具体是如下：在堆上申请了一块空间，存放hello字符数组，然后返回这个字符数组的三个信息：起始地址，长度，容量。返回给s1接收。</p><p><img src="/2022/02/14/rust-lang/image-20220115132259157.png" alt="image-20220115132259157"></p><p>​    第二行是将s1的指针考培给了s2，包括heap指针，len和capacity。然后按照常规的思路，s1 s2都离开作用域时，都会进行drop回收内存。这样一块heap内存被回收了两次，是不安全的。</p><p>​    为了解决这个，在将s1指针拷贝给了s2后，也就是MOVE操作后，s1的内容被废弃，再次调用将出现报错。然后s1s2离开作用域后，只有s2指向的heap会被drop掉。</p><p><img src="/2022/02/14/rust-lang/image-20220115132743008.png" alt="image-20220115132743008"></p><p><img src="/2022/02/14/rust-lang/image-20220115132811413.png" alt="image-20220115132811413"></p><p>​    这样无疑更安全，也不会在堆上重新分配空间。</p><p>​    以上其实是一种浅拷贝，然是由于s1时失效了，于是创建了新的术语叫MOVE。</p><ul><li>浅拷贝 – MOVE移动</li><li>深拷贝 – CLONE克隆</li></ul><p>​    Rust所有的操作都是廉价的浅拷贝操作，不会开辟新的heap内存，除非是这样要求的。</p><p>​    下面的深拷贝，即克隆的操作。</p><p><img src="/2022/02/14/rust-lang/image-20220115133335999.png" alt="image-20220115133335999"></p><p><img src="/2022/02/14/rust-lang/image-20220115133353197.png" alt="image-20220115133353197"></p><p>​    而在栈上进行的MOVE，先前声明的变量就不会失效。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">//useful</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x; <span class="hljs-comment">//useful</span><br></code></pre></td></tr></table></figure><p>​    可以用下面两个概念来解释：</p><ul><li>Copy trait（复制特性）：实现了Copy trait的数据结构，在赋值后旧的变量仍然有效。</li><li>Drop trait（回收特性）：实现了Drop trait的数据结构，不能再实现Copy trait</li></ul><p><img src="/2022/02/14/rust-lang/image-20220115134031494.png" alt="image-20220115134031494"></p><h2 id="4-4-函数与所有权"><a href="#4-4-函数与所有权" class="headerlink" title="4.4 函数与所有权"></a>4.4 函数与所有权</h2><p>​    将值窜给函数，要么会发生移动（Move），要么发生复制（Copy）</p><p><img src="/2022/02/14/rust-lang/image-20220115135319262.png" alt="image-20220115135319262"></p><ul><li>copy trait的数据类型被传入时（i32）：传进去的时副本，在函数结束的时候，副本会被弹出stack</li><li>drop trait数据类型被传入时（String）：传进去后，旧的变量丧失所有权，回收时不再使用drop清理heap内存。传进去的数据获得所有权，在函数结束时弹出堆栈并且使用drop回收堆内存</li></ul><p>​    如果想即使用所有权，还能返回回来的话，可以使用元组</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> (s1, len) = <span class="hljs-title function_ invoke__">get_len</span>(s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;   &#123;&#125;&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_len</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>, <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br>    (s, l)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-引用"><a href="#4-5-引用" class="headerlink" title="4.5 引用"></a>4.5 引用</h2><p>​    引用：引用数据的值而不使用其所有权。&amp;符号表示</p><p><img src="/2022/02/14/rust-lang/image-20220115140318148.png" alt="image-20220115140318148"></p><p>引用分类：</p><ul><li>不可变引用：不能修改指向堆上的数据</li><li>可变引用：可以修改指向堆上的数据</li><li>悬空引用：引用指向的数据已经被释放，而引用依然有效（Rust在编译期杜绝了这个问题）</li></ul><p><img src="/2022/02/14/rust-lang/image-20220115141807954.png" alt="image-20220115141807954"></p><p>​    有以下规则： </p><ul><li>一个作用域内只能有一个可变引用</li><li>一个作用域内可以有多个不可变引用</li><li>同一个作用域内可变引用与不可变引用不能同时存在</li></ul><p><img src="/2022/02/14/rust-lang/image-20220115142315424.png" alt="image-20220115142315424"></p><p>​    可以看到：先声明了俩不可变的引用，然后声明了一个可变引用。如果不对不可变引用做操作的话，不会报错。如果在声明了可变引用后，还对不可变引用进行操作，这样就会报错。</p><h2 id="4-5-切片"><a href="#4-5-切片" class="headerlink" title="4.5 切片"></a>4.5 切片</h2><p><img src="/2022/02/14/rust-lang/image-20220115144940387.png" alt="image-20220115144940387"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;ssss ssss&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">indx</span> = <span class="hljs-title function_ invoke__">get_space_index</span>(&amp;s);<br>    s.<span class="hljs-title function_ invoke__">clear</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, indx);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_space_index</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> p1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上面的代码是获取第一个空格所在的位置。</p><p>​    bug：当字符串被清空了后，得到的index不会发生改变，也就是同步性的问题。要保证：在字符串改变的同时，这个index也会同步改变。这很困难。</p><p>​    rust可以采用切片解决这个问题。</p><p><img src="/2022/02/14/rust-lang/image-20220115144751616.png" alt="image-20220115144751616"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;ssss ssss&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">indx</span> = <span class="hljs-title function_ invoke__">get_space_index</span>(&amp;s[..]);<br>    s.<span class="hljs-title function_ invoke__">clear</span>(); <span class="hljs-comment">//报错，这个方法会创建一个可变的引用，与上一行的不可变引用冲突 </span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, indx);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_space_index</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> p1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i]; <span class="hljs-comment">//[0, i)</span><br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    因为函数里面采用了字符串切片，也就是不可变引用，所以修改时报错。</p><p>​    注意：字符串切片仅仅针对UTF-8的字符，两字节的汉字会报错。</p><p>​    还做了一个优化，把字符串引用修改成为了字符串切片，这样就能同时接收两种类型了(&amp;String -&gt; &amp;str)。如字符串字面量（&amp;str）和String类型。</p><p>​    数组也可以切片，和上面类似。</p><h1 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h1><h2 id="5-1-结构定义"><a href="#5-1-结构定义" class="headerlink" title="5.1 结构定义"></a>5.1 结构定义</h2><p>​    三类：</p><ul><li>struct：普通结构</li><li>tuple struct：元组结构，当你想给元组起名字的时候，使用它。</li><li>Unit - like - struct：无任何字段的结构</li></ul><p>​    普通结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    active: <span class="hljs-type">bool</span>,<br>    id: <span class="hljs-type">u32</span>,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jack</span> = <span class="hljs-title function_ invoke__">get_user</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;jack&quot;</span>), String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;12222@qq.com&quot;</span>), <span class="hljs-literal">true</span>, <span class="hljs-number">1111</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jack.active);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_user</span>(name: <span class="hljs-type">String</span>, email: <span class="hljs-type">String</span>, active: <span class="hljs-type">bool</span>, id: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        name,<br>        email,<br>        active,<br>        id,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    元组结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-结构实例"><a href="#5-2-结构实例" class="headerlink" title="5.2 结构实例"></a>5.2 结构实例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = rectangle&#123;<br>        width: <span class="hljs-number">2</span>,<br>        length: <span class="hljs-number">3</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">get_area</span>(&amp;r1));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, r1);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_area</span>(rec: &amp;rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    rec.length * rec.width<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    Rust中有类似与java的toString方法，或者说是trait，但是默认没有实现，所以我们就用的是debug特性。</p><p><img src="/2022/02/14/rust-lang/image-20220115163757974.png" alt="image-20220115163757974"></p><ul><li>#[derive(Debug)]：实现debug trait</li><li>{:?}：输出结构的信息，不换行</li><li>{:#?}：输出结构的信息，换行</li></ul><h2 id="5-3-struct方法"><a href="#5-3-struct方法" class="headerlink" title="5.3 struct方法"></a>5.3 struct方法</h2><p>​    两种：</p><ul><li>方法：方法用impl定义的块去实现，需要传递它本身（或本身的引用）</li><li>关联函数：不需要传递本身，只是跟这个结构有关联，类似静态函数。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.length<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.length &gt;= other.length &amp;&amp; <span class="hljs-keyword">self</span>.width &gt;= other.width<br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sqare</span>(size: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> rectangle &#123;<br>        rectangle &#123;<br>            width: size,<br>            length: size,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">20</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = rectangle &#123;<br>        width: <span class="hljs-number">100</span>,<br>        length: <span class="hljs-number">20</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = rectangle &#123;<br>        width: <span class="hljs-number">10</span>,<br>        length: <span class="hljs-number">10</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r2.<span class="hljs-title function_ invoke__">area</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;r2));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;r3));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = rectangle::<span class="hljs-title function_ invoke__">sqare</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, r4);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-枚举与模式匹配"><a href="#6-枚举与模式匹配" class="headerlink" title="6 枚举与模式匹配"></a>6 枚举与模式匹配</h1><h2 id="6-1-定义枚举"><a href="#6-1-定义枚举" class="headerlink" title="6.1 定义枚举"></a>6.1 定义枚举</h2><p>​    rust的枚举很强大。可以自定义枚举并存储数据，不需要消耗额外的结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">home</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-number">120</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V6</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;::1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>​    枚举也可以定义方法。与结构体相同使用impl</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">express</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-2-Option枚举"><a href="#6-2-Option枚举" class="headerlink" title="6.2 Option枚举"></a>6.2 Option<T>枚举</T></h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span> &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;Sdssdffdsdsds&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n2</span>:<span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-match"><a href="#6-3-match" class="headerlink" title="6.3 match"></a>6.3 match</h2><p>​    math允许一个值与一系列的模式进行匹配，并执行匹配上的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Fir,<br>    <span class="hljs-title function_ invoke__">Fun</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Week</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_fun</span>(one_day: &amp;Week) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">match</span> one_day &#123;<br>            Week::<span class="hljs-title function_ invoke__">Fun</span>(statement) =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, statement);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            Week::Mon =&gt; <span class="hljs-literal">false</span>,<br>            Week::Fir =&gt; <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::<span class="hljs-title function_ invoke__">Fun</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;no need to work!!!&quot;</span>));<br>    Week::<span class="hljs-title function_ invoke__">is_fun</span>(&amp;day);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上面通过枚举存储了数据（String），并且通过模式匹配，将数据与statement绑定，重现了数据。</p><p>​    match必须列举所有的值进行匹配，若值太多了，使用_来代表其他的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>    <span class="hljs-title function_ invoke__">Fun</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Week</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_fun</span>(one_day: &amp;Week) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">match</span> one_day &#123;<br>            Week::<span class="hljs-title function_ invoke__">Fun</span>(statement) =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, statement);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            Week::Mon =&gt; <span class="hljs-literal">false</span>,<br>            Week::Fir =&gt; <span class="hljs-literal">false</span>,<br>            _ =&gt; <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-4-if-let语法糖"><a href="#6-4-if-let语法糖" class="headerlink" title="6.4 if-let语法糖"></a>6.4 if-let语法糖</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;this is Firday&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;nonono&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    等价于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir;<br>    <span class="hljs-keyword">match</span> day &#123;<br>        Week::Fir =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;this is Firday&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;nonono&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-package-crate-module"><a href="#7-package-crate-module" class="headerlink" title="7  package crate module"></a>7  package crate module</h1><p><img src="/2022/02/14/rust-lang/image-20220116100625209.png" alt="image-20220116100625209"></p><h2 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h2><p>​    自顶向下：</p><ul><li><p>Package：通过cargo可以创建一个新的包，位于最顶层。</p></li><li><p>Crate：cargo创建完包后，下面的.rs文件，有的会生成binary二进制文件（main.rs就是默认创建的binary文件，crate root），有的是产生library（其它的非main.rs文件）。Crate只能是以下两种类型：</p><ul><li>binary</li><li>library</li></ul></li><li><p>Module：在一个.rs文件中，可以定义多个module。</p></li><li><p>Path：</p></li></ul><p>​    还有一个概念叫crate root，是.rs源代码文件，编译器从这里开始组成我们的Module文件。</p><p>​    下面是Package的描述：</p><p><img src="/2022/02/14/rust-lang/image-20220116102055982.png" alt="image-20220116102055982"></p><p>​    crate可以把相关的功能整合到一个作用域内，还可以避免命名冲突。</p><p>​    Module是在一个crate内，将代码进行分组，可以复用，并且可以控制代码的权限（pub or pri）。mod还是可以嵌套的。</p><h2 id="7-2-权限"><a href="#7-2-权限" class="headerlink" title="7.2 权限"></a>7.2 权限</h2><p><img src="/2022/02/14/rust-lang/image-20220116103815978.png" alt="image-20220116103815978"></p><p>​    同级可以互相调用，父级不能调用子级的私有，子级可以调用所有父级的，无论暴露与否。外层mod加上了pub，里层的函数没加，函数依然是pri的。所以外面的mod里面的fn都需要加上pub才行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son_1 &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun1</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">mod</span> son_2 &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun2</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtt</span>() &#123;<br>    crate::father::son_1::<span class="hljs-title function_ invoke__">fun1</span>();<br>    crate::father::son_2::<span class="hljs-title function_ invoke__">fun2</span>(); <span class="hljs-comment">//报错，提示函数和mod都是私有的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    访问函数可以通过绝对路径和相对路径。建议绝对路径。</p><ul><li>绝对路径：<code>crate::father::son_1::fun1();</code></li><li>相对路径：<ul><li><code>father::son_1::fun1();</code></li><li>子级在调用父级的函数时，可以通过<code>super关键字</code></li></ul></li></ul><h2 id="7-3-结构的权限"><a href="#7-3-结构的权限" class="headerlink" title="7.3 结构的权限"></a>7.3 结构的权限</h2><p>​    结构默认为pri，并且结构的字段也是pri的，如果像设置乘公有的，加上pub</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>        <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_eat</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;is eating &#123;&#125; at &#123;&#125;.&#123;&#125;.&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.food, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">1</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">2</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">3</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">4</span>);<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtt</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jack</span> = crate::father::eat &#123;<br>        time: (<span class="hljs-number">2022</span>, <span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>),<br>        food: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;kaoji&quot;</span>),<br>    &#125;;<br>    jack.<span class="hljs-title function_ invoke__">to_eat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-枚举的权限"><a href="#7-4-枚举的权限" class="headerlink" title="7.4 枚举的权限"></a>7.4 枚举的权限</h2><p>​    枚举前面加上pub后，其里面的枚举变体自动变成公共的了。</p><h2 id="7-5-use的使用"><a href="#7-5-use的使用" class="headerlink" title="7.5 use的使用"></a>7.5 use的使用</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>​    针对函数，use一般时引用它的上一级mod，而不是直接引入到函数本身，这样增强代码的可读性，避免函数冲突了。</p><p>​    而针对结构struct，enum的话，就是引入到本身，而不是父级条目。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>            <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>            <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cry</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wawawawa&quot;</span>);<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">use</span> crate::father::son;<br><span class="hljs-keyword">use</span> crate::father::son::eat;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtttt</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = eat &#123;<br>        time: (<span class="hljs-number">2020</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>),<br>        food: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sasa&quot;</span>),<br>    &#125;;<br>    son::<span class="hljs-title function_ invoke__">cry</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    对于有同名的数据结构，有以下两种做法：</p><ul><li>像函数一样，引入到父级条目下就停止，不到该数据结构。</li><li>可以使用别名，用as，指定一个别名。</li></ul><p><img src="/2022/02/14/rust-lang/image-20220116121716763.png" alt="image-20220116121716763"></p><p>​    可以看到报错了。</p><p>​    可以写成如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = IoResult::<span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = FmtResult::<span class="hljs-literal">Ok</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h3><p>​    使用use导入mod后，这个mod对内部作用是可见的。而对如果外部去调用这个函数，对这个mod是没有访问权限的。所以这个时候可以使用pub use，这样这个模块对外部也是可见的了。</p><p>​    pub use 意思是重导出。</p><h2 id="7-6-特殊的use使用"><a href="#7-6-特殊的use使用" class="headerlink" title="7.6 特殊的use使用"></a>7.6 特殊的use使用</h2><ul><li>一次引入同一级下的多个包。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult;<br>-------<span class="hljs-punctuation">-&gt;</span><br><span class="hljs-keyword">use</span> std::&#123;<br>    io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult,<br>    fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>用self代表它自身</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span>;<br><span class="hljs-keyword">use</span> std::io;<br>-------<span class="hljs-punctuation">-&gt;</span><br><span class="hljs-keyword">use</span> std::io::&#123;<br>    <span class="hljs-type">Result</span>,<br>    <span class="hljs-keyword">self</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>通过通配符*引入全部的包（不建议经常使用），一般用于 以下情况<ul><li>测试：将所有的公共条目引入测试test模块</li><li>预导入</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::*;<br></code></pre></td></tr></table></figure><h2 id="7-7-引入自己写的mod"><a href="#7-7-引入自己写的mod" class="headerlink" title="7.7 引入自己写的mod"></a>7.7 引入自己写的mod</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my_lib;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_lib::father::son::<span class="hljs-title function_ invoke__">cry</span>(); <span class="hljs-comment">//使用了my_lib.rs下的father模块中的son模块中的一个关联函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    如果mod的嵌套太多，可以创建一个新的同名文件夹，然后里面建立子mod的同名.rs文件。</p><p>​    可以用mod和use一起作用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//main.rs</span><br><span class="hljs-keyword">mod</span> my_lib;<br><span class="hljs-keyword">use</span> my_lib::father::son <span class="hljs-keyword">as</span> son;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    son::<span class="hljs-title function_ invoke__">cry</span>();<br>&#125;<br><br><span class="hljs-comment">//my_lib.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> father;<br><br><span class="hljs-comment">//my_lib\father.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>        <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cry</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wawawawa&quot;</span>);<br>        <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    树形结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">src<br>main.rs<br>my_lib.rs<br>my_lib<br>father.rs<br></code></pre></td></tr></table></figure><h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8 集合"></a>8 集合</h1><p>​    集和是建立在heap上的数据，因此在编译时不需要去确定大小，在运行时会自动变化。</p><h2 id="8-1-Vector"><a href="#8-1-Vector" class="headerlink" title="8.1 Vector"></a>8.1 Vector</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><p>​    有两种方式创建Vector</p><ul><li>通过关联函数，这种情况需要显示的指明类型。</li><li>通过已有的值来创建</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = <span class="hljs-built_in">vec!</span>[String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;first&quot;</span>)];<br>&#125;<br></code></pre></td></tr></table></figure><p>​    rust有上下文推断机制，如果前面没有明确Vec的类型，这时会报错；然后后面添加了元素，又能够自动推断出类型了，报错会消失。</p><h3 id="2-更新"><a href="#2-更新" class="headerlink" title="2.更新"></a>2.更新</h3><p>​    我们使用第一种方式创建Vector，并且向里面添加元素。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1i64</span>); <span class="hljs-comment">//64位有符号</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-清理"><a href="#3-清理" class="headerlink" title="3.清理"></a>3.清理</h3><p>​    一般而言，离开作用域后，Vector就会被OS调用drop给清理掉。</p><h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4.获取"></a>4.获取</h3><p>​    两种方法：</p><ul><li>索引：得到的是数据本身</li><li>get方法：得到的是Some(T)或者None，其中T是不可变引用。</li></ul><p>​    get更安全，可以对得到的数据进行类型判断，如果是Some就取出，是None就不取出，提示错误。</p><p>​    而索引的话，就会出现panic，程序恐慌。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">30i32</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span>: <span class="hljs-type">i32</span> = <span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">10000</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(n) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;get it: &#123;&#125;&quot;</span>, n);<br>            *n<br>        &#125;,<br>        <span class="hljs-literal">None</span> =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>            -<span class="hljs-number">1</span><br>        &#125;,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    因为Vec在heap上，所以有所有权的借用，用get得到的是引用，用索引的到的是本身。但是借用两边并不会报错（i32），<em>说明是存放在栈上的，copy和move都一样</em>。这个地方是错误的，因为i32实现的是copy trait，所以使用等号时会在栈上压栈一个相同的数据。自然不会有所有权的问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">30i32</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n2</span> = v[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">//并没有报错</span><br></code></pre></td></tr></table></figure><p>​    下面修改成String类型的试试。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//cannot move out of index of `std::vec::Vec&lt;std::string::String&gt;`</span><br><span class="hljs-comment">//move occurs because value has type `std::string::String`, which does not implement the `Copy` trait</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    错误信息如上。String没有实现copy trait，而是drop trait，如果操作成功，原来Vec里面对应位置的数据就会失效，所以只能采用借用，也就是用引用来获取。</p><p>​    而get默认的就是得到一个引用，用索引的话需要加上引用符号。</p><p>​    下面我们先通过索引加引用符号得到一个不可变引用，然后再添加一个元素进去，最后再打印这个不可变引用指向的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = &amp;v[<span class="hljs-number">0</span>];<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;   &quot;</span>)); <span class="hljs-comment">//这一行会报错</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, n1);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/14/rust-lang/image-20220116142000246.png" alt="image-20220116142000246"></p><p>​    原因是什么呢？</p><ul><li>不可变引用与可变引用不能同时存在。</li><li>Vec的机制，因为在堆上分配的空间，所以空间可能不足，需要重新分配空间，然后进行一个数据的迁移，最后释放掉原来那部分的空间。如果发生这种情况，上面获取的不可变引用，它的指向是不会改变的，这样就指向了一片空的内存，是不安全的。所以编译器不允许这样的情况发生。</li></ul><p>​    然后再次试了一下使用Vector存放i64，放很多数据。然后发生了栈溢出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/**memory allocation of 8589934592 bytes failed</span><br><span class="hljs-comment"> *error: process didn&#x27;t exit successfully: `target\debug\stdvector.exe` (exit code: 0xc0000409,          *STATUS_STACK_BUFFER_OVERRUN)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1i64</span>);<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2i64</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">1000000000000000000i64</span>) &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, n1);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    换成String也会发生溢出。</p><p>​    然后查阅了相关资料，确定Vec是存放在栈上的。</p><h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5.遍历"></a>5.遍历</h3><p>​    通过for循环遍历，通过解引用*更新。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>        *num = *num + <span class="hljs-number">50</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-enum-amp-vector"><a href="#8-2-enum-amp-vector" class="headerlink" title="8.2 enum &amp; vector"></a>8.2 enum &amp; vector</h2><p>​    存放时直接存放就行，取出时需要根据类型取出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">InputKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>        InputKind::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">32</span>),<br>        InputKind::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">3.22222</span>),<br>        InputKind::<span class="hljs-title function_ invoke__">Text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hhhh&quot;</span>)),<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-String类型"><a href="#8-3-String类型" class="headerlink" title="8.3 String类型"></a>8.3 String类型</h2><h3 id="1-创建字符串"><a href="#1-创建字符串" class="headerlink" title="1.创建字符串"></a>1.创建字符串</h3><p>​    两种方法：</p><ul><li>字符串无初值，使用new关联函数。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure><ul><li><p>字符串有初值：</p><ul><li>使用关联函数from</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hhh&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>使用to_String方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hhh&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(); <span class="hljs-comment">//这里的string是小写</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-更新-1"><a href="#2-更新-1" class="headerlink" title="2.更新"></a>2.更新</h3><p><img src="/2022/02/14/rust-lang/image-20220116152252174.png" alt="image-20220116152252174"></p><h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3.访问"></a>3.访问</h3><p>​    不支持索引访问，只能用切片来访问。</p><p>​    原因有两个：</p><ul><li>UTF8编码，一个Unicode值对应的字节数不是固定的。</li><li>索引操作应该消耗O(1)的时间复杂度，但是String无法保证。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello_world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, p);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-内部表示"><a href="#4-内部表示" class="headerlink" title="4.内部表示"></a>4.内部表示</h3><p>​    String时对Vec<u8>的包装，也就是一个可变字节数组。</u8></p><p>​    有一个len方法返回的是它的字节数。</p><p>​    String有一个大坑，String里面存储的是字节，但是字符都有它的Unicode标量值，一个Unicode值不一定就是一个字节。如下：</p><ul><li>汉字：1 Unicode – 3 Byte</li><li>英语：1 Unicode – 1 Byte</li><li>印度：1 Unicode – 2 Byte</li></ul><p>​    这个时候我们访问，用字符串切割也要看响应的场景了。</p><p>​    Rust里有三种看待字符串的方式（自底向上）：</p><ul><li>字节</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;नमस्ते&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">bytes</span>() &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &quot;</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//224 164 168 224 164 174 224 164 184 224 165 141 224 164 164 224 165 135 </span><br></code></pre></td></tr></table></figure><ul><li>标量值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;हेलो बास्टियन&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &quot;</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//न म स ् त े </span><br><span class="hljs-comment">//第四个和第六个是类似音调的东西，拆分开没有意义</span><br></code></pre></td></tr></table></figure><ul><li>字形簇：标准库里没有提供。</li></ul><h3 id="5-字符串切片的坑"><a href="#5-字符串切片的坑" class="headerlink" title="5.字符串切片的坑"></a>5.字符串切片的坑</h3><p>​    使用[min..max]来进行切片，从[min, max - 1]</p><p>​    如果切割的不是完整的Unicode编码，不会报错，但会发生恐慌</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;नमस्ते&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//thread &#x27;main&#x27; panicked at &#x27;byte index 1 is not a char boundary; it is inside &#x27;न&#x27; (bytes 0..3) of `नमस्ते`&#x27;, src\main.rs:3:14</span><br></code></pre></td></tr></table></figure><h3 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6.遍历"></a>6.遍历</h3><p>​    遍历在内部表示中提及。</p><h2 id="8-4-HashMap"><a href="#8-4-HashMap" class="headerlink" title="8.4 HashMap"></a>8.4 HashMap</h2><h3 id="1-创建及插入"><a href="#1-创建及插入" class="headerlink" title="1.创建及插入"></a>1.创建及插入</h3><ul><li>引入包</li><li>new创建</li><li>insert插入</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    map.<span class="hljs-title function_ invoke__">insert</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;001&quot;</span>), String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcy&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>​    HashMap是同构的，所有的key是一种类型，value也是一种类型</p><p>​    上面是常规的创建方法，还可以使用tuple来创建。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">12u8</span>, <span class="hljs-number">13u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = name.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(age.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    先创建两个Vector，然后用一个vec生成一个迭代器，再跟另外一个vec的迭代器进行一一映射。然后再用collect方法打包返回一个hashmap。</p><p>​    那个&lt;_, _&gt;是会自动推断的，但是不可以省去。</p><p>​    向HashMap中插入数据时，如果数据是实现了copy trait的话，数据会被复制一份。如果是是西安了drop trait的话，数据会被一觉，所有权也会转移，源数据也会失效。</p><p>​    但如果插入的是引用，就不会发生所有权的移交了。</p><p>​    下面是通过get获取map中的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = map.<span class="hljs-title function_ invoke__">get</span>(&amp;name[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(r) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>),<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//打印18</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = map.<span class="hljs-title function_ invoke__">get</span>(&amp;<span class="hljs-string">&quot;hhh&quot;</span>);<br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(r) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>),<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//打印 error</span><br></code></pre></td></tr></table></figure><h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><p>​    使用元组tuple和for-each进行遍历</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (k, v) <span class="hljs-keyword">in</span> map &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, k, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h3><p>​    当向map中插入数据时，可能有三种情况：</p><ul><li><p>数据不存在，直接插入即可。</p></li><li><p>数据存在</p><ul><li>忽略原来的数据v，用新的v替换掉它 – insert()方法就是这样的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcy&quot;</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s, <span class="hljs-number">0u8</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s, <span class="hljs-number">99u8</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, m);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;qcy&quot;: 99&#125;</span><br></code></pre></td></tr></table></figure><ul><li>保留现在的v，忽略新的v – 使用entry来判断是否存在，用or_insert(v)方法来插入，如果k不存在，执行；存在，不执行。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qqcy&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcwdfg&quot;</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s1, <span class="hljs-number">1u8</span>);<br>    m.<span class="hljs-title function_ invoke__">entry</span>(&amp;s2).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">122u8</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, m);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;qqcy&quot;: 1, &quot;qcwdfg&quot;: 122&#125;</span><br></code></pre></td></tr></table></figure><ul><li>合并旧的v和新的v – 还是使用or_insert(v)，来判断，若k存在会返回一个k的可变引用，可以对k进行修改。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span>: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">u32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;h h h h h a a x c v b g r e qw s f gf g h h &quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = text.<span class="hljs-title function_ invoke__">split_whitespace</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> res &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = map.<span class="hljs-title function_ invoke__">entry</span>((*i).<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br>        *num += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, map);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;h&quot;: 7, &quot;b&quot;: 1, &quot;x&quot;: 1, &quot;r&quot;: 1, &quot;e&quot;: 1, &quot;f&quot;: 1, &quot;gf&quot;: 1, &quot;g&quot;: 2, &quot;s&quot;: 1, &quot;c&quot;: 1, &quot;qw&quot;: 1, &quot;v&quot;: 1, &quot;a&quot;: 2&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-Hash函数"><a href="#4-Hash函数" class="headerlink" title="4.Hash函数"></a>4.Hash函数</h3><p>​    一般默认情况下：</p><ul><li>可抵御Dos攻击 – 良好的安全性</li><li>并不是最快的 – 性能一般</li></ul><p>若是觉得性能不好，可以修改trait</p><h1 id="9-错误处理"><a href="#9-错误处理" class="headerlink" title="9.错误处理"></a>9.错误处理</h1><h2 id="1-不可恢复的错误与panic-宏"><a href="#1-不可恢复的错误与panic-宏" class="headerlink" title="1.不可恢复的错误与panic!宏"></a>1.不可恢复的错误与panic!宏</h2><p>​    大多编程语言在错误处理这方面提供了异常机制，没有对可恢复错误与不可恢复错误进行区分，而Rust没有异常机制，但他对错误处理进行了分类：</p><ul><li>可恢复错误：如文件找不到，可再次尝试<ul><li>使用Result&lt;T, E&gt;</li></ul></li><li>不可恢复错误：如Vec越界访问<ul><li>使用panic!宏进行处理</li></ul></li></ul><p>​    针对不可恢复的错误，我们有两种处理，展开或终止（abort）调用栈。</p><ul><li>展开调用栈：Rust沿着调用栈往回走，清理遇到每个函数中的数据。</li><li>终止调用栈：直接终止程序，不进行清理。但是需要由OS来清理。</li></ul><p>​    若想二进制文件更小，需要将默认的展开改成终止。</p><p>​    具体就是在cargo.toml中设置profile。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;paniccccccc&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang/.org/cargo/reference/manifest.html</span><br><br><span class="hljs-section">[dependencies]</span><br><br><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&#x27;abort&#x27;</span><br></code></pre></td></tr></table></figure><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2u8</span>];<br>    v[<span class="hljs-number">999</span>];<br>&#125;<br><span class="hljs-comment">//note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="hljs-comment">//通过set RUST_BACKTRACE=1 &amp;&amp; cargo run 进行栈回溯</span><br></code></pre></td></tr></table></figure><p>​    顺便再次复习一下，v.get(999)并不会报错，得到的返回值是None</p><h2 id="2-Result枚举与可恢复的错误"><a href="#2-Result枚举与可恢复的错误" class="headerlink" title="2.Result枚举与可恢复的错误"></a>2.Result枚举与可恢复的错误</h2><p>​    执行文件操作会返回一个Result的枚举变体，操作成功为Ok(T)，失败为Err(E)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, error);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    下面是针对不同的错误，通过match做的一些处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    fs::File,<br>    io::ErrorKind,<br>&#125;;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>() &#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(msg) =&gt; msg,<br>                <span class="hljs-title function_ invoke__">Err</span>(msg) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, msg),<br>            &#125;,<br>            OtherError =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, OtherError),<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-unwrap与expect替换match"><a href="#3-unwrap与expect替换match" class="headerlink" title="3.unwrap与expect替换match"></a>3.unwrap与expect替换match</h2><p>​    上面我们用了很多match，代码的可读性还行，但太臃肿了。</p><p>​    下面提供一种unwrap()方法。</p><p>​    使用unwrap打开文件</p><ul><li>如果文件不存在，程序恐慌</li><li>如果文件存在，返回文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用unwrap创建文件</p><ul><li>如果文件不存在，创建文件</li><li>如果文件存在，返回文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    但是有一个缺点，unwrap无法定位错误信息（所有unwrap返回的错误信息都是一样的），所以下面介绍expect</p><p>​    expect与unwrap一样，单数可以控制输出的错误信息，精确的定位到处错在哪一行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;出错啦&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-通过函数将错误返回"><a href="#4-通过函数将错误返回" class="headerlink" title="4.通过函数将错误返回"></a>4.通过函数将错误返回</h2><p>​    将函数的返回值设置为一个Result枚举类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123; <span class="hljs-comment">//file必须是可变的，因为会执行读这个操作。</span><br>        <span class="hljs-title function_ invoke__">Ok</span>(f) =&gt; f,<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e) <span class="hljs-comment">//直接作为函数返回值</span><br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">match</span> f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(s),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-语法糖：”-”"><a href="#5-语法糖：”-”" class="headerlink" title="5.语法糖：”?”"></a>5.语法糖：”?”</h2><p>​    ?：执行一个操作</p><ul><li>如果是Ok的话，就把Ok里的值作为结果绑定到变量。</li><li>如果是Err的话，就直接返回错误（注意main函数没有返回值，所以如果要使用”?”的话，需要加东西）。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path)?;<br>    <span class="hljs-comment">// let mut f = match f &#123; //file必须是可变的，因为会执行读这个操作。</span><br>    <span class="hljs-comment">//     Ok(f) =&gt; f,</span><br>    <span class="hljs-comment">//     Err(e) =&gt; return Err(e) //直接作为函数返回值</span><br>    <span class="hljs-comment">// &#125;;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-comment">// match f.read_to_string(&amp;mut s) &#123;</span><br>    <span class="hljs-comment">//     Ok(_) =&gt; Ok(s),</span><br>    <span class="hljs-comment">//     Err(e) =&gt; Err(e),</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    删掉注释后效果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    非常精简。</p><p>​    然后再进行链式调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    File::<span class="hljs-title function_ invoke__">open</span>(path)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-main函数中如何使用”-”运算符"><a href="#6-main函数中如何使用”-”运算符" class="headerlink" title="6.main函数中如何使用”?”运算符"></a>6.main函数中如何使用”?”运算符</h2><p>​    main的返回类型是()，也可以修改为Result，T对应的是()，E对应的是任意可能的错误类型（其实是一个trait对象7.）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-何时使用panic"><a href="#7-何时使用panic" class="headerlink" title="7.何时使用panic!"></a>7.何时使用panic!</h2><p>​    总体原则如下：</p><ul><li>尽量使用Result！将错误返回到代码的调用者，让他们决定如何去处理，如果我们觉得这个错误除了panic!，没有其它的解决办法，就直接使用panic!吧</li></ul><h1 id="10-泛型，trait，生命周期"><a href="#10-泛型，trait，生命周期" class="headerlink" title="10.泛型，trait，生命周期"></a>10.泛型，trait，生命周期</h1><h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h2><p>​    Rust对类型的命名采用的是驼峰命名而非蛇形命名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DogAnimal</span> &#123;<span class="hljs-comment">//...&#125;</span><br></code></pre></td></tr></table></figure><p>​    泛型的声明</p><ul><li>结构</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Good</span>&lt;X, Y&gt; &#123;<br>    name: X,<br>    msg: Y,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hhh</span>&lt;X&gt;() &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>枚举（Option<T> 和 Result&lt;T, E&gt;）</T></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法</li></ul><p>​    注：针对具体的方法，impl后不需要接收泛型。如果是泛型方法，那么就需要</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Good</span>&lt;X, Y&gt; &#123;<br>    name: X,<br>    msg: Y,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;X, Y&gt; Good&lt;X, Y&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name: X, msg: Y) <span class="hljs-punctuation">-&gt;</span> Good&lt;X, Y&gt;&#123;<br>        Good&#123;<br>            name,<br>            msg,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Good</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">speak</span>(<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    使用泛型并不会影响性能。因为Rust使用了<em><strong>单态化</strong></em>，也就是编译的时候会将具体的类型带入到泛型参数里去，从而在运行时不需要额外的开销。</p><h2 id="2-trait"><a href="#2-trait" class="headerlink" title="2.trait"></a>2.trait</h2><ul><li>类似于接口，告诉编译器哪些类型可以具有相同的功能。</li><li>还有一个trait bound的特性：要求传进来的泛型参数必须实现了对应的trait</li></ul><p>​    trait的产生和接口是类似的，有些不同的类型会实现相同的方法。所以我们就把这些方法提取出来，实现一个trait。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​    如下，只有方法签名，无具体实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Behavior</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat</span>(<span class="hljs-keyword">self</span>);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_money</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h3><p>my_lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Man</span> &#123;<br>        <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,<br>        <span class="hljs-keyword">pub</span> age: <span class="hljs-type">i8</span>,<br>        <span class="hljs-keyword">pub</span> money: <span class="hljs-type">i32</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Boy</span> &#123;<br>        <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,<br>        <span class="hljs-keyword">pub</span> age: <span class="hljs-type">i8</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Man</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>            <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;name is &#123;&#125;, age is &#123;&#125;, get money &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age, <span class="hljs-keyword">self</span>.money)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Boy</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>            <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;i am &#123;&#125;, age is &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> fanxingggggg::my_struct::&#123;<br>    Man,<br>    Boy,<br>&#125;;<br><span class="hljs-keyword">use</span> fanxingggggg::my_trait::Text;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Man &#123;<br>        name: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;father&quot;</span>),<br>        age: <span class="hljs-number">40</span>,<br>        money: <span class="hljs-number">100</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Boy &#123;<br>        name: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;boy&quot;</span>),<br>        age: <span class="hljs-number">18</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, m.<span class="hljs-title function_ invoke__">write</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b.<span class="hljs-title function_ invoke__">write</span>());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​    trait也可以使用默认实现，也就是在trait的定义时就实现trait。如果结构对trait的默认实现进行了重写的话，就不能再调用默认实现了。</p><h3 id="3-将trait作为参数"><a href="#3-将trait作为参数" class="headerlink" title="3.将trait作为参数"></a>3.将trait作为参数</h3><ul><li>参数类型为iml trait</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun1</span>(object: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> + Display) &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用trait bound</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;T: Text + Display&gt;(o: T) &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在返回类型后使用where</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;T&gt;(o: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">where</span> T: Text + <span class="hljs-built_in">Clone</span> + Display,<br>    &#123;<br>        String::<span class="hljs-title function_ invoke__">new</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h2><p>​    定义：让引用保持有效的作用域。</p><p>​    Rust有一个东西叫做借用检查器。会在编译的时候比较两个引用的生命周期的长短。</p><h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1.简单使用"></a>1.简单使用</h3><p>​    当你写了一个函数时，向里面传了多个引用，然后对其进行一系列操作，最后返回一个引用时。需要用到生命周期。</p><p>​    因为编译器需要确保传进来的生命周期，与传出去的生命周期一样，或者说大于。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">&quot;hello world!&quot;</span>; <span class="hljs-comment">//5</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sss&quot;</span>); <span class="hljs-comment">//3</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = <span class="hljs-title function_ invoke__">get_longer</span>(&amp;s1, &amp;s2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;res);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_longer</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s1: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, s2: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> s1.<span class="hljs-title function_ invoke__">len</span>() &gt; s2.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        s1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        s2<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    目的检查非法调用。</p><p>​    实际返回结果的生命周期是两个参数中生命周期较小的那一个。</p><p>​    我们看下面这个错误调用。</p><p><img src="/2022/02/14/rust-lang/image-20220119202214447.png" alt="image-20220119202214447"></p><p><img src="/2022/02/14/rust-lang/image-20220119202225682.png" alt="image-20220119202225682"></p><p>​    通过函数，res的生命这些周期被缩短到和s2一样了。这样在外部继续调用的话，就会发生错误。</p><p>​    再试试Java里的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.reptile;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestD</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br>        String res;<br>        &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sss&quot;</span>;<br>            res = s2;<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    res的值和s2是一样的，这意味着s2并没有被GC回收掉。</p><h3 id="2-函数的生命周期"><a href="#2-函数的生命周期" class="headerlink" title="2.函数的生命周期"></a>2.函数的生命周期</h3><p>​    函数的返回值的生命周期跟输入的参数的生命周期有关。</p><p>​    如果要返回一个引用，需要确保这个引用不会被回收（即不是本地变量）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s1: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, s2: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &amp;s <span class="hljs-comment">//报错，returns a reference to data owned by the current function</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    返回的引用指向的堆已经被drop掉了，所以不行。这个引用叫悬垂指针。在Rust里，只要提供了足够的信息（生命周期），就不会发生这种情况。</p><p>​    如果想要使用在函数里的变量，建议返回一个String，移交所有权，而不是返回一个引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(arg: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Config, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> arg.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">3</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;arguments counts not good, find &#123;&#125;, need 2&quot;</span>, arg.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = &amp;arg[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = &amp;arg[<span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">Ok</span>(<br>        Config &#123;<br>            query: p1,<br>            file_path: p2,<br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-struct的生命周期"><a href="#3-struct的生命周期" class="headerlink" title="3.struct的生命周期"></a>3.struct的生命周期</h3><p>​    与函数类似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Man</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    name: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这里生命周期的意思是：字段存活的时间必须比结构久，不然的话字段先被回收了，结构还在，就会发生内存泄漏。</p><p>​    即绑定给name的数据的生命周期的存活时间必须要覆盖这个结构的生命周期。</p><h3 id="4-生命周期省略的规则"><a href="#4-生命周期省略的规则" class="headerlink" title="4.生命周期省略的规则"></a>4.生命周期省略的规则</h3><ul><li>每个引用类型的参数都有自己的生命周期</li><li>如果只有一个输入生命周期参数，那么这个生命周期参数将被赋给输出生命周期参数</li><li>如果有多个输入生命周期参数，但是其中之一是<code>&amp;self or &amp;mut self</code>，那么self的生命周期将被赋给输出生命周期参数。</li></ul><h3 id="5-静态生命周期"><a href="#5-静态生命周期" class="headerlink" title="5.静态生命周期"></a>5.静态生命周期</h3><p>​    静态生命周期用&#96;static，表示，意思是比那辆的存活时间和程序的存活时间是一致的。也就是说编译器在编译的时候就把这一部分作为二进制值写进去了。</p><p>​    只有实现了copy trait的变量才可以声明static</p><h1 id="11-测试"><a href="#11-测试" class="headerlink" title="11.测试"></a>11.测试</h1><p>​    测试三个步骤，3A</p><ul><li><em><strong>准备数据</strong></em> </li><li><em><strong>运行测试代码</strong></em></li><li><em><strong>断言结果</strong></em></li></ul><h2 id="1-编写测试"><a href="#1-编写测试" class="headerlink" title="1.编写测试"></a>1.编写测试</h2><p>​    在函数的上方加上 属性（aattribute）<code>#[test]</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2.运行测试"></a>2.运行测试</h2><p>​    使用cargo test命令</p><h2 id="3-断言的作用"><a href="#3-断言的作用" class="headerlink" title="3.断言的作用"></a>3.断言的作用</h2><h3 id="1-assert"><a href="#1-assert" class="headerlink" title="1.assert!"></a>1.assert!</h3><p>​    断定此处为true！</p><p>​    可以接收一个bool类型，true通过，false则panic</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#[test]</span><br><span class="hljs-function">fn <span class="hljs-title">ppp</span>()</span> &#123;<br>    <span class="hljs-keyword">let</span> f = <span class="hljs-literal">false</span>;<br>    assert!(f);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-assert-eq"><a href="#2-assert-eq" class="headerlink" title="2.assert_eq!"></a>2.assert_eq!</h3><p>​    断定两个同类型的变量相等！</p><p>​    比如下面的assert_eq!，就是表明括号里面传入的参数肯定相等，不然就会报错。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    还可以接收字符串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(result, String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-assert-ne"><a href="#3-assert-ne" class="headerlink" title="3.assert_ne!"></a>3.assert_ne!</h3><p>​    与assert eq相反，ne的意思是not eq</p><h3 id="4-给断言添加自定义消息"><a href="#4-给断言添加自定义消息" class="headerlink" title="4.给断言添加自定义消息"></a>4.给断言添加自定义消息</h3><p>​        其实assert宏还有另外一个参数，可以传递字符串，而事实上这个字符串最终会传递给format宏。所以这个字符串里面可以添加占位符{}，并且后面可以带参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i1</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i2</span> = <span class="hljs-number">12</span>;<br>    <span class="hljs-built_in">assert_eq!</span>(i1, i2, <span class="hljs-string">&quot;&#123;&#125; is not eq &#123;&#125;&quot;</span>, i1, i2);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-属性should-panic"><a href="#4-属性should-panic" class="headerlink" title="4.属性should_panic"></a>4.属性should_panic</h2><p>​    在测试下面，函数上面再添加一条属性（attribute），叫<code>#[should_panic]</code></p><p>​    表示下面的测试函数应该恐慌，不恐慌测试就不会通过。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-meta">#[should_panic]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hello should_panic&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    可以通过在should_panic(expected &#x3D; “”)添加参数，让测试更加精确一点。如添加了字符串参数，然后如果恐慌信息里包含了这个expected参数，那么就测试通过；反之，如果不包含，那么测试失败。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-meta">#[should_panic(expected = <span class="hljs-string">&quot;hello&quot;</span>)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hello should_panic&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-使用Result枚举来进行测试"><a href="#5-使用Result枚举来进行测试" class="headerlink" title="5.使用Result枚举来进行测试"></a>5.使用Result枚举来进行测试</h2><p>​    无需panic。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Err</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;not eq&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="12-命令行项目"><a href="#12-命令行项目" class="headerlink" title="12.命令行项目"></a>12.命令行项目</h1><p>​    实现这样的功能：通过命令行，向程序中输入参数，一个是字符串，一个是文件绝对路径。然后找到这个绝对路径中跟字符串内容匹配的部分，并且打印出来。</p><h2 id="1-接收命令行参数"><a href="#1-接收命令行参数" class="headerlink" title="1.接收命令行参数"></a>1.接收命令行参数</h2><p>​    使用std::env下的args接收参数，并调用collect方法，返回一个Vec</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-comment">// let p1 = &amp;v[0];</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, v);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-读取文件内容"><a href="#2-读取文件内容" class="headerlink" title="2.读取文件内容"></a>2.读取文件内容</h2><p>​    使用std::fs下的read _to_string 来读取，会返回一个result，所以我们调用except来处理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: python</span><br><span class="hljs-comment">path: C:\Users\User\Desktop\Typora快捷键.txt</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = &amp;v[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = &amp;v[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = std::fs::<span class="hljs-title function_ invoke__">read_to_string</span>(path).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, content);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-代码重构"><a href="#3-代码重构" class="headerlink" title="3.代码重构"></a>3.代码重构</h2><p>​    遵循一个函数一个功能的原则，main函数现在太臃肿了。</p><p>​    选择将main.rs拆分成main.rs和lib.rs，将业务逻辑的实现放在libl里。</p><p>​    具体如下：</p><ul><li>在main.rs里编写全部功能，可以忽略重构，忽略错误处理，只考虑理想情况。</li><li>将实现功能的业务逻辑抽取出来，独立成单个的函数。</li><li>在函数中进行错误处理，或者返回一个Result让main去处理。</li><li>最后将抽取出来的函数移动到lib里去</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;env, fs, process&#125;;<br><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> cmdddddd::&#123;Config, run&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: python</span><br><span class="hljs-comment">path: C:\Users\User\Desktop\Typora快捷键.txt</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">config</span> = Config::<span class="hljs-title function_ invoke__">new</span>(&amp;v).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error_msg| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;problem happened: &#123;&#125;&quot;</span>, error_msg);<br>        process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;);<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(&amp;config) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; (),<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;got some problem； &#123;:#?&#125;&quot;</span>, err);<br>            process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(config: &amp;Config) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">query</span> = config.<span class="hljs-title function_ invoke__">query</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = config.<span class="hljs-title function_ invoke__">file_path</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(path)?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,content);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    query: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>    file_path: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Config&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(arg: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Config, <span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> arg.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;arguments counts not good, find &#123;&#125;, need 2&quot;</span>, arg.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = &amp;arg[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = &amp;arg[<span class="hljs-number">2</span>];<br>        <span class="hljs-title function_ invoke__">Ok</span>(<br>            Config &#123;<br>                query: p1,<br>                file_path: p2,<br>            &#125;<br>        )<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">query</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.query<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">file_path</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.file_path<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-使用TDD在lib里进行查错"><a href="#4-使用TDD在lib里进行查错" class="headerlink" title="4.使用TDD在lib里进行查错"></a>4.使用TDD在lib里进行查错</h2><p>​    TDD：test driver development，测试驱动开发</p><p><img src="/2022/02/14/rust-lang/image-20220120223838199.png" alt="image-20220120223838199"></p><p>​    测试部分</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_test</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-string">&quot;\n</span><br><span class="hljs-string">hi,\n</span><br><span class="hljs-string">rust-langn</span><br><span class="hljs-string">demo demo dododododod\n</span><br><span class="hljs-string">hello \n</span><br><span class="hljs-string">hhh\n</span><br><span class="hljs-string">s\n</span><br><span class="hljs-string">hhh\n</span><br><span class="hljs-string">hhh hanpi\n</span><br><span class="hljs-string">en\n&quot;</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">query</span> = <span class="hljs-string">&quot;hhh&quot;</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;demo demo dododododod&quot;</span>], <span class="hljs-title function_ invoke__">search</span>(<span class="hljs-string">&quot;demo&quot;</span>, content));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    被测试的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(query: &amp;<span class="hljs-type">str</span>, content: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lines</span> = content.<span class="hljs-title function_ invoke__">lines</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> lines &#123;<br>        <span class="hljs-keyword">if</span> line.<span class="hljs-title function_ invoke__">contains</span>(query) &#123;<br>            res.<span class="hljs-title function_ invoke__">push</span>(line);<br>        &#125;<br>    &#125;<br>    res<br>&#125;<br></code></pre></td></tr></table></figure><p>​        以后使用TDD来进行测试。测试样例与功能实现分离开。</p><h2 id="5-使用环境变量进行选择"><a href="#5-使用环境变量进行选择" class="headerlink" title="5.使用环境变量进行选择"></a>5.使用环境变量进行选择</h2><p>​    方法如下：</p><p>​    程序中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">flag</span> = std::env::<span class="hljs-title function_ invoke__">var</span>(<span class="hljs-string">&quot;IGNORE_CASE&quot;</span>);<br></code></pre></td></tr></table></figure><p>​    命令行中：IGNORE_CASE &#x3D; 1 cargo run</p><p>​    这样就可以在程序中读到环境变量了。</p><h2 id="6-进行错误信息定向输出"><a href="#6-进行错误信息定向输出" class="headerlink" title="6.进行错误信息定向输出"></a>6.进行错误信息定向输出</h2><p>​    我们可以使用cargo run &gt; output.txt 运行使得通过println!输出的内容定向到output.txt里面。</p><p>​    但是这样错误信息也输出到output里了。</p><p>​    可以使用eprintln!，将错误信息定向到控制台输出。</p><h1 id="13-迭代器-闭包"><a href="#13-迭代器-闭包" class="headerlink" title="13.迭代器 闭包"></a>13.迭代器 闭包</h1><h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h2><h3 id="1-闭包的定义"><a href="#1-闭包的定义" class="headerlink" title="1 闭包的定义"></a>1 闭包的定义</h3><p>​    定义：可以捕获其所在环境的匿名函数。</p><p>​    闭包是一个匿名函数，他是将一个函数的定义存放在一个变量中去，而不是函数的执行结果。这个闭包只有在遇到向里面传输参数的时候，才会去执行函数，得到返回结果。</p><p>​    闭包并不需要显式声明它的参数和返回值类型。因为闭包是在当前作用域内工作的，范围狭小，不是作为接口去调用的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bi_bao</span> = |num| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the num is &#123;&#125;&quot;</span>, num);<br>        num<br>    &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, <span class="hljs-title function_ invoke__">bi_bao</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">//调用bi_bao(3)的时候才是会真正执行闭包</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    将闭包绑定给变量后，变量的类型就是：<code>variable bi_bao: fn(&lt;unknown&gt;) -&gt; &lt;unknown&gt;</code></p><h3 id="2用结构来存储闭包"><a href="#2用结构来存储闭包" class="headerlink" title="2用结构来存储闭包"></a>2用结构来存储闭包</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cashe</span>&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    calculation: T,<br>    value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Cashe&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span><br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> Cashe&lt;T&gt; &#123;<br>        Cashe &#123;<br>            calculation,<br>            value: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, num: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.value &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(n) =&gt; n,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = (<span class="hljs-keyword">self</span>.calculation)(num);<br>                <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(res);<br>                res<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = Cashe::<span class="hljs-title function_ invoke__">new</span>(|num| num + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">32</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">92</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上面结构中的calculation，是一个泛型参数T，并且加上了限制，要求这个泛型参数是实现了Fn trait的一个闭包。</p><p>​    但是只能存储一次。</p><p>​    可以用hashmap来进行改进。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cashe</span>&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    calculation: T,<br>    value: HashMap&lt;<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Cashe&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span><br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> Cashe&lt;T&gt; &#123;<br>        Cashe &#123;<br>            calculation,<br>            value: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, num: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span> = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.value;<br>        <span class="hljs-keyword">match</span> map.<span class="hljs-title function_ invoke__">get</span>(&amp;num) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(res) =&gt; *res,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = (<span class="hljs-keyword">self</span>.calculation)(num);<br>                map.<span class="hljs-title function_ invoke__">insert</span>(num, res);<br>                res<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = Cashe::<span class="hljs-title function_ invoke__">new</span>(|num| num + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">32</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">92</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-使用闭包捕获外部变量"><a href="#3-使用闭包捕获外部变量" class="headerlink" title="3.使用闭包捕获外部变量"></a>3.使用闭包捕获外部变量</h3><p>​    闭包可以捕获和他定义于同一个作用域的变量。这是闭包独有的功能，而函数是没有的。</p><p>​    但是会产生额外的内存开销。</p><h3 id="4-闭包的trait"><a href="#4-闭包的trait" class="headerlink" title="4.闭包的trait"></a>4.闭包的trait</h3><ul><li>Fn            不可变借用</li><li>FnMut    可变借用</li><li>FnOnce   取得所有权</li></ul><p><img src="/2022/02/14/rust-lang/image-20220121151726938.png" alt="image-20220121151726938"></p><p>​    可以使用move关键字将闭包外的所有权强行移动到闭包内。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bb</span> = <span class="hljs-keyword">move</span> ||v; <span class="hljs-comment">//移动所有权</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, v); <span class="hljs-comment">//这一行报错</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2.迭代器"></a>2.迭代器</h2><h3 id="1-iterator-trait"><a href="#1-iterator-trait" class="headerlink" title="1.iterator trait"></a>1.iterator trait</h3><p>​    实现next方法即可。</p><h3 id="2-几个迭代api"><a href="#2-几个迭代api" class="headerlink" title="2.几个迭代api"></a>2.几个迭代api</h3><ul><li>iter：在不可变引用上创建迭代器</li><li>into_iter：创建的迭代器会获取所有权 – 用一个数据引出迭代器，并且夺取了元数据的所有权。</li><li>iter_mut：迭代可变的引用 – 可以通过解引用修改其中的值。</li></ul><h3 id="3-消耗-x2F-产生-迭代器"><a href="#3-消耗-x2F-产生-迭代器" class="headerlink" title="3.消耗&#x2F;产生 迭代器"></a>3.消耗&#x2F;产生 迭代器</h3><h4 id="1-消耗（消耗性适配器）"><a href="#1-消耗（消耗性适配器）" class="headerlink" title="1.消耗（消耗性适配器）"></a>1.消耗（消耗性适配器）</h4><p>​    消耗迭代器：当调用迭代器的next方法时，会消耗迭代器，迭代器中的元素会被一个一个消除掉，这就是叫消耗的原因。rust里有些方法（针对于实现了iterator trait的类型），会自主调用next，从而消耗迭代器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iterator</span> = v.<span class="hljs-title function_ invoke__">iter</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span>: <span class="hljs-type">i32</span> = iterator.<span class="hljs-title function_ invoke__">sum</span>(); <span class="hljs-comment">//sum消耗了迭代器</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/14/rust-lang/image-20220122155108279.png" alt="image-20220122155108279"></p><p>​    要调用sum这个方法，self必须实现Sizd这个trait，并且泛型参数必须实现了Sum这个trait。 </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.Sized trait: 要求这个类型必须有固定的长度，如i32，u32</span><br><span class="hljs-comment">2.Sum trait：可以进行求和</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="2-产生（迭代器适配器）"><a href="#2-产生（迭代器适配器）" class="headerlink" title="2.产生（迭代器适配器）"></a>2.产生（迭代器适配器）</h4><p>​    将一个迭代器转换成另一个迭代器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iter1</span> = v1.<span class="hljs-title function_ invoke__">iter</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span> = iter1.<span class="hljs-title function_ invoke__">map</span>(|num| &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num)<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = map.<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iter2</span> = v2.<span class="hljs-title function_ invoke__">iter</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    map()方法：一个泛型方法，接收两个泛型参数，目的是将传进来的类型T更改成传出去的类型F。接收两个参数，第一个是self，要求实现了Sized这个trait。第二个参数是T，要求实现FnMut这个trait，也就是一个闭包，并且是可变引用，因为要对参数进行修改。</p><p>​    调用map方法后，迭代器的所有权被Move。</p><h4 id="3-迭代器-闭包-捕获环境"><a href="#3-迭代器-闭包-捕获环境" class="headerlink" title="3.迭代器+闭包 捕获环境"></a>3.迭代器+闭包 捕获环境</h4><p>​    使用filter()这个方法，一个迭代器适配器。接收一个闭包，这个闭包必须返回bool类型。若是返回true，则元素被加到迭代器里，最终作为这个方法的返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i1</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|num| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        **num &gt; <span class="hljs-number">90</span><br>    &#125;).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, i1);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    传进闭包后，要用collect进行收集,返回一个集合，不然闭包是不会执行的</p><h4 id="4-构建自定义的迭代器"><a href="#4-构建自定义的迭代器" class="headerlink" title="4.构建自定义的迭代器"></a>4.构建自定义的迭代器</h4><p>​    实现Iterator trait即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">e1</span> = Elem::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e1.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Elem</span> &#123;<br>    val: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Elem</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Elem &#123;<br>        Elem &#123;<br>            val: <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Elem</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">i32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    迭代器比for循环遍历要快一点。</p><p>​    用filter方法。</p><h1 id="14-发布"><a href="#14-发布" class="headerlink" title="14.发布"></a>14.发布</h1><h1 id="15-智能指针"><a href="#15-智能指针" class="headerlink" title="15.智能指针"></a>15.智能指针</h1><h2 id="1-Box-lt-T-gt"><a href="#1-Box-lt-T-gt" class="headerlink" title="1.Box&lt; T &gt;"></a>1.Box&lt; T &gt;</h2><p>​    Rust中所有的类型在编译时都会知道大小。</p><p>​    考虑C语言中的链表的实现，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* next;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    有两个类型，一个是int，一个是指针。这实际就是一个递归，只不过递归的是指针，并不是结构，如果是结构的话，就永远无法知道声明一个struct的时候应该分配多少大小了。所以用的是指针。指针存放在栈上，就是一个地址而已。</p><p>​    rust也是类似的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l</span> = Node &#123;<br>        value: <span class="hljs-number">1</span>,<br>        next: <span class="hljs-title function_ invoke__">Some</span>(Box::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>            value: <span class="hljs-number">2</span>,<br>            next: <span class="hljs-literal">None</span>,<br>        &#125;))<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, l);<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>    next: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    Box这个类型就是一个智能指针，实现了两个trait，deref的目的是确保Box可以被当成一个引用实现；drop则是确保Box在离开作用域时，其指针（栈内存）和指向的数据（堆内存）都会被释放。</p><p><img src="/2022/02/14/rust-lang/image-20220123150617915.png" alt="image-20220123150617915"></p><h2 id="2-deref-trait"><a href="#2-deref-trait" class="headerlink" title="2.deref trait"></a>2.deref trait</h2><h3 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h3><p>​    实现这个trait后，可以确保类型被当成引用来使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Box::<span class="hljs-title function_ invoke__">new</span>(n);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, n);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, *m);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-实现Deref-trait"><a href="#2-实现Deref-trait" class="headerlink" title="2.实现Deref trait"></a>2.实现Deref trait</h3><p>​    给结构实现deref trait即可。</p><p>​    具体的话，就是指定一下类型，然后实现deref方法即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(m, *n);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt;(T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-deref-coercion"><a href="#3-deref-coercion" class="headerlink" title="3.deref coercion"></a>3.deref coercion</h3><p>​    假设实现了deref trait，然后传入的是引用，那么编译器就会自动调用deref方法，将&amp;Box<T> -&gt; &amp;T。</T></p><p>​    如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-title function_ invoke__">fun</span>(&amp;a);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>(s: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    首先将&amp;MyBox<String> -&gt; &amp;String，由于String类型实现了deref trait，所以 &amp;String -&gt; &amp;str，所以参数就匹配了。</String></p><p>​    并且，所有的这些操作，都是在编译期完成的，不会产生额外的运行时性能开销。</p><h2 id="3-drop-trait"><a href="#3-drop-trait" class="headerlink" title="3.drop trait"></a>3.drop trait</h2><p>​    变量在离开作用域时，会自动调用drop方法，来释放相关的资源。</p><p>​    不可以提前调用drop trait的drop方法，但是可以提前释放资源，使用另外一个drop方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-title function_ invoke__">drop</span>(s);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Rc-lt-T-gt"><a href="#4-Rc-lt-T-gt" class="headerlink" title="4.Rc&lt; T &gt;"></a>4.Rc&lt; T &gt;</h2><p>​    引用计数智能指针</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;s1)); <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;s1)); <span class="hljs-comment">//3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    为什么要有Rc<T>？</T></p><p>​    把Box<T>传进去之后，Box会夺取T的所有权，所以如果还想复用T的话，或者是在别的地方传入Box<T>，那么就会报错，因为T已经被移动了。</T></T></p><p>​    使用Rc就不一样了，如果函数接收的是Rc<T>，那么传入Rc::clone(&amp;T)就可以了，这个clone函数并不会深拷贝，只是增加引用计数，返回一个Rc<T>。</T></T></p><p>​    使用了Rc<T>，就相当于单个值有了多个所有者。</T></p><p>​    Rc使用的是不可变引用，如果是可变引用就会违反引用规则。并且，Rc只能在单线程下使用。</p><h2 id="5-RfCell-lt-T-gt"><a href="#5-RfCell-lt-T-gt" class="headerlink" title="5.RfCell&lt; T &gt;"></a>5.RfCell&lt; T &gt;</h2><p><img src="/2022/02/14/rust-lang/image-20220123172820248.png" alt="image-20220123172820248"></p><h1 id="16-并发"><a href="#16-并发" class="headerlink" title="16.并发"></a>16.并发</h1><h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><p>​    创建线程的两种方式：</p><ul><li>通过OS的api来创建 – 运行时小 – 1  : 1</li><li>语言自己实现的线程 – 运行时大 – M : N</li></ul><p>​    Rust提供的是1:1线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread: &#123;&#125;&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;main: &#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这样写，一旦主线程结束了，我们创建的线程也就停止了。可以通过join方法来阻塞主线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread: &#123;&#125;&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;main: &#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br><br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">//只有j的线程结束后，才会恢复主线程的执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    可以使用move将主线程里的值的所有权强制移动到分线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> v &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>        &#125;<br>    &#125;);<br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-通过channel实现线程通信"><a href="#2-通过channel实现线程通信" class="headerlink" title="2.通过channel实现线程通信"></a>2.通过channel实现线程通信</h2><p>​    通过mpsc的一个关联函数可以构造一个元组（send, receive）</p><p>​    mpsc的意思：多个生产者，一个消费者。multiple producer， single consumer</p><p>​    可以通过克隆来实现多个发送者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (send, receive) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">send1</span> = send.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ss</span> = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> ss &#123;<br>            send.<span class="hljs-title function_ invoke__">send</span>(s).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ss</span> = [<span class="hljs-string">&quot;111hello&quot;</span>, <span class="hljs-string">&quot;111world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot;111from&quot;</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> ss &#123;<br>            send1.<span class="hljs-title function_ invoke__">send</span>(s).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">r</span> <span class="hljs-keyword">in</span> receive &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r);<br>    &#125;<br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    j1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Mutex-lt-T-gt-共享内存"><a href="#3-Mutex-lt-T-gt-共享内存" class="headerlink" title="3.Mutex&lt; T &gt;共享内存"></a>3.Mutex&lt; T &gt;共享内存</h2><p>​        Mutex就是一个互斥锁，使用数据前需要先获取锁，然后使用完后需要释放锁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;mpsc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = n.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num = <span class="hljs-number">7</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="hljs-comment">//n从5到7</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    mutex可能会产生死锁</p><h2 id="4-Arc-lt-T-gt-原子引用计数"><a href="#4-Arc-lt-T-gt-原子引用计数" class="headerlink" title="4.Arc&lt; T &gt;原子引用计数"></a>4.Arc&lt; T &gt;原子引用计数</h2><p>​    在外面克隆引用，然后把克隆的引用传进去。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, mpsc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l1</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;n);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = l1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num += <span class="hljs-number">999</span>;<br>    &#125;);<br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="hljs-comment">//1004</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ceshi:</p><p><img src="/2022/02/14/rust-lang/image-20220214142148258.png" alt="image-20220214142148258"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-自顶向下</title>
    <link href="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <url>/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1 应用层"></a>1 应用层</h1><h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h2><h3 id="C-S："><a href="#C-S：" class="headerlink" title="C/S："></a><code>C/S</code>：</h3><p>不对等架构</p><ul><li>拓展性：差，要解决高并发，网络问题</li><li>可靠性：过度依赖服务器</li></ul><h3 id="P2P："><a href="#P2P：" class="headerlink" title="P2P："></a><code>P2P</code>：</h3><p>对等架构</p><ul><li>管理困难：结点上线，下线不稳定</li></ul><h3 id="混合："><a href="#混合：" class="headerlink" title="混合："></a><code>混合</code>：</h3><p>既有一个大服务器，同时又有每个节点，结点可以作为小服务器或者客户端</p><ul><li>服务器：管理所有上线用户<code>ip</code>，分发给结点。</li><li>结点：向服务器请求目标<code>ip</code>，选择跟这个<code>ip</code>连接，同时向服务器注册自己的<code>ip</code></li></ul><p>混合架构就是<code>C/S</code>里面套接<code>P2P</code>，既有两者的优点，也将缺点小化了。</p><h2 id="1-2-通信"><a href="#1-2-通信" class="headerlink" title="1.2 通信"></a>1.2 通信</h2><ul><li><p>不同端系统之间的网络进程，依靠网络通信，遵守相关协议。</p><p>任何一个用进程可以用端结点来标识，有一个<code>SAP</code>标识：</p><ul><li>主机<code>IP</code></li><li><code>TCP/UDP</code></li><li><code>port</code></li></ul><p>层间接口（稍底层），必须携带的信息：</p><ul><li>传输报文<code>SDU</code></li><li>发送者：<code>IP+TCP/UDP+port</code></li><li>接收者：<code>IP+TCP/UDP+port</code></li></ul><p><code>TCP Socket</code>：源IP+源Port+目标IP+目标Port。四元组。</p><p>发送：</p><ul><li>TCP Socket+报文</li></ul><p><code>UDP Socket</code>：源IP+源Port。二元组</p><p>发送：</p><ul><li>UDP Socket+报文+(目标IP+目标Port)</li></ul></li><li><p>同一端系统进程间通信，通过操作系统的：管道，消息队列，缓冲区等</p></li></ul><p>协议：应用进程之间通信的约束（语法，语义，规则），只跟网络相关。</p><p>应用实体：在某一层，和网络交互有关的，遵守协议的部分，叫做这一层的实体。在这个过程中需要实现协议的一些操作，是非实体。</p><p>应用层需要传输层提供什么样的服务：</p><ul><li>数据丢失率</li><li>延迟</li><li>吞吐</li><li>安全性<ul><li>机密性</li><li>完整性</li><li>可认证性</li></ul></li></ul><h2 id="1-3-HTTP"><a href="#1-3-HTTP" class="headerlink" title="1.3 HTTP"></a>1.3 <code>HTTP</code></h2><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><ul><li><p>web页：本身是对象，里面又嵌入了一些对象（的链接）</p></li><li><p>URL：统一资源定位器</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">Port:<span class="hljs-regexp">//u</span>ser:psw@www.xxx.edu<span class="hljs-regexp">/path/</span>pic.gif:port<br>协议名 用户 口令 主机名 路径 文件 端口<br></code></pre></td></tr></table></figure></li><li><p>匿名访问：不需要口令</p></li><li><p>HTTP默认端口：80</p></li><li><p>FTP默认端口：21</p></li></ul><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><ul><li><p>跑在TCP上</p></li><li><p>服务器客户端连接过程</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.服务器有一个守候socket（<span class="hljs-keyword">waiting </span>socket）<span class="hljs-built_in">s1</span>，在服务器xxxip的<span class="hljs-number">80</span>端口，等待连接建立请求<br><span class="hljs-number">2</span>.web向服务器发送TCP请求，要求建立连接<br><span class="hljs-number">3</span>.服务器响应，允许建立连接，并返回一个socket <span class="hljs-built_in">s2</span>，代表web与server的会话关系<br><span class="hljs-number">4</span>.s1，<span class="hljs-built_in">s2</span>，<span class="hljs-built_in">s3</span>都守护在对应的<span class="hljs-number">80</span>端口，但<span class="hljs-built_in">s1</span>是守候socket，<span class="hljs-built_in">s2</span>，<span class="hljs-built_in">s3</span>是连接socket<br></code></pre></td></tr></table></figure></li></ul><h3 id="非持久HTTP（1-0）"><a href="#非持久HTTP（1-0）" class="headerlink" title="非持久HTTP（1.0）"></a>非持久HTTP（1.0）</h3><ul><li>TCP连接–TCP确认</li><li>HTTP请求–HTTP确认（返回对象，时间较长）</li><li>TCP关闭–关闭</li></ul><h3 id="持久HTTP（1-1）"><a href="#持久HTTP（1-1）" class="headerlink" title="持久HTTP（1.1）"></a>持久HTTP（1.1）</h3><ul><li>TCP请求–TCP确认</li><li>HTTP请求–HTTP确认（返回对象）</li><li>–等待，不关闭</li></ul><h3 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a>响应时间模型</h3><p>请求确认RTT：一次往返加小分组传输时间，因为分组字节数较小，所以通常忽略，只计算往返时间</p><h4 id="非持久HTTP"><a href="#非持久HTTP" class="headerlink" title="非持久HTTP"></a>非持久HTTP</h4><ul><li>TCP的RTT</li><li>HTTP的RTT</li><li>文件传输时间</li><li>总时间：2RTT+文件传输时间</li></ul><p>在非持久HTTP中，一个对象的时间：2RTT+文件传输时间</p><h4 id="持久HTTP"><a href="#持久HTTP" class="headerlink" title="持久HTTP"></a>持久HTTP</h4><h5 id="非流水线HTTP（同步-串行）"><a href="#非流水线HTTP（同步-串行）" class="headerlink" title="非流水线HTTP（同步,串行）"></a>非流水线HTTP（同步,串行）</h5><ul><li>TCP</li><li>HTTP</li><li>文件1</li><li>文件2</li></ul><h5 id="流水线HTTP（异步，并行）"><a href="#流水线HTTP（异步，并行）" class="headerlink" title="流水线HTTP（异步，并行）"></a>流水线HTTP（异步，并行）</h5><ul><li>TCP</li><li>HTTP</li><li>文件1+文件2+…</li></ul><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><ul><li>两种报文：请求+响应</li><li>ANCII码，人能阅读</li><li>GET：server向服务器请求</li><li>POST：上载</li><li>HEAD：只要HTML的head，搜索引擎建立索引或者维护</li></ul><h3 id="HTTP状态码："><a href="#HTTP状态码：" class="headerlink" title="HTTP状态码："></a>HTTP状态码：</h3><p>​    常用：</p><ul><li>200：ok</li><li>301：资源已被转移</li><li>404：页面不存在</li><li>500：内部服务器错误</li></ul><p>​    全部：</p><table><thead><tr><th>100</th><th>Continue</th><th>继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</th></tr></thead><tbody><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h3 id="cookie，有状态的HTTP"><a href="#cookie，有状态的HTTP" class="headerlink" title="cookie，有状态的HTTP"></a>cookie，有状态的HTTP</h3><ul><li>client第一次访问server，HTTP报文中不携带cookie</li><li>server给client分配cookie，保存到数据库，并在响应报文中返回cookie</li><li>client接收到cookie，存入本地操作系统。</li><li>client后续访问。请求报文中会携带本地的cookie</li><li>server将接收到的cookie与数据库中的cookie对比，得到用户历史</li></ul><h3 id="web缓存（代理服务器）"><a href="#web缓存（代理服务器）" class="headerlink" title="web缓存（代理服务器）"></a>web缓存（代理服务器）</h3><ul><li>c向s发出HTTP请求，首先到代理服务器。</li><li>代理服务器检查，没有发现对象，发送给origin server</li><li>origin server给出响应，返回给代理，代理将对象保存</li><li>代理返回对象给c</li><li>c第二次向s请求相同的对象，经过代理服务器。</li><li>代理服务器保有此对象，该对象被命中，代理返回对象给c</li></ul><p>优点：</p><p>​    1.客户端快，请求响应时间短</p><p>​    2.服务器端压力小，负载轻</p><p>​    3.减小网络拥堵</p><p>二八原则</p><p>​    很小的缓存，但可以满足很多用户访问。</p><h2 id="1-4-FTP"><a href="#1-4-FTP" class="headerlink" title="1.4 FTP"></a>1.4 <code>FTP</code></h2><ul><li>c与s使用tcp，与21号端口建立连接</li><li>c通过控制连接来获得身份确认</li><li>c通过控制连接连续发送命令浏览目录</li><li>收到文件传输命令时，s与c的20号端口进行数据连接（另外一个TCP连接）</li><li>文件传输结束，s关闭连接</li></ul><p>控制连接21端口：发送命令</p><p>数据连接20端口：传输数据</p><h2 id="1-5-Email"><a href="#1-5-Email" class="headerlink" title="1.5 Email"></a>1.5 <code>Email</code></h2><p>发送协议（push）：SMTP</p><p>接收协议（pop）：HTTP，pop3，IMAP</p><p>跑在TCP上</p><ul><li>用户代理：outlook，qqmail，发送给邮件服务器（SMTP）</li><li>邮件服务器：运行在25号端口</li><li>邮件服务器将接收的邮件放进队列里</li><li>邮件服务器将邮件发送给其它邮件服务器，放在用户的邮箱里</li><li>目标用户，使用用户代理将邮件从对应的邮件服务器的邮箱中取出来（pop3协议，HTTP，IMAP，60端口）</li></ul><h2 id="1-6-DNS"><a href="#1-6-DNS" class="headerlink" title="1.6 DNS"></a>1.6 <code>DNS</code></h2><p>域名解析系统：DNS是给其它应用应用的应用</p><p>其它应用访问web，通过DNS这个基础设施，来成功访问到server。</p><p>用户输入域名，DNS完成域名到ip地址的转换。</p><p>分布式解析，区域DNS</p><h3 id="DNS的问题："><a href="#DNS的问题：" class="headerlink" title="DNS的问题："></a>DNS的问题：</h3><ul><li>如何命名设备</li><li>如何完成域名到ip地址的转化</li><li>如何维护：增加域名&#x2F;子域名，删除…</li></ul><h3 id="DNS的思路："><a href="#DNS的思路：" class="headerlink" title="DNS的思路："></a>DNS的思路：</h3><ul><li>分层的命名</li><li>分布式的数据库</li><li>UDP的53号端口</li><li>是web的核心功能，但不在核心实现，在边缘实现。由此可见web最复杂的其实是边缘。</li></ul><h3 id="DNS的功能："><a href="#DNS的功能：" class="headerlink" title="DNS的功能："></a>DNS的功能：</h3><ul><li>主机名到IP的转换</li><li><ul><li>主机别名到规范名字的转换</li><li>邮件服务器别名到邮件服务器正规名字的转换</li><li>负载均衡（多个子服务器提供服务），分治的思想。</li></ul></li></ul><h3 id="DNS命名空间："><a href="#DNS命名空间：" class="headerlink" title="DNS命名空间："></a>DNS命名空间：</h3><ul><li><ul><li>国家：.cn    .us    .jp（国家的顶级域）</li><li>通用：.com（很多公司的顶级域）  .edu  .gov</li></ul></li><li>二级域</li><li>三级域</li><li>…</li></ul><p>DNS命名就是一个很多个个倒着生长的树，树根是顶级域，顶级域分为国家的和通用的。</p><h3 id="DNS根名字服务器："><a href="#DNS根名字服务器：" class="headerlink" title="DNS根名字服务器："></a>DNS根名字服务器：</h3><p>13个名字服务器。查询的时候选择任何一个树根开始往下查阅，这样更稳定。</p><h2 id="1-7-P2P"><a href="#1-7-P2P" class="headerlink" title="1.7 P2P"></a>1.7 <code>P2P</code></h2><h2 id="1-8-CDN"><a href="#1-8-CDN" class="headerlink" title="1.8 CDN"></a>1.8 <code>CDN</code></h2><h2 id="1-9-TCP"><a href="#1-9-TCP" class="headerlink" title="1.9 TCP"></a>1.9 <code>TCP</code></h2><p>可靠数据传输。</p><ul><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：网络拥堵时抑制发送方</li><li>不能提供的服务：时间保证，最小吞吐保证，安全性</li><li>面向连接：要求C&#x2F;S建立连接</li></ul><h2 id="1-10-UDP"><a href="#1-10-UDP" class="headerlink" title="1.10 UDP"></a>1.10 <code>UDP</code></h2><p>不可靠数据传输。</p><ul><li>不提供的服务：可靠，流量控制，拥塞控制，时间，带宽保证，建立连接</li><li>优点：简单，延时低</li></ul><h2 id="1-11-SSL"><a href="#1-11-SSL" class="headerlink" title="1.11 SSL"></a>1.11 <code>SSL</code></h2><p>TCP&#x2F;UDP都没有加密，都是明文传输。</p><p>SSL建立在TCP上，提供加密的TCP连接</p><p>SSL在应用层。</p><ul><li>私密性</li><li>数据完整性</li><li>端到端的鉴别（认证）</li></ul><p><code>https</code>开头的网站是跑在SSL协议上，再往下是TCP，是安全的</p><p><code>http</code>则跑在TCP上，明文传输，不安全</p><h1 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2.传输层"></a>2.传输层</h1><h2 id="2-1-多路复用解复用"><a href="#2-1-多路复用解复用" class="headerlink" title="2.1 多路复用解复用"></a>2.1 多路复用解复用</h2><p>​    传输层向应用层提供服务；网络层向传输层提供服务。传输层和应用层是进程–进程（或是线程）通信。网络层则是端系统–端系统通信。</p><p>​    多个应用程序把socket+报文（+目标&lt;ip,port&gt;二元组）向下交给传输层。传输层在报文前面加上源port，目标port的段，形成传输层的TCP字节流或者是UDP数据报。传输层再向下交给ip层，ip层在报文前面加上源ip，目标ip，形成ip数据报。再统一向下交，将多个ip数据报发出。–复用</p><p>​    经过网络核心到接收端，再依次向上交。一方面丢掉头部的ip，port信息，得到message；另一方面根据ip，port找到对应的进程。–解复用</p><h2 id="2-2-UDP"><a href="#2-2-UDP" class="headerlink" title="2.2 UDP"></a>2.2 UDP</h2><p>​    UDP是不可靠传输，但它在ip的基础上，优化了：进程–进程；差错检验功能。</p><p>​    差错检验，注意溢出回卷还有取反码部分。</p><h2 id="2-3-RDT"><a href="#2-3-RDT" class="headerlink" title="2.3 RDT"></a>2.3 RDT</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>计网</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-性能指标"><a href="#1-性能指标" class="headerlink" title="1.性能指标"></a>1.性能指标</h2><ul><li>速率</li><li>带宽</li><li>吞吐量</li><li>时延<ul><li>传输时延 &#x2F; 发送时延</li><li>传播时延</li><li>排队时延</li><li>处理时延</li></ul></li><li>时延带宽积</li><li>往返时间RTT</li><li>利用率<ul><li>信道利用率</li><li>网络利用率</li></ul></li></ul><h2 id="2-分层结构的元素"><a href="#2-分层结构的元素" class="headerlink" title="2.分层结构的元素"></a>2.分层结构的元素</h2><ol><li><p>实体：某一层的活动元素，同一层的实体叫对等实体</p></li><li><p>协议：对等实体间进行数据交换制定的规则，包括：</p><ul><li>语法</li><li>语义</li><li>时序 &#x2F; 同步</li></ul></li><li><p>接口：层层之间还有一层接口，是上层使用下层服务的入口</p></li><li><p>服务：下层中某些功能提供给上层调用</p></li><li><p>PCI + SDU &#x3D; PDU</p><ul><li>PCI： 协议控制信息</li><li>SDU：服务数据单元</li><li>PDU：协议数据单元（最终层间传输的单元）</li></ul><p>以n层为例，n层接受到n + 1传下来的PDU，作为本层的SDU，然后n层进行打包，加上协议信息PCI，打包为PDU，发给n - 1层作为它的SDU</p></li></ol><h2 id="3-OSI"><a href="#3-OSI" class="headerlink" title="3.OSI"></a>3.OSI</h2><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220128161115359.png" alt="image-20220128161115359"></p><ul><li><p>应用层：用户的页面</p></li><li><p>表示层：数据格式的转换，数据加密，数据的压缩及恢复</p></li><li><p>会话层：</p><ul><li>实体间建立连接及有序传输数据</li><li>使用校验点，在通信失效的时候从校验点重新开始</li></ul></li><li><p>传输层</p><ul><li>可靠 &#x2F; 不可靠传输</li><li>差错控制</li><li>流量控制</li><li>复用<ul><li>多个应用层进程可同时使用传输层的服务 – 复用</li><li>传输层会接收到所有进程的消息，然后分别发给对应的进程 – 分用</li></ul></li></ul></li><li><p>网络层：数据包 &#x2F; 分组</p><ul><li>路由选择</li><li>流量控制</li><li>拥塞控制</li><li>差错控制</li></ul></li><li><p>数据链路层：数据帧</p><ul><li>封装数据帧</li><li>差错控制：位错 &#x2F; 帧错</li><li>流量控制</li><li>接入控制：控制对信道的访问</li></ul></li><li><p>物理层：比特流，透明传输：无论收到什么样的数据帧，都能作为比特流，然后转化成电信号在介质中传播</p><ul><li>定义接口特性：比如接口有多少根引脚</li><li>定义传输模式：单工，半双工，双工</li><li>定义传输速率</li><li>比特同步</li><li>比特编码：曼彻斯特编码等等</li></ul></li></ul><p>​    上四层是e2e通信（进程），下三层是p2p通信（结点）</p><h2 id="4-TCP-x2F-IP-模型"><a href="#4-TCP-x2F-IP-模型" class="headerlink" title="4.TCP &#x2F; IP 模型"></a>4.TCP &#x2F; IP 模型</h2><ul><li>应用层</li><li>传输层</li><li>网际层</li><li>网络接口层</li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220130095908613.png" alt="image-20220130095908613"></p><h2 id="5-5层参考模型"><a href="#5-5层参考模型" class="headerlink" title="5.5层参考模型"></a>5.5层参考模型</h2><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220130100154087.png" alt="image-20220130100154087"></p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220130100308960.png" alt="image-20220130100308960"></p><h1 id="2-物理层（傻瓜层）"><a href="#2-物理层（傻瓜层）" class="headerlink" title="2.物理层（傻瓜层）"></a>2.物理层（傻瓜层）</h1><p>​    了解上层基础和下层建筑。</p><p>​    物理层主要是确定传输介质接口的标准，而不是定义传输介质。</p><p>​    有人将传输介质称作第零层，也有道理。</p><h2 id="1-通信分类"><a href="#1-通信分类" class="headerlink" title="1.通信分类"></a>1.通信分类</h2><p>​    通信模型：信源 – 调制解调器（发送，调制） – 信道 – 调制解调器（接收，解调） – 信宿</p><h3 id="1-通信方式"><a href="#1-通信方式" class="headerlink" title="1.通信方式"></a>1.通信方式</h3><ul><li>单工 – 广播</li><li>半双工 – 对讲机</li><li>双工 – 电话</li></ul><p>​    明确的是，信道是有方向的，可以看作是矢量。</p><h3 id="2-传输方式"><a href="#2-传输方式" class="headerlink" title="2.传输方式"></a>2.传输方式</h3><ul><li>串行传输：一条信道，一个byte的8个bit由低到高依次发送<ul><li>特性：速度低，费用低，适合远距离</li></ul></li><li>并行传输：八条信道，每个信道传输一位<ul><li>特性：速度高，费用高，适合近距离</li><li>例子：计算机内部部件的信息传输</li></ul></li></ul><h3 id="3-同步方式"><a href="#3-同步方式" class="headerlink" title="3.同步方式"></a>3.同步方式</h3><ul><li>同步：同步传输时，数据是以数据区块作为一个整体发送的，数据区块前面要加上同步字符SYN，作为收发端之间的同步时钟。</li><li>异步：将数据比特分为几个比特组，然后发送方会在传送数据之前给比特组加上起始位和终止位，发送端可以在任意时刻发送数据。</li></ul><p>​    同步和异步最终都是为了对收发的数据进行同步，最终得到完整不失真的数据。</p><p>​    同步的话，收发必须进行严格的校准，当接收方没接收到时，发送方不能继续发。而异步，发送方直接发就行了，不用关心接收方接收到没有。</p><p>​    类似于QQ的在线传文件和发送离线文件</p><h2 id="2-数字通信性能指标"><a href="#2-数字通信性能指标" class="headerlink" title="2.数字通信性能指标"></a>2.数字通信性能指标</h2><h3 id="1-码元"><a href="#1-码元" class="headerlink" title="1.码元"></a>1.码元</h3><p>​    一个码元可以携带多个比特信息。</p><p>​    码元是通过一定固定时长的信号波形来代表不同离散数值（0 &#x2F; 1）的基本波形。</p><p>​    二进制码元可以携带 0 &#x2F; 1，所以可以携带一个bit。</p><p>​    四进制码元，可以携带四个状态，00 &#x2F; 01 &#x2F; 10 &#x2F; 11，所以可以携带2bits</p><p>​    16进制码元，携带4bits</p><p>​    M进制码元，可以携带log2M个bits</p><h3 id="2-码元速率"><a href="#2-码元速率" class="headerlink" title="2.码元速率"></a>2.码元速率</h3><p>​    单位时间发送码元个数，单位是bote，Baud，B</p><h3 id="3-信息速率"><a href="#3-信息速率" class="headerlink" title="3.信息速率"></a>3.信息速率</h3><p>​    别名比特速率，比特率，表示单位时间传输的二进制码元的个数，单位bit&#x2F;s</p><h3 id="4-带宽"><a href="#4-带宽" class="headerlink" title="4.带宽"></a>4.带宽</h3><p>​    模拟带宽：高频与低频之间的差值，界限是功率为最大功率的一半</p><p>​    数字带宽：一点到另一点能通过的最高数据率，单位bps，b &#x2F; s</p><h2 id="3-奈氏准则-amp-amp-香农定理"><a href="#3-奈氏准则-amp-amp-香农定理" class="headerlink" title="3.奈氏准则 &amp;&amp; 香农定理"></a>3.奈氏准则 &amp;&amp; 香农定理</h2><p>​    信噪比：信噪比（db） &#x3D; 10log10（S&#x2F;N），S是信道平均功率，N是信道内噪声功率</p><ul><li>奈：理想低通情况下（无噪声），为避免码间串扰，码元极限传输速率是2W baud，W是信道带宽，单位hz</li><li>香：带宽受限且有噪声情况下，信息速率有上限，值为：Wlog2（1 + S&#x2F;N）</li></ul><p>​    奈奎斯特是在理想情况，无噪声的时候使用。香农则是在有噪声的时候使用。</p><h2 id="4-编码-amp-amp-调制"><a href="#4-编码-amp-amp-调制" class="headerlink" title="4.编码 &amp;&amp; 调制"></a>4.编码 &amp;&amp; 调制</h2><p>​    基带信号 &amp; 宽带信号</p><p>​    基带信号是直接将0101这种原始数字信号进行传输，传输信道是数字信道。</p><p>​    宽带信号是将基带信号进行调制后，再频分复用的信号，传输信道是模拟信道。</p><p>​    距离较近时使用基带信号传输，这样衰减小；距离较远的时候，就是使用宽带信号传输。</p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131173207400.png" alt="image-20220131173207400"></p><h3 id="1-数字数据-–-数字信号"><a href="#1-数字数据-–-数字信号" class="headerlink" title="1.数字数据 – 数字信号"></a>1.数字数据 – 数字信号</h3><ul><li><p>非归零编码（NRZ）：高1低0</p><ul><li>缺点：无开始结束，接收方无法判断，所以不好同步</li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131173650920.png" alt="image-20220131173650920"></p></li><li><p>归零编码（RZ）：在一个码元内需要归零。</p><ul><li>缺点：信道利用率低，0太多了，并且同步没解决</li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131173830468.png" alt="image-20220131173830468"></p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131173843015.png" alt="image-20220131173843015"></p></li><li><p>反向不归零编码（NRZI）：电平反转0，反之1</p><ul><li>缺点：数据全1的话，无法判断</li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131174255181.png" alt="image-20220131174255181"></p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131174302733.png" alt="image-20220131174302733"></p></li><li><p>曼彻斯特编码：将码元分成两部分，前高后低表示1，前低后高表示0，也可以反过来。</p><ul><li>缺点：数据传输速度是调制速率的二分之一</li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131174849899.png" alt="image-20220131174849899"></p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131174858911.png" alt="image-20220131174858911"></p></li><li><p>差分曼彻斯特编码：若码元为1，则前半个码元脉冲，与前一个码元的后半脉冲相同。反之相反</p><ul><li>优点：抗干扰能力优于曼彻斯特编码。</li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131180434222.png" alt="image-20220131180434222"></p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131180441467.png" alt="image-20220131180441467"></p></li><li><p>4B &#x2F; 5B编码：编码效率百分之80</p></li></ul><h3 id="2-数字数据-–-模拟信号"><a href="#2-数字数据-–-模拟信号" class="headerlink" title="2.数字数据 – 模拟信号"></a>2.数字数据 – 模拟信号</h3><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131182344549.png" alt="image-20220131182344549"></p><h3 id="3-模拟信号–-数字信号"><a href="#3-模拟信号–-数字信号" class="headerlink" title="3.模拟信号– 数字信号"></a>3.模拟信号– 数字信号</h3><p>​    采样 – 量化 – 编码</p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131183011631.png" alt="image-20220131183011631"></p><h3 id="4-模拟数据-–-模拟信号"><a href="#4-模拟数据-–-模拟信号" class="headerlink" title="4.模拟数据 – 模拟信号"></a>4.模拟数据 – 模拟信号</h3><p>​    低频 – 高频，采用频分复用</p><h2 id="5-数据交换方式"><a href="#5-数据交换方式" class="headerlink" title="5.数据交换方式"></a>5.数据交换方式</h2><p>​    局域网交换机，广域网路由器。</p><p>​    <img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131184129161.png" alt="image-20220131184129161"></p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131184329262.png" alt="image-20220131184329262"></p><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h3><p>​    用一条物理线路直接连接俩条通信设备，线路占有率为100%，连接始终open</p><p>​    具体步骤：建立连接（呼叫） – 通信 – 释放电路（拆除）</p><p>​    通信是全双工的</p><p>​    适用于大量的数据传输</p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131184915419.png" alt="image-20220131184915419"></p><h3 id="2-报文交换"><a href="#2-报文交换" class="headerlink" title="2.报文交换"></a>2.报文交换</h3><p>​    不需要在两个结点之间专门建立一条线路，单位是报文，采用的方式是：存储转发</p><ul><li>优点：存储转发，不独占资源，存储后交换设备会对报文进行检查查看是否出错</li><li>缺点：共享带宽</li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131185918907.png" alt="image-20220131185918907"></p><h3 id="3-分组交换"><a href="#3-分组交换" class="headerlink" title="3.分组交换"></a>3.分组交换</h3><p>​    与报文交换略有不同，传输单位是分组。源节点把数据发送过来后，交换设备会将数据切分成一个个的小分组。</p><p>​    一般每个分组的大小是128B</p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131190505122.png" alt="image-20220131190505122"></p><h4 id="1-数据包交换"><a href="#1-数据包交换" class="headerlink" title="1.数据包交换"></a>1.数据包交换</h4><h4 id="2-虚电路交换"><a href="#2-虚电路交换" class="headerlink" title="2.虚电路交换"></a>2.虚电路交换</h4><h3 id="4-如何选择"><a href="#4-如何选择" class="headerlink" title="4.如何选择"></a>4.如何选择</h3><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131190720267.png" alt="image-20220131190720267"></p><h2 id="6-物理层传输媒介"><a href="#6-物理层传输媒介" class="headerlink" title="6.物理层传输媒介"></a>6.物理层传输媒介</h2><ul><li><p>导向性传输介质 – 电磁波沿着固体介质传播</p><ul><li><p>双绞线 – 便宜</p></li><li><p>同轴电缆 – 优于双绞线</p></li><li><p>光纤 – 带宽大，损耗低，传输距离远</p><ul><li>单模光纤 – 远距离</li><li>多模光纤 – 近距离</li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131194222033.png" alt="image-20220131194222033"></p></li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131194712214.png" alt="image-20220131194712214"></p></li><li><p>非导向性传输介质 – 空气，真空，海水等</p><ul><li>无线电波：所有方向</li><li>微波：单一方向</li><li>红外线，单一方向</li></ul></li></ul><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131195135629.png" alt="image-20220131195135629"></p><h2 id="7-物理层设备"><a href="#7-物理层设备" class="headerlink" title="7.物理层设备"></a>7.物理层设备</h2><h3 id="1-中继器"><a href="#1-中继器" class="headerlink" title="1.中继器"></a>1.中继器</h3><p>​    对中途损耗的信号进行再生和还原，对衰减的信号进行放大</p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131202431114.png" alt="image-20220131202431114"></p><h3 id="2-集线器（多口中继器）"><a href="#2-集线器（多口中继器）" class="headerlink" title="2.集线器（多口中继器）"></a>2.集线器（多口中继器）</h3><p>​    功能和集线器一样，但是有多个端口，也就是多播（广播形式）。</p><p>​    集线器也是傻瓜设备，不仅不能存储数据，而且不支持并发，会有冲突。如果两个端口同时向一个端口发送数据，那么会失败，然后这两个端口会在随机时间后重试，知道不冲突为止</p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131203205867.png" alt="image-20220131203205867"></p><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h1><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220201150714322.png" alt="image-20220201150714322"></p><p>​    链路层的功能：</p><ul><li>给网络层提供服务：无确认无连接，有确认无连接，有确认有连接</li><li>链路管理 –&gt; 连接的建立，维持，释放</li><li>组帧</li><li>流量控制</li><li>差错控制 –&gt; 位错 &#x2F; 帧错</li></ul><h2 id="1-组帧-amp-透明传输"><a href="#1-组帧-amp-透明传输" class="headerlink" title="1.组帧 &amp; 透明传输"></a>1.组帧 &amp; 透明传输</h2><p>测试：</p><p><img src="/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220214130405104.png" alt="image-20220214130405104"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>操作系统</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h2><p>​    定义：位于用户层和底层硬件之间的一层，目的是：</p><ul><li>1.管理底层的硬件资源，协调硬件的资源，使得不同的部分组合在一起拥有更强大的功能。<ul><li>文件管理</li><li>内存管理</li><li>进程管理</li><li>设备管理</li></ul></li><li>2.提供给用户&#x2F;程序员接口：<ul><li>用户：<ul><li>GUI – 图形界面</li><li>命令接口<ul><li>cmd：联机命令接口</li><li>bat文件：脱机命令接口</li></ul></li></ul></li><li>程序员：系统调用</li></ul></li></ul><h2 id="1-2操作系统的特征"><a href="#1-2操作系统的特征" class="headerlink" title="1.2操作系统的特征"></a>1.2操作系统的特征</h2><p>​    四个特性：</p><ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ul><p>​    其中并发和共享是基础。</p><p>​    区分两个概念：</p><ul><li>并发：多个程序交替执行，是时分复用的思想</li><li>并行：多个程序同时执行</li></ul><h2 id="1-3操作系统的分类"><a href="#1-3操作系统的分类" class="headerlink" title="1.3操作系统的分类"></a>1.3操作系统的分类</h2><p>​    大致分一下几个阶段：</p><ul><li>手工操作机器：写纸袋 – 输入纸袋 – 读取纸袋 – 计算 –  写出纸袋 – 输出纸袋 – 取纸袋。缺点是利用率太低了，各个阶段，无论是cpu还是io</li><li>批处理阶段<ul><li>单道批处理系统：类似于bat文件，将程序直接写好，用外围机将纸袋转换成磁带 ，然后用户输入磁带，等待机器计算完后输出磁带。具体的不住：输入磁带 – 计算 – 输出磁带。利用的技术是：脱机输入输出技术。也有缺点，资源利用率低，cpu计算时io是空闲的。</li><li>多道批处理系统：利用了流水线技术。缺点：无人机交互功能，一旦提交程序就无法修改或输入参数</li></ul></li><li>分时操作系统：时间片轮转为用户提供作业，用户可通过终端与计算机进行交互。缺点是OS太公平了，没有优先级之分，没人得到的任务时间都是一样的，无法处理紧急任务</li><li>实时操作系统:<ul><li>硬实时操作系统：导弹发射 – 严格执行，对ddl的要求很严格</li><li>软实时操作系统：订火车票 – 偶尔违反</li></ul></li><li>其它：网络操作系统，分布式操作系统，个人操作系统</li></ul><h2 id="1-4操作系统的运行机制"><a href="#1-4操作系统的运行机制" class="headerlink" title="1.4操作系统的运行机制"></a>1.4操作系统的运行机制</h2><p>​    <img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212094555081.png" alt="image-20220212094555081"></p><h2 id="1-5中断和异常"><a href="#1-5中断和异常" class="headerlink" title="1.5中断和异常"></a>1.5中断和异常</h2><p>​    中断是唯一一种内核夺回cpu控制权的途径</p><p>​    中断分类：</p><ul><li>内中断：中断与当前执行的指令有关，也称为异常<ul><li>产生内中断的方式：执行非法的用户指令或参数非法，执行陷入指令（请求系统调用的时候会进行）</li></ul></li><li>外中断：与当前执行的指令无关<ul><li>产生外中断的方式：时钟中断（并发的实现），io中断（打印机打印完成）</li></ul></li></ul><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212112201718.png" alt="image-20220212112201718"></p><h2 id="1-6系统调用与函数"><a href="#1-6系统调用与函数" class="headerlink" title="1.6系统调用与函数"></a>1.6系统调用与函数</h2><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212113442182.png" alt="image-20220212113442182"></p><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212113701444.png" alt="image-20220212113701444"></p><p>​    系统调用能更好的去管理资源，因为很多资源的请求都是有条件的，共享也是在互斥的条件下才能共享的。</p><p>​    库函数是暴露给上层程序员的接口，而系统调用则是某些库函数在进行资源请求时的接口。</p><p>​    系统调用的过程：</p><ul><li>用户态：应用程序向寄存器中传入参数，指明想要那种系统调用</li><li>用户态：应用程序执行陷入指令，由用户态切换内核态</li><li>内核态：运行系统调用入口程序，检查寄存器中的参数，准备运行相对应的系统调用</li><li>内核态：运行响应的系统调用程序</li><li>用户态：返回用户态</li></ul><p>​    陷入指令 &#x3D; trap指令 &#x3D; 访管指令</p><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212225124372.png" alt="image-20220212225124372"></p><h2 id="1-7操作系统体系结构"><a href="#1-7操作系统体系结构" class="headerlink" title="1.7操作系统体系结构"></a>1.7操作系统体系结构</h2><ul><li>大内核 &#x2F; 单内核 &#x2F; 宏内核</li><li>微内核</li></ul><p>微内核和大内核的一个比较重要的区别：微内核向OS请求服务需要经过6次状态改变，而大内核只需要经过2次状态改变</p><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213123547242.png" alt="image-20220213123547242"></p><p>​    所以微内核的性能比较低，但是内核维护的资源少一点</p><h1 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h1><h2 id="1-进程-amp-程序-amp-进程实体"><a href="#1-进程-amp-程序-amp-进程实体" class="headerlink" title="1.进程 &amp; 程序 &amp; 进程实体"></a>1.进程 &amp; 程序 &amp; 进程实体</h2><p>​    概念 – 组成 – 特征</p><p>​    进程和程序的区别：</p><ul><li>程序：是我们写死的，一系列的指令的集和，表示为一个可执行文件，是静态的</li><li>进程：是程序的一次执行，是动态的</li></ul><p>​    进程的组成：</p><ul><li>PCB（程序管理块）：OS管理用的</li><li>程序段：进程自己用的，程序代码</li><li>数据段：进程自己用的，程序运行产生的数据</li></ul><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213132126787.png" alt="image-20220213132126787"></p><p>​    进程是程序的一次执行，是动态的，而进程实体，是在某一时刻进程的状态，包括PCB，程序段，数据段，这是静态的。</p><p>​    于是可以给进程下定义：进程是进程实体的整个运行过程，是系统进行资源分配与调度的基本单位</p><p>​    进程还有一些特征，不记录了</p><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213135040011.png" alt="image-20220213135040011"></p><h2 id="2-进程的状态与转换"><a href="#2-进程的状态与转换" class="headerlink" title="2.进程的状态与转换"></a>2.进程的状态与转换</h2><p>​    可以分为以下状态：</p><ul><li>创建状态：创建PCB，分配资源</li><li>就绪状态：资源1，处理机（CPU）0</li><li>运行状态：资源1，处理机1</li><li>阻塞状态：资源0，处理机0</li><li>终止状态：资源回收</li></ul><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213144610261.png" alt="image-20220213144610261"></p><p>​    进程的管理有两种方法，一是队列的形式（指针），二是索引的形式</p><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213144600005.png" alt="image-20220213144600005"></p><h2 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3.进程控制"></a>3.进程控制</h2><p>​    进程控制的工作：创建进程，撤销进程，进程状态转换。</p><p>​    用原语实现</p><p>​    原语的 原子性如何实现：通过“开 &#x2F; 关中断指令”。一旦执行了关中断指令，系统就不会去响应中断信号了。类似中断屏蔽机制。</p><h3 id="1-创建进程的原语"><a href="#1-创建进程的原语" class="headerlink" title="1.创建进程的原语"></a>1.创建进程的原语</h3><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213160142949.png" alt="image-20220213160142949"></p><h3 id="2-撤销进程的原语"><a href="#2-撤销进程的原语" class="headerlink" title="2.撤销进程的原语"></a>2.撤销进程的原语</h3><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213160229617.png" alt="image-20220213160229617"></p><h3 id="3-阻塞-x2F-唤醒进程的原语"><a href="#3-阻塞-x2F-唤醒进程的原语" class="headerlink" title="3.阻塞 &#x2F; 唤醒进程的原语"></a>3.阻塞 &#x2F; 唤醒进程的原语</h3><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213160431015.png" alt="image-20220213160431015"></p><h3 id="4-切换进程原语"><a href="#4-切换进程原语" class="headerlink" title="4.切换进程原语"></a>4.切换进程原语</h3><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213161125817.png" alt="image-20220213161125817"></p><h2 id="4-进程通信"><a href="#4-进程通信" class="headerlink" title="4.进程通信"></a>4.进程通信</h2><p>​    通过：共享存储，消息传递，管道通信实现</p><h3 id="1-共享存储"><a href="#1-共享存储" class="headerlink" title="1.共享存储"></a>1.共享存储</h3><p>​    进程之间的内存地址是只能有自己访问的。要想进程通信，可以再开辟一个单独的空间，归通信的进程所有，细分为两类。</p><ul><li>共享数据结构：只能存放一种特定的数据结构，通信慢，低级</li><li>共享存储区：在内存中单独分配一份空间，数据的类型，存放的位置由应用程序决定，不由OS决定，高速，高级</li></ul><p>​    无论哪种，进程对共享内存的访问都需要是互斥的</p><h3 id="2-管道通信"><a href="#2-管道通信" class="headerlink" title="2.管道通信"></a>2.管道通信</h3><p>​    以下几点：</p><ul><li>互斥访问</li><li>一个pipe只能半双工，要实现双工需要两个pipe</li><li>写满了会阻塞，只有写满了才能读，pipe不空不许写</li><li>最多一个进程读</li></ul><h3 id="3-消息传递"><a href="#3-消息传递" class="headerlink" title="3.消息传递"></a>3.消息传递</h3><ul><li>直接通信：直接将消息体加上消息头打包发出，然后OS给到对应进程的消息队列中去</li><li>间接通信（邮箱）：类似于web邮箱</li></ul><h2 id="5-线程"><a href="#5-线程" class="headerlink" title="5.线程"></a>5.线程</h2><h3 id="1-引入多线程"><a href="#1-引入多线程" class="headerlink" title="1.引入多线程"></a>1.引入多线程</h3><p>​    进程的出现是为了增加系统的并发度。多线程出现后，线程成为了系统调度的基本单位，进程只用于资源分配</p><p>​    线程和进程类似，有TCB（thread control block），TID（thread id）</p><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213203126361.png" alt="image-20220213203126361"></p><p>​    多线程引入后，相同进程的线程切换，开销少；不同进程的线程切换，开销依然大。</p><h3 id="2-线程的实现"><a href="#2-线程的实现" class="headerlink" title="2.线程的实现"></a>2.线程的实现</h3><ul><li>用户级线程（ULT）：用户自己来实现，并不由OS调度，通过app &amp; 线程库来对线程进行调度。<ul><li>优点：开销少，无需状态的切换</li><li>缺点：只能并发不能并行。并且单核多核一个样，因为核的调度单位是线程。然后若是碰上阻塞，那就阻塞了。</li></ul></li><li>内核级线程（kernel-level thread）：OS可以看到的线程，由OS调度<ul><li>优点：并发高，就算某线程阻塞了，可以通过内核的调度，去执行其它的线程</li><li>缺点：开销高，切换线程需要对应状态的改变。</li></ul></li></ul><h3 id="3-多线程模型"><a href="#3-多线程模型" class="headerlink" title="3.多线程模型"></a>3.多线程模型</h3><ul><li>一对一：一个用户级对应一个内核级</li></ul><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213213321140.png" alt="image-20220213213321140"></p><ul><li>多对一：多个用户级对应一个内核级，通过引入线程库实现。通过牺牲并发性来提高效率，一旦被阻塞就会over</li></ul><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213213205942.png" alt="image-20220213213205942"></p><ul><li>多对多（n : m）：n个用户及对应m个内核级，其中n&gt;&#x3D;m，这样就算某一个用户级线程被阻塞，其他用户线程也不会被阻塞。</li></ul><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213213144911.png" alt="image-20220213213144911"></p><p>​    总览：</p><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213213547855.png" alt="image-20220213213547855"></p><p>测试图片：</p><p><img src="/2022/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213233536884.png" alt="image-20220213233536884"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/13/hello-world/"/>
    <url>/2022/02/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
