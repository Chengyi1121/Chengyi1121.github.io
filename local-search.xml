<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>thymeleaf语法</title>
    <link href="/2022/02/16/thymeleaf%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/02/16/thymeleaf%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Thymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT  等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端  HTML5 开发的理想选择。</p><h2 id="1-创建模板文件"><a href="#1-创建模板文件" class="headerlink" title="1. 创建模板文件"></a>1. 创建模板文件</h2><p>创建一个 HTML 模板文件：</p><figure class="highlight dust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Index Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Welcome to BeiJing!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>通过<code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code>引入 Thymeleaf 命名空间。<code>th:text</code>用于处理<code>p</code>标签体的文本内容。该模板文件直接在任何浏览器中正确显示，浏览器会自动忽略它们不能理解的属性<code>th:text</code>。但这不是一个真正有效的 HTML5 文档，因为 HTML5 规范是不允许使用<code>th:*</code>这些非标准属性的。我们可以切换到 Thymeleaf 的<code>data-th-*</code>语法，以此来替换<code>th:*</code>语法：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Index Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">data-th-text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Welcome to BeiJing!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>HTML5 规范是允许<code>data-*</code>这样自定义的属性的。<code>th:*</code>和<code>data-th-*</code>这两个符号是完全等效且可以互换的。但为了简单直观和代码的紧凑性，本文采用<code>th:*</code>的表示形式。</p><h2 id="2-标准表达式语法"><a href="#2-标准表达式语法" class="headerlink" title="2. 标准表达式语法"></a>2. 标准表达式语法</h2><p>Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类：</p><ul><li>简单表达式</li><li>字面值</li><li>文本操作</li><li>算术运算</li><li>布尔运算</li><li>比较和相等</li><li>条件运算</li><li>无操作符</li></ul><h3 id="2-1-简单表达式"><a href="#2-1-简单表达式" class="headerlink" title="2.1 简单表达式"></a>2.1 简单表达式</h3><table><thead><tr><th align="center">语法</th><th>名称</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td align="center">${…}</td><td>Variable Expressions</td><td>变量表达式</td><td>取出上下文变量的值</td></tr><tr><td align="center">*{…}</td><td>Selection Variable Expressions</td><td>选择变量表达式</td><td>取出选择的对象的属性值</td></tr><tr><td align="center">#{…}</td><td>Message Expressions</td><td>消息表达式</td><td>使文字消息国际化，I18N</td></tr><tr><td align="center">@{…}</td><td>Link URL Expressions</td><td>链接表达式</td><td>用于表示各种超链接地址</td></tr><tr><td align="center">~{…}</td><td>Fragment Expressions</td><td>片段表达式</td><td>引用一段公共的代码片段</td></tr></tbody></table><h4 id="2-1-1-…"><a href="#2-1-1-…" class="headerlink" title="2.1.1 ${…}"></a>2.1.1 ${…}</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/standard-expression-syntax/variables&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">variables</span>(<span class="hljs-params">ModelMap model, HttpSession session</span>) &#123;<br>    model.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;now&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    model.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;Welcome to BeiJing!&quot;</span>);<br>    session.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;fanlychie&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">24</span>));<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>通过变量表达式<code>$&#123;&#125;</code>取出上下文环境中的<code>message</code>变量：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>它相当于：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ctx.getVariable(<span class="hljs-string">&quot;message&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-2-…"><a href="#2-1-2-…" class="headerlink" title="2.1.2 *{…}"></a>2.1.2 *{…}</h4><p>变量表达式<code>$&#123;&#125;</code>是面向整个上下文的，而选择变量表达式<code>*&#123;&#125;</code>的上下文是父标签（<code>th:object</code>）所选择的对象：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*</span></span></span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*</span></span></span><span class="hljs-template-variable">&#123;sex&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*</span></span></span><span class="hljs-template-variable">&#123;age&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>它相当于：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user.sex&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user.age&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如果对象没有被选择，那么，<code>*&#123;&#125;</code>和<code>$&#123;&#125;</code>表达式所达到的效果是完全相同的：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*</span></span></span><span class="hljs-template-variable">&#123;session.user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-1-3-…"><a href="#2-1-3-…" class="headerlink" title="2.1.3 #{…}"></a>2.1.3 #{…}</h4><p>消息表达式可用于国际化文字信息。首先我们来了解一下 i18n 资源文件的命名规则：</p><ul><li>basename.properties</li><li>basename_language.properties</li><li>basename_language_country.properties</li></ul><p><code>basename</code>是自定义的资源文件名称，<code>language</code>和<code>country</code>必须是 Java 支持的语言和国家。<code>basename.properties</code>是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。</p><p>创建文件<code>src/main/resources/messages.properties</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">welcome.message</span> = 北京欢迎你！<br></code></pre></td></tr></table></figure><p>创建文件<code>src/main/resources/messages_en_US.properties</code></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">welcome.<span class="hljs-keyword">message</span> = Welcome <span class="hljs-keyword">to</span> BeiJing!<br></code></pre></td></tr></table></figure><p>在 IntelliJ IDEA 编辑视图：</p><p><img src="https://raw.githubusercontent.com/fanlychie/mdimg/master/i18n-messages.png" alt="img"></p><p><code>messages</code>是 Spring Boot 加载资源文件默认采用的名称（<code>basename</code>），如果你所使用的资源文件名称不是以<code>messages</code>命名或所使用的资源文件不是在<code>src/main/resources</code>根目录，你可以通过<code>spring.messages.basename</code>属性来做具体的配置。如，资源文件<code>messages.properties</code>和<code>messages_en_US.properties</code>假设它们所在的目录位置是<code>src/main/resources/i18n</code>。</p><p>application.properties 配置示例：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">spring</span>.messages.<span class="hljs-keyword">basename</span>:i18n/messages<br></code></pre></td></tr></table></figure><p>application.yml 配置示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">spring<br>  messages<br>    <span class="hljs-built_in">basename</span>: i18n/messages<br></code></pre></td></tr></table></figure><p>静态文本消息示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 北京欢迎你！ --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#</span></span></span><span class="hljs-template-variable">&#123;welcom.message&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>消息表达式<code>#&#123;&#125;</code>是不允许直接处理非静态的文本消息的，但是你可以在资源文件中通过使用占位符<code>&#123;&#125;</code>来处理非静态的文本消息：</p><p>messages.properties 配置示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">welcome.user.message</span> = &#123;<span class="hljs-number">0</span>&#125;, 北京欢迎你！<br></code></pre></td></tr></table></figure><p>messages_en_US.properties 配置示例：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">welcome.user.<span class="hljs-keyword">message</span> = <span class="hljs-comment">&#123;0&#125;</span>, Welcome <span class="hljs-keyword">to</span> BeiJing!<br></code></pre></td></tr></table></figure><p>非静态文本消息，以参数的形式传递变量的值：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- fanlychie, 北京欢迎你！ --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#</span></span></span><span class="hljs-template-variable">&#123;welcome.user.message($&#123;session.user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-1-4-…"><a href="#2-1-4-…" class="headerlink" title="2.1.4 @{…}"></a>2.1.4 @{…}</h4><p>链接表达式<code>@&#123;&#125;</code>是专门用来处理 URL 链接地址的。</p><p>绝对地址示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- https://fanlychie.github.io --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-variable">&#123;https://fanlychie.github.io&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>页面相对地址示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- commons/base.html --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-variable">&#123;commons/base.html&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上下文相对地址（相对于当前的服务）示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- /css/mian.css --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">css</span>/mian.css&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>服务器相对地址（相对于部署在同一个服务器中的不同服务）示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- /image/upload --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-variable">&#123;~/image/upload&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>参数使用示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- /css/mian.css?v=1.0 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">css</span>/mian.css(v=1.0)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- /user/order?username=fanlychie --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">user</span>/order(username=$&#123;session.user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- /user/order?username=fanlychie&amp;status=PAIED --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">user</span>/order(username=$&#123;session.user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">,status=&#x27;PAIED&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- /user/fanlychie/info --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">user</span>/&#123;username&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/info(username=$</span></span></span><span class="hljs-template-variable">&#123;session.user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-1-5-…"><a href="#2-1-5-…" class="headerlink" title="2.1.5 ~{…}"></a>2.1.5 ~{…}</h4><p>片段表达式<code>~&#123;&#125;</code>可以用来引用一段公共的 HTML 代码片段。</p><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>~{templatename}</td><td>引用整个模板文件的代码片段</td></tr><tr><td>~{templatename :: selector}</td><td>selector 可以是 th:fragment 指定的名称或其他选择器。 如类选择器、ID选择器等</td></tr><tr><td>~{::selector}</td><td>相当于 ~{this :: selector}，表示引用当前模板定义的代码片段</td></tr></tbody></table><p>在 Thymeleaf 模板文件中，你可以使用<code>th:fragment</code>属性来定义一段公共的代码片段，然后你可以通过使用<code>th:insert</code>、<code>th:replace</code>、<code>th:include</code>（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。</p><p>src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;base.html，通过<code>th:fragment</code>属性定义一段公共的代码片段：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;footer&quot;</span> th:fragment=<span class="hljs-string">&quot;footerFragment&quot;</span>&gt;&amp;<span class="hljs-keyword">copy</span>; <span class="hljs-number">2017</span> fanlychie&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;index.html，通过<code>th:insert</code>属性引用一段公共的代码片段：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~</span></span></span><span class="hljs-template-variable">&#123;base :: footerFragment&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>其中，<code>~&#123;&#125;</code>是可选的，我们可以去掉这层的包裹：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> th:insert=<span class="hljs-string">&quot;base :: footerFragment&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>若 index.html 与 base.html 不在同级目录，如 templates&#x2F;commons&#x2F;base.html：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~</span></span></span><span class="hljs-template-variable">&#123;commons/base :: footerFragment&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>使用<code>th:fragment</code>属性定义代码片段时，你还可以声明一组参数：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;crumbs(parent, child)&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;parent&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;child&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;i&gt;用户中心&lt;/i&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;i&gt;我的订单&lt;/i&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">--&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;::crumbs(&#x27;用户中心&#x27;, &#x27;我的订单&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~</span></span></span><span class="hljs-template-variable">&#123;base :: #footer&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>除了<code>th:insert</code>属性<code>th:replace</code>也可以用来引用公共的代码片段。不同的是，<code>th:insert</code>是直接将代码片段插入到标签体内，而<code>th:replace</code>则是用代码片段直接替换标签体内容。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;div&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">    &lt;div id=&quot;footer&quot;&gt;© 2017 fanlychie&lt;/div&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;/div&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">--&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~</span></span></span><span class="hljs-template-variable">&#123;base :: footerFragment&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;div id=&quot;footer&quot;&gt;© 2017 fanlychie&lt;/div&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">--&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;~</span></span></span><span class="hljs-template-variable">&#123;base :: footerFragment&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-1-6-内置对象"><a href="#2-1-6-内置对象" class="headerlink" title="2.1.6 内置对象"></a>2.1.6 内置对象</h4><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/context/IContext.java">#ctx</a></td><td>上下文对象</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/context/IContext.java">#vars</a></td><td>同 #ctx，表示上下文变量</td></tr><tr><td>#locale</td><td>上下文本地化（特定的地理区域）变量，可参考 java.util.Locale</td></tr><tr><td>#request</td><td>HttpServletRequest 对象，可参考 javax.servlet.http.HttpServletRequest</td></tr><tr><td>#response</td><td>HttpServletResponse 对象，可参考 javax.servlet.http.HttpServletResponse</td></tr><tr><td>#session</td><td>HttpSession 对象，可参考 javax.servlet.http.HttpSession</td></tr><tr><td>#servletContext</td><td>ServletContext 对象，可参考 javax.servlet.ServletContext</td></tr></tbody></table><p><code>#ctx</code>示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- zh_CN --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">ctx.getLocale</span>()&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">ctx.getVariable</span>(&#x27;message&#x27;)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- true --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">ctx.containsVariable</span>(&#x27;message&#x27;)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>#vars</code>示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- zh_CN --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">vars.getLocale</span>()&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">vars.getVariable</span>(&#x27;message&#x27;)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- true --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">vars.containsVariable</span>(&#x27;message&#x27;)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>#locale</code>示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- zh_CN --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">locale</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- CN --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">locale.country</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 中国 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">locale.displayCountry</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- zh --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">locale.language</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 中文 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">locale.displayLanguage</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 中文 (中国) --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">locale.displayName</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>#request</code>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- HTTP/1.1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.protocol&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- http --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.scheme&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- localhost --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.serverName&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 8080 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.serverPort&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- GET --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.method&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- /standard-expression-syntax/variables --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.requestURI&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- http://localhost:8080/standard-expression-syntax/variables --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.requestURL&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- /standard-expression-syntax/variables --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.servletPath&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- java.util.Collections$3@203646fe --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.parameterNames&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &#123;q=[Ljava.lang.String;@3308c69f&#125; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.parameterMap&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- q=expression --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#request.queryString&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，请求地址的 URL 参数直接通过<code>#request.x</code>是取不出来的，需要使用<code>param.x</code>语法来取出。如，URL：<code>/standard-expression-syntax/variables?q=expression</code>，取出 q 参数的正确姿势：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;param.q&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>#response</code>示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 200 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">response.status</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 8192 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">response.bufferSize</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- UTF-8 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">response.characterEncoding</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- text/html;charset=UTF-8 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">response.contentType</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>#session</code>示例：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 2BCB2A0EACFF2D9D249D9799431B5127 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">session.id</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 1499786693244 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">session.lastAccessedTime</span>&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- fanlychie --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">session.getAttribute</span>(&#x27;user&#x27;).name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>注意，放到会话里面的对象直接通过<code>#session.x</code>是取不出来的，需要使用<code>session.x</code>语法来取出。如，取出会话里面的 user 对象的正确姿势：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;session.user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-1-7-工具类"><a href="#2-1-7-工具类" class="headerlink" title="2.1.7 工具类"></a>2.1.7 工具类</h4><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Messages.java">#messages</a></td><td>消息工具类，与 ＃{…} 作用相同</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Uris.java">#uris</a></td><td>地址相关的工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Conversions.java">#conversions</a></td><td>对象转换工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Dates.java">#dates</a></td><td>日期时间工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Calendars.java">#calendars</a></td><td>日历工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Numbers.java">#numbers</a></td><td>数字工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Strings.java">#strings</a></td><td>字符串工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Objects.java">#objects</a></td><td>对象工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Bools.java">#bools</a></td><td>布尔工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Arrays.java">#arrays</a></td><td>数组工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Lists.java">#lists</a></td><td>List 工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Sets.java">#sets</a></td><td>Set 工具类</td></tr><tr><td><a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.5.RELEASE/src/main/java/org/thymeleaf/expression/Maps.java">#maps</a></td><td>Map 工具类</td></tr></tbody></table><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- false --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">strings.isEmpty</span>(message)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2017-07-12 00:37:25 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">dates.format</span>(now, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-2-字面值"><a href="#2-2-字面值" class="headerlink" title="2.2 字面值"></a>2.2 字面值</h3><p>所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：<code>18</code>、<code>&#39;welcome&#39;</code>等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。</p><h4 id="2-2-1-文字字面值"><a href="#2-2-1-文字字面值" class="headerlink" title="2.2.1 文字字面值"></a>2.2.1 文字字面值</h4><p>文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Welcome to BeiJing! --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;Welcome to BeiJing!&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &#x27;Welcome to BeiJing!&#x27; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;\&#x27;Welcome to BeiJing!\&#x27;&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-数字字面值"><a href="#2-2-2-数字字面值" class="headerlink" title="2.2.2 数字字面值"></a>2.2.2 数字字面值</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 2017 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;2017&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 2018 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;2017 + 1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3-布尔字面值"><a href="#2-2-3-布尔字面值" class="headerlink" title="2.2.3 布尔字面值"></a>2.2.3 布尔字面值</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- false --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;1 &gt; 2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 否 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;1 &gt; 2 ? &#x27;是&#x27; : &#x27;否&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-4-空字面值"><a href="#2-2-4-空字面值" class="headerlink" title="2.2.4 空字面值"></a>2.2.4 空字面值</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- false --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user == null&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-2-5-字面令牌"><a href="#2-2-5-字面令牌" class="headerlink" title="2.2.5 字面令牌"></a>2.2.5 字面令牌</h4><p>字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）：</p><ul><li>大写或小写的字母、中文等不含空格和特殊符号的文本</li><li>0 到 9 的数字</li><li>中括号</li><li>下划线</li><li>连字符（-）</li><li>点符号（.）</li></ul><p>实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;Welcome to BeiJing!&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它等效于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;Welcome to BeiJing!&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-文本操作"><a href="#2-3-文本操作" class="headerlink" title="2.3 文本操作"></a>2.3 文本操作</h3><p>我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换。</p><h4 id="2-3-1-字符串连接"><a href="#2-3-1-字符串连接" class="headerlink" title="2.3.1 字符串连接"></a>2.3.1 字符串连接</h4><p>不管是字面值还是表达式的结果，我们都可以使用<code>+</code>符号将它们连接起来：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;Welcome to &#x27; + $</span></span></span><span class="hljs-template-variable">&#123;location&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> + &#x27;!&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-字面值替换"><a href="#2-3-2-字面值替换" class="headerlink" title="2.3.2 字面值替换"></a>2.3.2 字面值替换</h4><p>符号<code>||</code>可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用<code>+</code>连接符：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;|Welcome to $</span></span></span><span class="hljs-template-variable">&#123;location&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">!|&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-4-算术运算"><a href="#2-4-算术运算" class="headerlink" title="2.4 算术运算"></a>2.4 算术运算</h3><p>支持<code>+</code>（加）、<code>-</code>（减）、<code>*</code>（乘）、<code>/</code>（除）、<code>%</code>（模）运算：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 6 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;4 + 2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;4 - 2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 8 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;4 * 2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;4 / 2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 0 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;4 % 2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;pagination.page + 1&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 2 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;pagination.page&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> + 1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-5-布尔运算"><a href="#2-5-布尔运算" class="headerlink" title="2.5 布尔运算"></a>2.5 布尔运算</h3><p>支持<code>and</code>（且）、<code>or</code>（或）、<code>!</code>（非）、<code>not</code>（非）运算：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.online and user.vip&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.online or user.vip&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;!user.online&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;not user.online&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-6-比较和相等"><a href="#2-6-比较和相等" class="headerlink" title="2.6 比较和相等"></a>2.6 比较和相等</h3><p>支持<code>&lt;</code>（<code>lt</code>）、<code>&gt;</code>（<code>gt</code>）、<code>&lt;=</code>（<code>le</code>）、<code>&gt;=</code>（<code>ge</code>）、<code>==</code>（<code>eq</code>）、<code>！=</code>（<code>ne</code>）：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.age &lt; 60&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.age &lt;= 60&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.age &gt; 18&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.age &gt;= 18&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.age == 18&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.age != 18&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-7-条件运算"><a href="#2-7-条件运算" class="headerlink" title="2.7 条件运算"></a>2.7 条件运算</h3><p>三元运算符：<code>(if) ? (then) : (else)</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;p th:text=<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;user.online ? <span class="hljs-string">&#x27;在线&#x27;</span> : <span class="hljs-string">&#x27;离线&#x27;</span>&#125;</span>&quot;</span>&gt;&lt;/p&gt;<br>&lt;p th:text=<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;user.online ? (user.vip ? <span class="hljs-string">&#x27;VIP用户在线&#x27;</span> : <span class="hljs-string">&#x27;普通用户在线&#x27;</span>) : <span class="hljs-string">&#x27;离线&#x27;</span>&#125;</span>&quot;</span>&gt;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>二元运算符：<code>(value) ?: (defaultValue)</code>。</p><p>其中，<code>value</code>非空（null）即真，条件为真时输出<code>value</code>，否则输出<code>defaultValue</code>。假设<code>token = null</code>，<code>user.email = fanlychie@gmail.com</code></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 你还没有登录，请先登录 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;token&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> ?: &#x27;你还没有登录，请先登录&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- fanlychie@gmail.com --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.email&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> ?: &#x27;你还没有绑定邮箱&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-8-无操作符"><a href="#2-8-无操作符" class="headerlink" title="2.8 无操作符"></a>2.8 无操作符</h3><p>当模板运行在服务器端时，Thymeleaf 会解析<code>th:*</code>属性的具体值替换标签体的内容。无操作符（<code>_</code>）则允许你使用原型标签体的内容作为默认值：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 你还没有登录，请先登录 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;token&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> ?: _&quot;</span>&gt;</span>你还没有登录，请先登录<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="3-使用文本"><a href="#3-使用文本" class="headerlink" title="3. 使用文本"></a>3. 使用文本</h2><p>首先介绍两个最基础的<code>th:*</code>属<code>th:text</code>和<code>th:utext</code>，它们都是用于处理文本消息内容。</p><h3 id="3-1-th-text"><a href="#3-1-th-text" class="headerlink" title="3.1 th:text"></a>3.1 th:text</h3><p>在标签体中展示表达式评估结果的文本内容：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>使用外部化的文本内容：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Welcome to BeiJing!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的<code>th:text</code>属性，而显示<code>&lt;p&gt;</code>标签体的文本内容<code>Welcome to BeiJing!</code></p><p>当它作为模板文件运行在服务器端时，<code>th:text</code>属性的具体值将会替换<code>&lt;p&gt;</code>标签体的文本内容。</p><h3 id="3-2-th-utext"><a href="#3-2-th-utext" class="headerlink" title="3.2 th:utext"></a>3.2 th:utext</h3><p>属性<code>th:utext</code>与<code>th:text</code>的区别在于：</p><ul><li><code>th:text</code>默认会对含有 HTML 标签的内容进行字符转义；</li><li><code>th:utext</code>（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义；</li></ul><p>假设：<code>message = &quot;&lt;b&gt;Welcome to BeiJing!&lt;/b&gt;&quot;</code>。</p><p>使用<code>th:text</code>属性：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>th:text</code>效果：<b>Welcome to BeiJing!</b></p><p>使用<code>th:utext</code>属性：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>th:utext</code>效果：<strong>Welcome to BeiJing!</strong></p><h2 id="4-设置属性值"><a href="#4-设置属性值" class="headerlink" title="4. 设置属性值"></a>4. 设置属性值</h2><p>在 Thymeleaf 模板文件中，你可以使用<code>th:*</code>（或者使用<code>th:attr</code>属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以<code>th:*-*</code>来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用<code>th:attrappend</code>和<code>th:attrprepend</code>来追加新的值到现有的标签属性值中。</p><h3 id="4-1-th-attr"><a href="#4-1-th-attr" class="headerlink" title="4.1 th:attr"></a>4.1 th:attr</h3><p>这种方式是不被推荐的，了解一下就行。下面是用<code>th:attr=&quot;href=...&quot;</code>来设置标签<code>href</code>属性的值：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:attr</span>=<span class="hljs-string">&quot;href=@</span></span></span><span class="hljs-template-variable">&#123;https://www.google.com.hk&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>谷歌一下你就知道<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-2-th"><a href="#4-2-th" class="headerlink" title="4.2 th:*"></a>4.2 th:*</h3><p>显然<code>th:attr=&quot;href=@&#123;http://www.baidu.com&#125;&quot;</code>不够简洁，我们更推荐下面的这种语法：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-variable">&#123;https://www.google.com.hk&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>谷歌一下你就知道<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>其中<code>th:*</code>中的<code>*</code>可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- &lt;div item-id=&quot;1001&quot;&gt;Welcome to BeiJing!&lt;/div&gt; --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:item-id</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.id&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>Welcome to BeiJing!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-3-th"><a href="#4-3-th" class="headerlink" title="4.3 th:-"></a>4.3 th:<em>-</em></h3><p>如果想要同时为标签的多个不同属性设置相同的一个值，可以使用<code>th:*-*</code>的语法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> th:<span class="hljs-attribute">alt-title</span>=<span class="hljs-string">&quot;LOGO图片&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>它相当于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> th:<span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;LOGO图片&quot;</span> th:<span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;LOGO图片&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="4-4-th-attrappend-amp-th-attrprepend"><a href="#4-4-th-attrappend-amp-th-attrprepend" class="headerlink" title="4.4 th:attrappend &amp; th:attrprepend"></a>4.4 th:attrappend &amp; th:attrprepend</h3><p><code>th:attrappend</code>和<code>th:attrprepend</code>可以将表达式的结果分别追加到指定的属性值之后和之前。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">th:attrappend</span>=<span class="hljs-string">&quot;class=$</span></span></span><span class="hljs-template-variable">&#123;outOfStock&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;</span>&gt;</span>购买<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- &lt;button class=&quot;enable btn&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">th:attrprepend</span>=<span class="hljs-string">&quot;class=$</span></span></span><span class="hljs-template-variable">&#123;outOfStock&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> ? &#x27;enable &#x27; : &#x27;disable &#x27;&quot;</span>&gt;</span>购买<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>另外，还有两个常用的具体附加属性<code>th:classappend=&quot;...&quot;</code>和<code>th:styleappend=&quot;&quot;</code>。</p><p>它们分别用来代替<code>th:attrappend=&quot;class=...&quot;</code>和<code>th:attrappend=&quot;style=...&quot;</code>。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">th:classappend</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;outOfStock&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;</span>&gt;</span>购买<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-5-布尔属性"><a href="#4-5-布尔属性" class="headerlink" title="4.5 布尔属性"></a>4.5 布尔属性</h3><p>在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如<code>readonly</code>、<code>checked</code>、<code>selected</code>等。它们若存在那就意味着值为 true。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; <span class="hljs-type">name</span>=&quot;rememberme&quot; checked /&gt; 记住我<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;radio&quot; <span class="hljs-type">name</span>=&quot;sex&quot; <span class="hljs-keyword">value</span>=&quot;male&quot; checked&gt; 男<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;radio&quot; <span class="hljs-type">name</span>=&quot;sex&quot; <span class="hljs-keyword">value</span>=&quot;female&quot;&gt; 女<br>&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;text&quot; <span class="hljs-type">name</span>=&quot;appId&quot; <span class="hljs-keyword">value</span>=&quot;J123654&quot; readonly&gt;<br>&lt;<span class="hljs-keyword">select</span>&gt;<br>    &lt;<span class="hljs-keyword">option</span> selected&gt;北京&lt;/<span class="hljs-keyword">option</span>&gt;<br>    &lt;<span class="hljs-keyword">option</span>&gt;上海&lt;/<span class="hljs-keyword">option</span>&gt;<br>    &lt;<span class="hljs-keyword">option</span>&gt;广州&lt;/<span class="hljs-keyword">option</span>&gt;<br>    &lt;<span class="hljs-keyword">option</span>&gt;深圳&lt;/<span class="hljs-keyword">option</span>&gt;<br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p>Thymeleaf 也允许我们通过<code>th:*</code>（这里的<code>*</code>表示任意的布尔属性） 来选择是否使用这些布尔属性。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;rememberme&quot;</span> ch:<span class="hljs-attribute">checked</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;rememberme&#125;</span>&quot;</span> /&gt; 记住我<br></code></pre></td></tr></table></figure><p>正如你所见，如果表达式的结果为<code>true</code>，则自动勾选复选框，若为<code>false</code>，则不会自动勾选。</p><h2 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5. 遍历"></a>5. 遍历</h2><p>遍历（迭代）的语法<code>th:each=&quot;自定义的元素变量名称 : $&#123;集合变量名称&#125;&quot;</code>：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">spn</span>&gt;</span>你所在城市：<span class="hljs-tag">&lt;/<span class="hljs-name">spn</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mycity&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;city : $</span></span></span><span class="hljs-template-variable">&#123;cities&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;city.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>属性<code>th:each</code>提供了一个用于跟踪迭代的状态变量，它包含以下几个属性：</p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>int</td><td>当前迭代的索引，从 0 开始</td></tr><tr><td>count</td><td>int</td><td>当前迭代的计数，从 1 开始</td></tr><tr><td>size</td><td>int</td><td>集合中元素的总个数</td></tr><tr><td>current</td><td>int</td><td>当前的元素对象</td></tr><tr><td>even</td><td>boolean</td><td>当前迭代的计数是否是偶数</td></tr><tr><td>odd</td><td>boolean</td><td>当前迭代的计数是否是奇数</td></tr><tr><td>first</td><td>boolean</td><td>当前元素是否是集合的第一个元素</td></tr><tr><td>last</td><td>boolean</td><td>当前元素是否是集合的最后一个元素</td></tr></tbody></table><p>状态变量的使用语法：<code>th:each=&quot;自定义的元素变量名称, 自定义的状态变量名称 : $&#123;集合变量名称&#125;&quot;</code>：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">spn</span>&gt;</span>所在城市：<span class="hljs-tag">&lt;/<span class="hljs-name">spn</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mycity&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;city, status : $</span></span></span><span class="hljs-template-variable">&#123;cities&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;city.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">th:item-index</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;status.count&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>不管什么时候，Thymeleaf 始终会为每个<code>th:each</code>创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加<code>Stat</code>字符串组成：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">spn</span>&gt;</span>所在城市：<span class="hljs-tag">&lt;/<span class="hljs-name">spn</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mycity&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;city : $</span></span></span><span class="hljs-template-variable">&#123;cities&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;city.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">th:item-index</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;cityStat.count&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="6-条件判断"><a href="#6-条件判断" class="headerlink" title="6. 条件判断"></a>6. 条件判断</h2><p>条件判断语句有三种，分别是：<code>th:if</code>、<code>th:unless</code>、<code>th:swith</code>。</p><h3 id="6-1-th-if"><a href="#6-1-th-if" class="headerlink" title="6.1 th:if"></a>6.1 th:if</h3><p>当表达式的评估结果为真时则显示内容，否则不显示：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">user</span>/order(uid=$&#123;user.id&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">)&#125;&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user != null&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>我的订单<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>真假评估的依据：</p><ul><li>当表达式的值不为空（null）时<ul><li>如果表达式的值是一个布尔类型，且值为<code>true</code>评估为真，否则为假</li><li>如果表达式的值是一个数字类型，且值为非<code>0</code>评估为真，否则为假</li><li>如果表达式的值是一个字符类型，且值为非<code>0</code>评估为真，否则为假</li><li>如果表达式的值是一个字符串类型，且值为非<code>&quot;false&quot;</code>、<code>&quot;off&quot;</code>、<code>&quot;no&quot;</code>评估为真，否则为假</li><li>如果表达式的值不是一个<code>布尔</code>、<code>数字</code>、<code>字符</code>或<code>字符串</code>评估为真</li></ul></li><li>当表达式的值为空（null）时，评估结果为假</li></ul><p>因此，上面代码我们也可以简写成：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">user</span>/order(uid=$&#123;user.id&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">)&#125;&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>我的订单<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>但是，为了代码的可读性，我们并不建议这样使用。</p><h3 id="6-2-th-unless"><a href="#6-2-th-unless" class="headerlink" title="6.2 th:unless"></a>6.2 th:unless</h3><p><code>th:unless</code>与<code>th:if</code>判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@</span></span></span><span class="hljs-template-tag">&#123;/<span class="hljs-name">user</span>/order(uid=$&#123;user.id&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">)&#125;&quot;</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user == null&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>我的订单<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="6-3-th-swith"><a href="#6-3-th-swith" class="headerlink" title="6.3 th:swith"></a>6.3 th:swith</h3><p>多路选择语句，它需要搭配<code>th:case</code>来使用：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.role&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span>管理员<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>普通用户<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="7-定义局部变量"><a href="#7-定义局部变量" class="headerlink" title="7. 定义局部变量"></a>7. 定义局部变量</h2><p>使用<code>th:with</code>属性可以定义局部变量：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;name=&#x27;fanlychie&#x27;&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>同时定义多个局部变量时，用英文<code>,</code>号分隔开：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;name=$</span></span></span><span class="hljs-template-variable">&#123;user.name&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">,age=</span></span></span><span class="hljs-template-variable">&#123;user.age&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    ......</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8. 注释"></a>8. 注释</h2><p>下面介绍常见的两种注释：</p><h3 id="8-1-标准注释"><a href="#8-1-标准注释" class="headerlink" title="8.1 标准注释"></a>8.1 标准注释</h3><p>语法：<code>&lt;!-- ... ---&gt;</code>，注释的代码块会在文件源代码中显示出来。</p><h4 id="8-1-1-单行注释"><a href="#8-1-1-单行注释" class="headerlink" title="8.1.1 单行注释"></a>8.1.1 单行注释</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- &lt;span&gt;$</span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-comment">&lt;/span&gt; ---&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="8-1-2-多行注释"><a href="#8-1-2-多行注释" class="headerlink" title="8.1.2 多行注释"></a>8.1.2 多行注释</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!--</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;div th:switch=&quot;$</span></span><span class="hljs-template-variable">&#123;user.role&#125;</span><span class="language-xml"><span class="hljs-comment">&quot;&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">    &lt;p th:case=&quot;admin&quot;&gt;管理员&lt;/p&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">    &lt;p th:case=&quot;user&quot;&gt;普通用户&lt;/p&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">&lt;/div&gt;</span></span><br><span class="hljs-comment"><span class="language-xml">---&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="8-2-解析器级注释"><a href="#8-2-解析器级注释" class="headerlink" title="8.2 解析器级注释"></a>8.2 解析器级注释</h3><p>语法：<code>&lt;!--/* ... */--&gt;</code>，注释的代码块会在引擎解析的时候抹去。</p><h4 id="8-2-1-单行注释："><a href="#8-2-1-单行注释：" class="headerlink" title="8.2.1 单行注释："></a>8.2.1 单行注释：</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!--/* &lt;span&gt;$</span></span><span class="hljs-template-variable">&#123;message&#125;</span><span class="language-xml"><span class="hljs-comment">&lt;/span&gt; */--&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="8-2-2-多行注释"><a href="#8-2-2-多行注释" class="headerlink" title="8.2.2 多行注释"></a>8.2.2 多行注释</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!--/*--&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;user.role&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span>管理员<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>普通用户<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!--*/--&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="9-内联表达式"><a href="#9-内联表达式" class="headerlink" title="9. 内联表达式"></a>9. 内联表达式</h2><p>内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用<code>th:*</code>标签属性。</p><h3 id="9-1-…"><a href="#9-1-…" class="headerlink" title="9.1 [[…]]"></a>9.1 [[…]]</h3><p><code>[[]]</code>相当于<code>th:text</code>，对含有 HTML 标签的内容自动进行字符转义。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">&lt;p&gt;The message is : <span class="hljs-string">[[$&#123;htmlContent&#125;]]</span>&lt;/p&gt;<br></code></pre></td></tr></table></figure><h3 id="9-2-…"><a href="#9-2-…" class="headerlink" title="9.2 [(…)]"></a>9.2 [(…)]</h3><p><code>[()]</code>相当于<code>th:utext</code>，对含有 HTML 标签的内容不进行字符转义。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">p</span>&gt;The message is : [($&#123;htmlContent&#125;)]&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="9-3-th-inline"><a href="#9-3-th-inline" class="headerlink" title="9.3 th:inline"></a>9.3 th:inline</h3><p>我们已经了解到，使用<code>[[]]</code>和<code>[()]</code>语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用<code>th:inline</code>属性来激活，它的取值如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>禁止内联表达式，可以原样输出 [[]] 和 [()] 字符串</td></tr><tr><td>text</td><td>文本内联，可以使用 th:each 等高级语法</td></tr><tr><td>css</td><td>样式内联，如：<code>&lt;style th:inline=&quot;css&quot;&gt;</code></td></tr><tr><td>javascript</td><td>脚本内联，如：<code>&lt;style th:inline=&quot;javascript&quot;&gt;</code></td></tr></tbody></table><h4 id="9-3-1-none"><a href="#9-3-1-none" class="headerlink" title="9.3.1 none"></a>9.3.1 none</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- [[1, 2], [3, 4]] --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span>[[1, 2], [3, 4]]<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-3-2-text"><a href="#9-3-2-text" class="headerlink" title="9.3.2 text"></a>9.3.2 text</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 北京 上海 广州 深圳 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span></span><br><span class="language-xml">    [# th:each=&quot;city : $</span><span class="hljs-template-variable">&#123;cities&#125;</span><span class="language-xml">&quot;]</span><br><span class="language-xml">        [($</span><span class="hljs-template-variable">&#123;city.name&#125;</span><span class="language-xml">)]</span><br><span class="language-xml">    [/]</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="9-3-3-css"><a href="#9-3-3-css" class="headerlink" title="9.3.3 css"></a>9.3.3 css</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>:[[$&#123;bgColor&#125;]];</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-3-4-javascript"><a href="#9-3-4-javascript" class="headerlink" title="9.3.4 javascript"></a>9.3.4 javascript</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> user = [[$</span></span><span class="hljs-template-variable">&#123;user&#125;</span><span class="language-xml"><span class="language-javascript">]];</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;用户名：&quot;</span> + user.<span class="hljs-property">name</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java</title>
    <link href="/2022/02/16/Thinking%20in%20Java/"/>
    <url>/2022/02/16/Thinking%20in%20Java/</url>
    
    <content type="html"><![CDATA[<h1 id="Thinking-in-Java"><a href="#Thinking-in-Java" class="headerlink" title="Thinking in Java"></a>Thinking in Java</h1><h1 id="第2章-一切都是对象"><a href="#第2章-一切都是对象" class="headerlink" title="第2章 一切都是对象"></a>第2章 一切都是对象</h1><h2 id="1-存储"><a href="#1-存储" class="headerlink" title="1 存储"></a>1 存储</h2><p>​    Java中的引用，对象，等存储在什么地方？</p><p>​    stack区：存放引用。</p><p>​    heap区：存放被new出来的对象</p><p>​    方法区&#x2F;常量池：存放方法，常量，和class文件</p><p><img src="/2022/02/16/Thinking%20in%20Java/Thinking%20in%20Java%5C%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6.png"></p><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2 数组"></a>2 数组</h2><p>​    创建数组并将数组初始化，数组中存放的是很多个新的引用，这些未初始化的引用指向null。</p><p><img src="/2022/02/16/Thinking%20in%20Java/Thinking%20in%20Java%5C%E6%95%B0%E7%BB%84.png"></p><h2 id="3-作用域scope"><a href="#3-作用域scope" class="headerlink" title="3 作用域scope"></a>3 作用域scope</h2><p>​    Java中{}表示作用域。在作用域里创建的基本类型（和引用）在作用域之外（}之后）就消失了，但是对象不会。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">(String s)</span>&#123;<br>    String s1=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span>(s.length()&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> result=s.length();<br>        String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;字符串&quot;</span>+s+<span class="hljs-string">&quot;不为空&quot;</span>);<br>        s1=s2;<br>    &#125;<br>    System.out.println(s1);<br>    <span class="hljs-comment">// System.out.println(s2);</span><br>    <span class="hljs-comment">// System.out.println(result);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    在作用域将要结束时，将new的对象给到作用域外的引用s1，这样这个对象就被保存下来了，不会被GC回收。</p><h2 id="4-方法，参数，返回值"><a href="#4-方法，参数，返回值" class="headerlink" title="4 方法，参数，返回值"></a>4 方法，参数，返回值</h2><p>​    方法：方法名</p><p>​    参数：参数类型，参数个数（合起来称为参数列表）</p><p>​    方法签名：方法名+参数</p><p>​    返回值：void的方法作用域结束之前，可以加一个return，代表方法在这里结束</p><h1 id="第3章-操作符"><a href="#第3章-操作符" class="headerlink" title="第3章 操作符"></a>第3章 操作符</h1><h2 id="1-赋值"><a href="#1-赋值" class="headerlink" title="1 赋值"></a>1 赋值</h2><p>​        基本数据类型的赋值，就是复制，是值传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>;<br>    b=a;<span class="hljs-comment">//此时a=1,b=1</span><br>    a=<span class="hljs-number">3</span>;<span class="hljs-comment">//a=3,b还是为1，没有随a的变化变化</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​        引用的赋值，是地址的赋值，复制之后指向同一个地址，同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">man</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        man m1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>(<span class="hljs-number">12</span>);<br>        man m2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>(<span class="hljs-number">21</span>);<br>        m2=m1;<span class="hljs-comment">//现在m2和m1引用都指向了m1对象，m2原来指向的对象已经被GC回收</span><br>        m1.age=<span class="hljs-number">0</span>;<span class="hljs-comment">//m1和m2的age都设置成了0。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2 方法调用"></a>2 方法调用</h2><p>​        方法中传递一个引用，在方法的作用域内<strong>对这个引用进行修改，引用的对象也修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(man m)</span>&#123;<br>        m.age=-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        man m1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>(<span class="hljs-number">12</span>);<span class="hljs-comment">//m1的age为12</span><br>        change(m1);<span class="hljs-comment">//m1的age为-1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        总结：Java是值传递。当传的是基本类型时，传的是值的拷贝，对拷贝变量的修改不影响原变量；当传的是引用类型时，传的是<strong>引用地址的拷贝</strong>，但是拷贝的地址和真实地址指向的都是同一个真实数据，因此可以修改原变量中的值；当传的是String类型时，虽然拷贝的也是引用地址，指向的是同一个数据，但是String的值不能被修改，因此无法修改原变量中的值。</p><h2 id="3-i-和-i问题"><a href="#3-i-和-i问题" class="headerlink" title="3 i++和++i问题"></a>3 i++和++i问题</h2><p>​        i++和++i（3&#x3D;3++–&gt;3&#x3D;3，3++）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    n=i++;<span class="hljs-comment">//n=1,i=2</span><br>    n=++j;<span class="hljs-comment">//n=2,j=2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-x3D-x3D-和equals-问题"><a href="#4-x3D-x3D-和equals-问题" class="headerlink" title="4 &#x3D;&#x3D;和equals()问题"></a>4 &#x3D;&#x3D;和equals()问题</h2><p>​        &#x3D;&#x3D;比较的是引用</p><p>​        equals()比较的是对象，若创建了自己的类没有重写equals，比较的还是引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">man</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test01</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        man m1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>(<span class="hljs-number">12</span>);<br>        man m2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>(<span class="hljs-number">12</span>);<br>        System.out.println(m1==m2);<span class="hljs-comment">//false</span><br>        System.out.println(m1.equals(m2));<span class="hljs-comment">//false</span><br>        Integer i1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">11</span>);<br>        Integer i2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">11</span>);<br>        System.out.println(i1==i2);<span class="hljs-comment">//false</span><br>        System.out.println(i1.equals(i2));<span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        注：若创建出了自己的类，一定要覆盖equals方法！</p><h2 id="5-常量及指数计数法"><a href="#5-常量及指数计数法" class="headerlink" title="5 常量及指数计数法"></a>5 常量及指数计数法</h2><p>​        L(long),F(float),D(double),0X…(十六进制),1.39E-49F（1.39*10-49次方，float精度）</p><h2 id="6-三元操作符（boolean-exp-value0-value1）"><a href="#6-三元操作符（boolean-exp-value0-value1）" class="headerlink" title="6 三元操作符（boolean-exp?value0:value1）"></a>6 三元操作符（boolean-exp?value0:value1）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test01</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>        System.out.println(x&gt;<span class="hljs-number">10</span>?<span class="hljs-number">10</span>*x:<span class="hljs-number">9</span>*x);<span class="hljs-comment">//90</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a>第4章 控制执行流程</h1><h2 id="1-Foreach"><a href="#1-Foreach" class="headerlink" title="1 Foreach"></a>1 Foreach</h2><p>​        可用于数组，容器，还有枚举</p><p>​        方法：String-&gt;char[]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;abcd&quot;</span>;<br><span class="hljs-type">char</span>[] ch=s.toCharArray();<br></code></pre></td></tr></table></figure><p>​        方法：产生数组：range()&#x2F;&#x2F;自己写，py中的方法</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span>[] i=range(<span class="hljs-number">10</span>);//<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>...<span class="hljs-number">9</span><br><span class="hljs-attribute">int</span>[] j=range(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span><br><span class="hljs-attribute">int</span>[] k=range(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>);<span class="hljs-number">5</span>,<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="2-switch"><a href="#2-switch" class="headerlink" title="2 switch"></a>2 switch</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test01</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Scanner <span class="hljs-keyword">in</span>=<span class="hljs-keyword">new</span> Scanner(System.<span class="hljs-keyword">in</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            String c=<span class="hljs-keyword">in</span>.next();<br>            <span class="hljs-keyword">switch</span>(c)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;choose a&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;b&quot;</span>:System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;choose b&quot;</span>);<span class="hljs-keyword">break</span>;<br>                <span class="hljs-literal">default</span>:<span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;end&quot;</span>))<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        注意：break和default和冒号。</p><h1 id="第5章-初始化和清理"><a href="#第5章-初始化和清理" class="headerlink" title="第5章 初始化和清理"></a>第5章 初始化和清理</h1><h2 id="1-重载（多载）"><a href="#1-重载（多载）" class="headerlink" title="1 重载（多载）"></a>1 重载（多载）</h2><p>​        构造器又称构造方法，由于构造方法名唯一，所以签名只取决于参数列表，参数数目，类型，顺序有一个不同，签名就不同。</p><p>​        当参数为基本类型时，若实参&lt;形参（如int实参，double形参），实参类型会被提升（int转double），**char则会转为int型**；反之，实参&gt;形参，需要窄化处理（强制转换）。</p><p>​        根据方法的返回值来判断重载是不行的！</p><h2 id="2-this和super"><a href="#2-this和super" class="headerlink" title="2 this和super"></a>2 this和super</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">super</span>（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句） <br><span class="hljs-keyword">this</span>（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）<br><span class="hljs-keyword">super</span>:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：<span class="hljs-keyword">super</span>.变量名    <span class="hljs-keyword">super</span>.成员函数据名（实参）<br><span class="hljs-keyword">this</span>：它代表当前对象名（在程序中易产生二义性之处，应使用<span class="hljs-keyword">this</span>来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用<span class="hljs-keyword">this</span>来指明成员变量名）<br>调用<span class="hljs-keyword">super</span>()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用<span class="hljs-keyword">super</span>()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。<br><span class="hljs-keyword">super</span>()和<span class="hljs-keyword">this</span>()类似,区别是，<span class="hljs-keyword">super</span>()从子类中调用父类的构造方法，<span class="hljs-keyword">this</span>()在同一类内调用其它方法。<br><span class="hljs-keyword">super</span>()和<span class="hljs-keyword">this</span>()均需放在构造方法内第一行。<br>尽管可以用<span class="hljs-keyword">this</span>调用一个构造器，但却不能调用两个。<br><span class="hljs-keyword">this</span>和<span class="hljs-keyword">super</span>不能同时出现在一个构造函数里面，因为<span class="hljs-keyword">this</span>必然会调用其它的构造函数，其它的构造函数必然也会有<span class="hljs-keyword">super</span>语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。<br><span class="hljs-keyword">this</span>()和<span class="hljs-keyword">super</span>()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。<br>从本质上讲，<span class="hljs-keyword">this</span>是一个指向本对象的指针, 然而<span class="hljs-keyword">super</span>是一个Java关键字。<br></code></pre></td></tr></table></figure><h2 id="3-可变参数列表"><a href="#3-可变参数列表" class="headerlink" title="3 可变参数列表"></a>3 可变参数列表</h2><p>​        与重载结合使用时，当多个重载方法都有可变参数列表时，注意当实参小于形参时（实参char自动提升为形参int），实参会自动提升，可能导致编译器无法区分两个方法（模糊的ambiguous）。如下面的f(…)编译器就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test01</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i,Character...ch)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;first&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(Character...ch)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;secound&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        f(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<span class="hljs-comment">//实参‘a’自动提升为ANCII值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4 枚举"></a>4 枚举</h2><p>​        枚举是一种特殊的类，当创建一个枚举时，会自动给他添加如下方法：</p><p>​        **toString():**显示其中一个枚举实例的名字。</p><p>​        **ordinal():**显示枚举实例的声明顺序</p><p>​        **static values():**静态方法，产生一个由这些枚举常量构成的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span>&#123;<br>    S,M,L,XL,XXL,XXXL<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test01</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(Size s:Size.values())&#123;<br>            System.out.println(s.toString()+<span class="hljs-string">&quot; &quot;</span>+s.ordinal()+<span class="hljs-string">&quot;...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">output:</span><br><span class="hljs-comment">S 0...</span><br><span class="hljs-comment">M 1...</span><br><span class="hljs-comment">L 2...</span><br><span class="hljs-comment">XL 3...</span><br><span class="hljs-comment">XXL 4...</span><br><span class="hljs-comment">XXXL 5...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="第6章-访问权限的控制"><a href="#第6章-访问权限的控制" class="headerlink" title="第6章 访问权限的控制"></a>第6章 访问权限的控制</h1><p>​    Java有四种访问权限， 其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符。</p><ol><li>private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。</li><li>default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。</li><li>protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</li><li>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。</li></ol><h1 id="第7章-复用类"><a href="#第7章-复用类" class="headerlink" title="第7章 复用类"></a>第7章 复用类</h1><h2 id="1-组合"><a href="#1-组合" class="headerlink" title="1 组合"></a>1 组合</h2><p>​        组合：创建新类A，再创建另一个新类B，并且，B有一个实例变量是A的已经初始化了的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span>&#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">man</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">man</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//自动初始化实例变量</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;age&quot;</span>+<span class="hljs-string">&quot;:&quot;</span>+age;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bigman</span>&#123;<br>    man m=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>(<span class="hljs-number">18</span>);<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;atleast:&quot;</span>+m.age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test01</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">var</span> m=<span class="hljs-keyword">new</span> <span class="hljs-title class_">bigman</span>();<br>        System.out.println(m.toString());<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//ooutput atleast:18</span><br></code></pre></td></tr></table></figure><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2 继承"></a>2 继承</h2><p>​        继承了哪些？–&gt;非private的所有字段和方法</p><p>​        哪些可以更改？–&gt;可以覆盖基类的方法，static方法不能被覆盖，可以被继承。也可以为导出类添加新的字段和方法。</p><p>​        导出类可以调用基类吗？–&gt;导出类可以用super.方法名()调用上一级基类的方法，super.字段名调用上一级基类的字段，在导出类构造器中，可以用super()调用基类的构造方法。</p><p>​        导出类对象中竟然包含着向上的所有基类的对象。–&gt;当初始化基类时，首先会初始化Object对象，然后时下一级基类，再往下一直到当前的导出类。</p><h2 id="3-代理（组合-继承）"><a href="#3-代理（组合-继承）" class="headerlink" title="3 代理（组合+继承）"></a>3 代理（组合+继承）</h2><p>​        什么时候可以用代理？</p><p>​        比如，当要造一俩ship时，ship有一个control模块。可以写一个control类，然后再写一个ship类。</p><p>​        继承：让ship直接继承control类，继承相关功能。</p><p>​        组合：在ship类中实例化一个control对象，在ship中也定义相同的方法，让control对象去实现他们。</p><p>​        代理：继承+组合</p><h2 id="4-protected关键字的使用"><a href="#4-protected关键字的使用" class="headerlink" title="4 protected关键字的使用"></a>4 protected关键字的使用</h2><p>​        当需要导出类访问基类的成员或方法时，可将其设置为protected</p><h2 id="5-向上转型和向下转型"><a href="#5-向上转型和向下转型" class="headerlink" title="5 向上转型和向下转型"></a>5 向上转型和向下转型</h2><p>​        导出类可以自动转为基类（男人是人），基类转换成导出类需要强制转换且类型正确（人是（男人）人）</p><p>​        注：向上转型后，基类的引用不能访问导出类中扩展的方法。即丢失了导出类的具体信息。</p><h2 id="6-final和static"><a href="#6-final和static" class="headerlink" title="6 final和static"></a>6 final和static</h2><p>​        final：表示编译后不再改变。</p><p>​        static：表示只占用一块空间。</p><p>​        final+static：只占一块空间的常量。</p><p>​        （对于方法，使用final，一般是为了禁止方法被覆盖而这样做；对于类，表示这个类不能被继承）</p><h1 id="第8章-多态"><a href="#第8章-多态" class="headerlink" title="第8章 多态"></a>第8章 多态</h1><h2 id="1-绑定"><a href="#1-绑定" class="headerlink" title="1 绑定"></a>1 绑定</h2><p>​        前期绑定：在程序运行前必须确定对象的具体类型。</p><p>​        后期绑定&#x2F;动态绑定&#x2F;运行时绑定：在程序运行时根据对象的类型来进行绑定。</p><h2 id="2-private-，final，static（对于方法）"><a href="#2-private-，final，static（对于方法）" class="headerlink" title="2 private ，final，static（对于方法）"></a>2 private ，final，static（对于方法）</h2><p>​        private：不可被覆盖</p><p>​        final：动态绑定被关闭</p><p>​        static：不具备多态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        people m=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>(<span class="hljs-number">19</span>);<br>        System.out.println(m.what());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">people</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age=age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">what</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;people age&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">people</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">man</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">super</span>(age);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">what</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;man age&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        如上，最后调用的是people的what()方法，并不是man的what()方法。static没有多态。</p><h2 id="3-构造器内部多态方法的行为"><a href="#3-构造器内部多态方法的行为" class="headerlink" title="3 构造器内部多态方法的行为"></a>3 构造器内部多态方法的行为</h2><p>​        初始化的步骤：</p><p>​            1.将分配给对象的空间初始化成二进制的0（基本数据类型为0，false，引用为null）。</p><p>​            2.调用基类的构造器，如果基类的构造器中有即将被导出类覆盖的方法，调用覆盖后的方法，这个时候，非静态量都是0，因为还没有初始化。</p><p>​            3.按照声明的顺序调用成员初始化方法。</p><p>​            4.调用导出类的构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        people m=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>(<span class="hljs-number">19</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">int</span> num=-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">people</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age=age;<br>        what();<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">what</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;people age&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">people</span>&#123;<br><br>    <span class="hljs-type">int</span> sum=-<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">man</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">super</span>(age);<br>        System.out.println(<span class="hljs-built_in">super</span>.num);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">what</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(sum);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;man age&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-协变返回类型"><a href="#4-协变返回类型" class="headerlink" title="4 协变返回类型"></a>4 协变返回类型</h2><p>​        当基类的某一个方法的返回值是一个具体的对象，其导出类覆盖掉这个方法后返回值可以是这个对象的向下转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">people</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;people con&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">man</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;man con&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    people <span class="hljs-title function_">act</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">people</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>&#123;<br>    man <span class="hljs-title function_">act</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">var</span> f=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br>        <span class="hljs-keyword">var</span> s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">son</span>();<br>        f.act();<br>        s.act();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-向下转型与运行时类型识别（RTTI）"><a href="#5-向下转型与运行时类型识别（RTTI）" class="headerlink" title="5 向下转型与运行时类型识别（RTTI）"></a>5 向下转型与运行时类型识别（RTTI）</h2><h1 id="第9章-接口"><a href="#第9章-接口" class="headerlink" title="第9章 接口"></a>第9章 接口</h1><h2 id="1-抽象abstract"><a href="#1-抽象abstract" class="headerlink" title="1 抽象abstract"></a>1 抽象abstract</h2><p>​        抽象类：可包含抽象方法，也可包含具体方法，也可定义字段；若其导出类为所有抽象方法提供定义，则算是一个具体的类；若导出类没有为抽象方法提供具体定义，则导出类仍未抽象类。</p><p>​        抽象方法：用static，只有方法名参数列表，没有方法体。</p><h2 id="2-接口interface"><a href="#2-接口interface" class="headerlink" title="2 接口interface"></a>2 接口interface</h2><p>​        接口是纯抽象的类，只有抽象方法的声明。</p><p>​        一个类可实现多个接口。</p><p>​        类实现了多个接口后，可以向上转为这些接口的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">man</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;man eat&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;man sleep&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">boy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;boy eat&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;boy sleep&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        people p1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">man</span>();<br>        people p2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boy</span>();<br>        p1.eat();<br>        p2.sleep();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        应用接口象像是多重继承一样，只不过更简单。</p><p>​        接口可以继承接口，从而创建新的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">people</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">smoke</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-策略设计模式"><a href="#3-策略设计模式" class="headerlink" title="3 策略设计模式"></a>3 策略设计模式</h2><p>​        创建一个方法，这个方法能根据传入参数的不同来执行不同的行为，说白了还是多态。</p><h2 id="4-适配器设计模式"><a href="#4-适配器设计模式" class="headerlink" title="4 适配器设计模式"></a>4 适配器设计模式</h2><p>​        接收到拥有的接口，产生需要的接口（强制转换）。</p><h2 id="5-工厂方法设计模式"><a href="#5-工厂方法设计模式" class="headerlink" title="5 工厂方法设计模式"></a>5 工厂方法设计模式</h2><p>​        创建工厂类，用工厂里的方法来得到想要的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>&#123;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ManFactory</span>&#123;<br>    Man <span class="hljs-title function_">getMan</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第10章-内部类"><a href="#第10章-内部类" class="headerlink" title="第10章 内部类"></a>第10章 内部类</h1><h2 id="1-普通内部类"><a href="#1-普通内部类" class="headerlink" title="1 普通内部类"></a>1 普通内部类</h2><p>​        在外部类的内部，方法的外部</p><p>​        能访问外部类的字段和方法。</p><p>​        在内部类中，内部类类名.this 会得到内部类的引用；外部类类名.this得到外部类的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>&#123;<br>        <span class="hljs-built_in">this</span>.count=count;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMoreThanThousand</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>&#123;<br>            <span class="hljs-keyword">return</span> count&gt;<span class="hljs-number">1000</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>        &#125;<br>        test <span class="hljs-title function_">getTest</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> test.<span class="hljs-built_in">this</span>;<br>        &#125;<br>        Inner <span class="hljs-title function_">getIniner</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> Inner.<span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">1001</span>;<br>        test t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">test</span>(count);<br>        test.Inner inner=t.getInner();<br>        System.out.println(t.equals(inner.getTest()));<span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        通过外部类的引用.new来使其内部类对象被创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">what</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;this is inner&quot;</span>);<br>        &#125;<br>        Test <span class="hljs-title function_">getTest</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> Test.<span class="hljs-built_in">this</span>;<br>        &#125;<br>    &#125;<br>    Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">var</span> t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-keyword">var</span> ti=t.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        ti.what();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        内部类体现了Java的闭包特性，在类中再创建一个private类（只有其外部类能访问），或者protected类（其外部类和与外部类在一个包中的类可以访问），都能体现出封装&#x2F;闭包的思想。</p><h2 id="2-局部内部类"><a href="#2-局部内部类" class="headerlink" title="2 局部内部类"></a>2 局部内部类</h2><p>​        在方法的内部。</p><p>​        内部类实现了摸个接口，但对外部类是不可见的。</p><p>​        局部内部类在方法内部，也可以实现接口，然后在这个方法内部的最后，返回这个接口类型的向上转型，这也可以算是一种多重继承。</p><h2 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3 匿名内部类"></a>3 匿名内部类</h2><p>​            局部内部类的简化形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">what</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> AInterface <span class="hljs-title function_">aInterface</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AInterface</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">what</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;what???&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Test t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        AInterface a=t.aInterface();<br>        a.what();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​        在匿名内部类中定义字段时，还可以对其进行初始化，如果在匿名类的内部多字段进行初始化，需要写一个更改器（set方法），并且这个方法的形参需要是final的；若是传入基类的构造器中，则不需要final。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> Contents <span class="hljs-title function_">contents</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String str)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Contents</span>()&#123;<br>            String name=str;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">readString</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> name;<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">var</span> t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        Contents c=t.contents(<span class="hljs-string">&quot;niubi!&quot;</span>);<br>        System.out.println(c.readString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-匿名内部类实现工厂方法"><a href="#4-匿名内部类实现工厂方法" class="headerlink" title="4 匿名内部类实现工厂方法"></a>4 匿名内部类实现工厂方法</h2><h2 id="—-内部类暂时只看普通内部类-局部内部类，其它后续再看"><a href="#—-内部类暂时只看普通内部类-局部内部类，其它后续再看" class="headerlink" title="—-内部类暂时只看普通内部类+局部内部类，其它后续再看"></a>—-内部类暂时只看普通内部类+局部内部类，其它后续再看</h2><h1 id="第11章-持有对象（容器-x2F-集合类）"><a href="#第11章-持有对象（容器-x2F-集合类）" class="headerlink" title="第11章 持有对象（容器&#x2F;集合类）"></a>第11章 持有对象（容器&#x2F;集合类）</h1><h2 id="1-泛型和类型安全"><a href="#1-泛型和类型安全" class="headerlink" title="1 泛型和类型安全"></a>1 泛型和类型安全</h2><p>​        尖括号里的类型为泛型参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; strings=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        strings.add(<span class="hljs-string">&quot;e&quot;</span>);<br>        strings.add(<span class="hljs-string">&quot;afafaf&quot;</span>);<br>        strings.add(<span class="hljs-string">&quot;wqwqw&quot;</span>);<br>        <span class="hljs-keyword">for</span>(String str:strings)&#123;<br>            System.out.println(str+<span class="hljs-string">&quot; size:&quot;</span>+strings.size());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        一旦制定了泛型参数（未指定默认Object），就只能在容器中添加泛型对应的类型或其导出类（小狗是狗，所以可以放进容器）。</p><h2 id="2-容器的基本概念"><a href="#2-容器的基本概念" class="headerlink" title="2 容器的基本概念"></a>2 容器的基本概念</h2><h3 id="1）Collection："><a href="#1）Collection：" class="headerlink" title="1）Collection："></a>1）Collection：</h3><p>​            是一条独立的序列，这些元素遵守一条或多条规则：List必须按照插入顺序保存元素；Set不能有重复元素；Queen按照排队规则来确定对象产生的顺序。</p><h3 id="2）Map："><a href="#2）Map：" class="headerlink" title="2）Map："></a>2）Map：</h3><p>​            一组成对的键值对对象。如ArrayList允许用数字查找值。</p><h2 id="3-向容器中添加元素"><a href="#3-向容器中添加元素" class="headerlink" title="3 向容器中添加元素"></a>3 向容器中添加元素</h2><p>​        两个方法：</p><p>​            1）Arrays.asList()：接收一个数组或者用逗号分隔的元素列表，返回一个List对象</p><p>​            2）Collections.addAll()：接收一个collection对象+一个数组或者用逗号分隔的元素列表，将其添加到collection中去。</p><p>​            3）collection.addAll()：接收一个List，将其添加到collection中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;Integer&gt; collection=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<span class="hljs-comment">//创建collection对象</span><br>        Integer[] integers=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>        collection.addAll(Arrays.asList(integers));<span class="hljs-comment">//用collection中的方法</span><br>        Collections.addAll(collection, <span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//用Collections中的静态方法</span><br>        Collections.addAll(collection, integers);<span class="hljs-comment">//用Collections中的静态方法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:collection)&#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-容器的打印"><a href="#4-容器的打印" class="headerlink" title="4 容器的打印"></a>4 容器的打印</h2><p>​        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;Integer&gt; collection=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>        Integer[] integers=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>        collection.addAll(Arrays.asList(integers));<br>        Collections.addAll(collection, <span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>        Collections.addAll(collection, integers);<br>        System.out.println(collection);<span class="hljs-comment">//直接打印</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        直接打印。</p><h2 id="5-List简介"><a href="#5-List简介" class="headerlink" title="5 List简介"></a>5 List简介</h2><p>​        ArrayList：随机访问元素快；插入删除元素慢。</p><p>​        LinkedList：随机访问元素慢；插入和删除快。</p><h2 id="6-迭代器Iterator"><a href="#6-迭代器Iterator" class="headerlink" title="6 迭代器Iterator"></a>6 迭代器Iterator</h2><p>​        迭代器是一种轻量级的对象，可以单项移动，使用容器中的iterator()获取一个Iterator，有next() hasNext() remove()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;Integer&gt; collection=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>        Iterator&lt;Integer&gt; iterator=collection.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>            System.out.println(iterator.next());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        Iterator类似于链表，初始的Iterator指向第一个元素，Iterator.next()指针是指向当前位置的元素，并返回第一个元素</p><img src="/2022/02/16/Thinking%20in%20Java/Iteratorpng.png" style="zoom:75%;"><h2 id="7-LinkedList"><a href="#7-LinkedList" class="headerlink" title="7 LinkedList"></a>7 LinkedList</h2><p>​        LinkedList在插入删除时更加高级，可以实现栈，队列，双端队列的方法。</p><p>​        方法：</p><p>​            getFirst()&#x2F;element()</p><p>​            removeFirst()&#x2F;remove()</p><p>​            addFirst()</p><p>​            addLast()&#x2F;add()</p><p>​            removeLast()</p><p>​            peek() 检索但不删除此列表的头（第一个元素），空表返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedList&lt;Integer&gt; linkedList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>));<br>        System.out.println(linkedList);<br>        linkedList.addFirst(<span class="hljs-number">0</span>);<br>        System.out.println(linkedList);<br>        linkedList.removeLast();<br>        System.out.println(linkedList);<br>        linkedList.add(<span class="hljs-number">5</span>);<br>        System.out.println(linkedList);<br>        System.out.println(linkedList.peek()==<span class="hljs-literal">null</span>);<br>        linkedList.removeAll(linkedList);<br>        System.out.println(linkedList);<br>        System.out.println(linkedList.peek()==<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        可用linkedList.peek()&#x3D;&#x3D;null判断list是不是空，也可直接用linkedList.isEmpty()。</p><h2 id="8-Set"><a href="#8-Set" class="headerlink" title="8 Set"></a>8 Set</h2><p>​        Set主要用于查找，因为Set不允许重复元素出现，一般选择set时选择HashSet</p><h2 id="9-Map"><a href="#9-Map" class="headerlink" title="9 Map"></a>9 Map</h2><p>​        Map的优势在于它的键-值对，以及Map可以很容易扩展到多维。</p><h2 id="10-Queue"><a href="#10-Queue" class="headerlink" title="10 Queue"></a>10 Queue</h2><p>​        队列，先进先出；</p><p>​        PriorityQueue：优先队列</p><h2 id="—-Collection与迭代器"><a href="#—-Collection与迭代器" class="headerlink" title="—-Collection与迭代器"></a>—-Collection与迭代器</h2><h1 id="第12章-异常处理"><a href="#第12章-异常处理" class="headerlink" title="第12章 异常处理"></a>第12章 异常处理</h1><h2 id="1-try-with-resource"><a href="#1-try-with-resource" class="headerlink" title="1 try with resource"></a>1 try with resource</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<br>    <span class="hljs-comment">//需要关闭的变量的声明和初始化</span><br>) &#123;<br>    <span class="hljs-comment">//</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> handle exception</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><h1 id="第13章-字符串"><a href="#第13章-字符串" class="headerlink" title="第13章 字符串"></a>第13章 字符串</h1><h2 id="1-String的只读性"><a href="#1-String的只读性" class="headerlink" title="1 String的只读性"></a>1 String的只读性</h2><p>​        String是不变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    String <span class="hljs-title function_">change</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-keyword">return</span> s.toUpperCase();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Test t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        String s=<span class="hljs-string">&quot;abcd&quot;</span>;<br>        String ss=t.change(s);<br>        System.out.println(s);<br>        System.out.println(ss);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        可以看到，将String s作为实参传入之后，s并没有改变，与对象不同，它是创建后就不变的。</p><h2 id="2-StringBuilder和StringBuffer"><a href="#2-StringBuilder和StringBuffer" class="headerlink" title="2 StringBuilder和StringBuffer"></a>2 StringBuilder和StringBuffer</h2><p>​        StringBuilder更高效，但不是线程安全的。</p><p>​        StringBuffer是线程安全的，但性能低点。</p><p>​        StringBuilder的方法：</p><p>​            insert()    插入</p><p>​            replace()    替换</p><p>​            substring()</p><p>​            reverse()    反转</p><p>​            append()    追加</p><p>​            delete()    删除</p><p>​            toString()</p><h2 id="3-String的详细操作"><a href="#3-String的详细操作" class="headerlink" title="3 String的详细操作"></a>3 String的详细操作</h2><p>![](Thinking%20in%20Java\新识别word文档 2021-07-24 14.51_2.jpg)</p><p>![新识别word文档 2021-07-24 14.51_edit_1187438893440685](Thinking%20in%20Java\新识别word文档 2021-07-24 14.51_edit_1187438893440685.jpg)</p><h2 id="4-Formatter类"><a href="#4-Formatter类" class="headerlink" title="4 Formatter类"></a>4 Formatter类</h2><p>​        System.out.format()&lt;&#x3D;&#x3D;&gt;C语言中的printf</p><p>​        上面的功能还可以使用到普通类中，只需要创建Formatter对象，然后将对象添加到类的构造方法中，就饿可以在其他方法中格式化输出了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">mport java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.util.Formatter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> Formatter f;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age,Formatter f)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age=age;<br>        <span class="hljs-built_in">this</span>.f=f;<br>        <span class="hljs-built_in">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">what</span><span class="hljs-params">()</span>&#123;<br>        f.format(<span class="hljs-string">&quot;name:%s---age:%d&quot;</span>, name,age);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        PrintStream ps=System.out;<br>        Test t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">19</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Formatter</span>(ps));<br>        t.what();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        还可以利用格式化说明符进行更深入的格式化。</p><p>​        如下面的产生购物收据的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.io.PrintStream;<br><span class="hljs-keyword">import</span> java.util.Formatter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PrintStream ps=System.out;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Formatter formatter=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Formatter</span>(ps);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> sum=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTitle</span><span class="hljs-params">()</span>&#123;<br>        formatter.format(<span class="hljs-string">&quot;%-15s %5s %5s %10s\n&quot;</span>,<span class="hljs-string">&quot;Item&quot;</span>,<span class="hljs-string">&quot;Count&quot;</span>,<span class="hljs-string">&quot;Price&quot;</span>,<span class="hljs-string">&quot;All&quot;</span>);<br>        formatter.format(<span class="hljs-string">&quot;%-15s %5s %5s %10s\n&quot;</span>,<span class="hljs-string">&quot;----&quot;</span>,<span class="hljs-string">&quot;----&quot;</span>,<span class="hljs-string">&quot;----&quot;</span>,<span class="hljs-string">&quot;----&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> count,<span class="hljs-type">float</span> price)</span>&#123;<br>        formatter.format(<span class="hljs-string">&quot;%-15.15s %5s %5.2f %10.2f\n&quot;</span>, name,count,price,price*count);<br>        sum+=price*count;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTotal</span><span class="hljs-params">()</span>&#123;<br>        formatter.format(<span class="hljs-string">&quot;%-15.5s %5s %5s %10s\n&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot; &quot;</span> ,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;----&quot;</span>);<br>        formatter.format(<span class="hljs-string">&quot;%-15.5s %5s %5s %10.2f\n&quot;</span>, <span class="hljs-string">&quot;Total&quot;</span>,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot; &quot;</span>,sum);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        printTitle();<br>        print(<span class="hljs-string">&quot;Cola&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2.5f</span>);<br>        print(<span class="hljs-string">&quot;Meat&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        print(<span class="hljs-string">&quot;Ice-Cream&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>);<br>        printTotal();<br>    &#125;<br></code></pre></td></tr></table></figure><p>​        所有的文字做好都用英文来描述。</p><h2 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5 正则表达式"></a>5 正则表达式</h2><h2 id="—-1"><a href="#—-1" class="headerlink" title="—-"></a>—-</h2><h1 id="项目经验："><a href="#项目经验：" class="headerlink" title="项目经验："></a>项目经验：</h1><p>1.String.format(“%8.8s”,arg1,arg2…)：和printf一样，只不过会返回一个String对象，用于格式化字符串。</p><p>2.string.split(“”)[].split(“”)…：可以不断将字符串划分，直到得到想要的字符串。</p><p>3.StringBuilder：用其apend()方法来取代+，十分节省性能。</p><p>4.String.value(double d)：将double转换成String</p><h1 id="第14章-类型信息"><a href="#第14章-类型信息" class="headerlink" title="第14章 类型信息"></a>第14章 类型信息</h1><h2 id="—-2"><a href="#—-2" class="headerlink" title="—-"></a>—-</h2><h1 id="第15章-泛型"><a href="#第15章-泛型" class="headerlink" title="第15章 泛型"></a>第15章 泛型</h1><p>泛型：适用于许多许多的类型。</p><h2 id="1-简单泛型"><a href="#1-简单泛型" class="headerlink" title="1 简单泛型"></a>1 简单泛型</h2><p>​        使用泛型的类：在类名后面添加<T>，T代表不确定类型</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> T t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(T t)</span>&#123;<br>        <span class="hljs-built_in">this</span>.t=t;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getT</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Test&lt;String&gt; test=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;String&gt;(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        System.out.println(test.getT());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-元组"><a href="#2-元组" class="headerlink" title="2 元组"></a>2 元组</h2><p>​        元组：将一组对象打包储存于一个单一对象内，可以向这个容器对象读取元素，但不能添加元素。</p><p>​        元组又称为：数据传送对象&#x2F;信使</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;A,B&gt;&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> A a;<span class="hljs-comment">//设置成public final，既可以读取，还可以防止被修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> B b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(A a,B b)</span>&#123;<br>        <span class="hljs-built_in">this</span>.a=a;<br>        <span class="hljs-built_in">this</span>.b=b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">var</span> t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        System.out.println(t.a+<span class="hljs-string">&quot; &quot;</span>+t.b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        还可以通过继承，将短的元组进一步拓展，而不需要重新编写元组。ik</p><h1 id="第16章-数组"><a href="#第16章-数组" class="headerlink" title="第16章 数组"></a>第16章 数组</h1><h1 id="第17章-深入容器"><a href="#第17章-深入容器" class="headerlink" title="第17章 深入容器"></a>第17章 深入容器</h1><h2 id="—-3"><a href="#—-3" class="headerlink" title="—-"></a>—-</h2><h1 id="第18章-I-x2F-O"><a href="#第18章-I-x2F-O" class="headerlink" title="第18章 I&#x2F;O"></a>第18章 I&#x2F;O</h1><p><img src="/2022/02/16/Thinking%20in%20Java/image-20220216021830766.png" alt="image-20220216021830766"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2022/02/16/SpringBoot/"/>
    <url>/2022/02/16/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="1SpringBoot"><a href="#1SpringBoot" class="headerlink" title="1SpringBoot"></a>1SpringBoot</h1><h2 id="1-创建Spring-Boot项目"><a href="#1-创建Spring-Boot项目" class="headerlink" title="1 创建Spring Boot项目"></a>1 创建Spring Boot项目</h2><p>​    1.官网直接创建项目下载导入idea（Springboot initializr）</p><p>​    2.使用idea构建springboot项目，还是从官网创建，只不过idea提供了接口</p><h2 id="2-springboot项目里的类，配置"><a href="#2-springboot项目里的类，配置" class="headerlink" title="2 springboot项目里的类，配置"></a>2 springboot项目里的类，配置</h2><p>​    1.src&gt;main&gt;java&gt;com.example.deom&gt;DemoApplication.java&gt;main方法：启动main方法，是项目的入口</p><p>​    2.src&gt;main&gt;resourses&gt;application.properties：springboot的配置</p><p>​        可以配置springboot占用的端口号，默认是8080，这里我修改成了8081</p><figure class="highlight elm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">server</span>.<span class="hljs-keyword">port</span>=8081<br></code></pre></td></tr></table></figure><p>​    3.src&gt;test&gt;java&gt;com.example.demo&gt;DemoApplicationTests.java：测试类</p><p>​    4.pom.xml文件，配置文件</p><p>​    下面是spring-web依赖和spring-test依赖的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​    5.修改banner</p><p>​        在resource目录下创建一个banner.txt，拷贝进去已经创建好的banner即可</p><h2 id="3-springboot项目建包"><a href="#3-springboot项目建包" class="headerlink" title="3  springboot项目建包"></a>3  springboot项目建包</h2><p>​    在Application.java的同级目录下建立package。如：controller，dao，pojo，service</p><p>​    Application.java只会扫描同级目录下的包。</p><h2 id="4-将项目导出idea"><a href="#4-将项目导出idea" class="headerlink" title="4 将项目导出idea"></a>4 将项目导出idea</h2><p>​    在idea右侧找到并打开Mevan，找到lifestyle里的package，双击package，将项目打包成jar文件，命令行中输入</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span><span class="hljs-keyword">jar的绝对路径</span><br></code></pre></td></tr></table></figure><p>可运行项目</p><h1 id="2-springboot自动装配原理"><a href="#2-springboot自动装配原理" class="headerlink" title="2 springboot自动装配原理"></a>2 springboot自动装配原理</h1><h2 id="1-spring-boot-starter-parent（xml中）"><a href="#1-spring-boot-starter-parent（xml中）" class="headerlink" title="1 spring-boot-starter-parent（xml中）"></a>1 spring-boot-starter-parent（xml中）</h2><p>​    核心依赖，在父工程中（例如java包版本）</p><h2 id="2-启动器（xml中）"><a href="#2-启动器（xml中）" class="headerlink" title="2 启动器（xml中）"></a>2 启动器<dependencies>（xml中）</dependencies></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​    启动器：就是SpringBoot的应用场景</p><p>​    比如：spring-boot-starter-web，就会自动导入web环境的所有依赖</p><p>​    springboot会将所有的应用场景都变成启动器</p><p>​    要使用什么样的功能，就只需要找到对应的启动器即可 <code>starter</code></p><p>​    可以在springboot的官网的doc文档中去找springboot的启动器</p><h2 id="3-主程序（demoApplication-java中）"><a href="#3-主程序（demoApplication-java中）" class="headerlink" title="3 主程序（demoApplication.java中）"></a>3 主程序（demoApplication.java中）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chengyi;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-comment">//标注这个类是springboot的应用</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//静态方法启动springboot应用</span><br>        SpringApplication.run(Demo1Application.class, args);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>注解</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@SpringBootConfiguration</span>：springboot的配置<br><span class="hljs-variable">@Configuration</span>：代表这个类是一个spring类启动类<br>        <span class="hljs-variable">@Component</span>：还是spring的组件<br><span class="hljs-variable">@EnableAutoConfiguration</span>：自动配置类<br><span class="hljs-variable">@AutoConfigurationPackage</span>：自动配置<span class="hljs-built_in">`包注册`</span><br><span class="hljs-variable">@Import</span>(&#123;Registrar.class&#125;)：自动配置包<br>        metadata：有一个并导入了一个元数据<br>        <span class="hljs-variable">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)：自动配置导入选择<br>        List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes)：获取所有的候选配置<br><span class="hljs-variable">@ComponentScan</span><br></code></pre></td></tr></table></figure><p>META-INF&#x2F;spring.factories：核心配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title function_">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;<br>        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-built_in">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-built_in">this</span>.getBeanClassLoader());<br>        Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);<br>        <span class="hljs-keyword">return</span> configurations;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/16/SpringBoot/SpringBoot%5Cs.png"></p><p>结论：springboot的自动配置都是在启动的时候扫描并且加载的，从<code>spring.factories</code>里扫描加载。但是导入不一定生效，要判断条件是否成立，只要导入了对应的<code>start</code>，就有对应的启动器，有启动器，自动装配就会生效。</p><h1 id="3-properties文件替换成yaml文件-yaml语法"><a href="#3-properties文件替换成yaml文件-yaml语法" class="headerlink" title="3 properties文件替换成yaml文件 yaml语法"></a>3 <code>properties</code>文件替换成<code>yaml</code>文件 <code>yaml</code>语法</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#配置端口</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-comment">#存储对象</span><br><span class="hljs-attr">student:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">qiu</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">sex:</span> <span class="hljs-string">male</span><br><span class="hljs-comment">#行内写法</span><br><span class="hljs-attr">teacher:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">na</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">12</span>&#125;<br><br><span class="hljs-comment">#存储值 key-value</span><br><span class="hljs-attr">k:</span> <span class="hljs-number">3</span><br><br><span class="hljs-comment">#数组</span><br><span class="hljs-attr">pets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">dog</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pig</span><br><span class="hljs-comment">#行内写法</span><br><span class="hljs-attr">man:</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br></code></pre></td></tr></table></figure><ul><li><p><code>yaml</code>对空格要求很严格</p></li><li><p>可以存放：数组，键值对，对象</p></li><li><p>可以注入到配置类中（可以对实体类赋值）</p></li><li><p><code>yaml</code>对组件进行配置时很方便</p></li><li><p>遇到驼峰命名时加<code>-</code> (lastName&#x3D;&#x3D;last-name)</p></li></ul><h1 id="4-POJO文件夹"><a href="#4-POJO文件夹" class="headerlink" title="4 POJO文件夹"></a>4 <code>POJO</code>文件夹</h1><ul><li><p>其实就是javabeans</p></li><li><p>简单的java对象</p></li><li><p>有属性及<code>gett1er</code> <code>setter</code> 方法</p></li><li><p>不允许业务方法，<code>connection</code> 等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chengyi.pojo;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>@Value(&quot;&quot;)</code>：赋值</p><p><code>@Autowired</code>：将 Spring 容器中的 bean 自动的和我们需要这个 bean 的类组装在一起</p><p><code>@Qualifier</code>：</p><p>通过yaml来给对象赋值：<code>@ConfigurationProperties(prefix = &quot;person&quot;)</code></p><p>​    <code>prefix</code>：前缀</p><p>​    将配置文件中的每一个值，映射到这个组件当中</p><p>测试赋值结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1ApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    Person p;<br>    <span class="hljs-meta">@Autowired</span><br>    Dog d;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(p);<br>        System.out.println(d);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>jsr303验证</p><p><code>@Validated</code>：数据校验，表示下面的字段中有的字段需要进行数据校验</p><p><code>@Email(message=&quot;XXXXX&quot;)</code>：检验字段是否是Emali格式，不是则报处message</p><p>使用<code>@Email</code>需要导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.4.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>并导入class包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.hibernate.validator.constraints.Email;<br></code></pre></td></tr></table></figure></li></ul><h1 id="5-springboot-web开发整体概括"><a href="#5-springboot-web开发整体概括" class="headerlink" title="5 springboot web开发整体概括"></a>5 springboot web开发整体概括</h1><ul><li>导入静态资源</li><li>首页</li><li>jsp，模板引擎Thymeleaf</li><li>装配拓展springmvc</li><li>增删改查</li><li>拦截器</li><li>国际化</li></ul><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.resourceProperties.isAddMappings()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>        <span class="hljs-built_in">this</span>.addResourceHandler(registry, <span class="hljs-built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>            registration.addResourceLocations(<span class="hljs-built_in">this</span>.resourceProperties.getStaticLocations());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.servletContext != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">ServletContextResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextResource</span>(<span class="hljs-built_in">this</span>.servletContext, <span class="hljs-string">&quot;/&quot;</span>);<br>                registration.addResourceLocations(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>[]&#123;resource&#125;);<br>            &#125;<br><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 导入jquery包后，就可以访问对应的<code>jquery.js</code>的资源了。</p><p>在浏览器中输入<code>localhost:8081/webjars/jquery/3.6.0/jquery.js</code>，即可访问该文件</p><p>为什么上面能访问到jquery的资源？</p><p>点两下<code>shift</code>后搜索<code>WebMvcAutoConfiguration.class</code>，发现以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br></code></pre></td></tr></table></figure><p>这里对路径已经进行了设定。</p><p>代码解读：只要输入的是webjars&#x2F;阿巴阿巴，就会自动定位到：<code>classpath:/META-INF/resources/webjars/</code>，在这个目录下寻找阿巴阿巴什么的。</p><p>再去找<code>WebMvcAutoConfiguration.class</code>下的<code>ResourceProperities</code>，进去，进入到<code>ResourceProperities.class</code>里，对如下代码进行追根溯源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] getStaticLocations() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getStaticLocations();<br>&#125;<br></code></pre></td></tr></table></figure><p>点击<code>getStaticLocations</code>，进入到其父类<code>WebProperities.class</code>，再找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] getStaticLocations() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.staticLocations;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>staticLocations</code>里面，找到了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="hljs-string">&quot;classpath:/resources/&quot;</span>, <span class="hljs-string">&quot;classpath:/static/&quot;</span>, <span class="hljs-string">&quot;classpath:/public/&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>这是静态资源会自动加载的目录。</p><p>总结就是有5个地方是静态资源的目录（修改源码可以自行添加）：</p><ul><li><code>/META-INF/resources/</code>：自行创建</li><li><code>/resources/</code>：自行创建（上传的文件）</li><li><code>/static/</code>：已存在（放静态资源，比如图片，首页）</li><li><code>/public/</code>：自行创建（放公共资源，比如js文件）</li><li><code>/META-INF/resources/webjars/</code>：已存在，通过Mevan导入jar包后就可以访问</li></ul><p>访问优先级：<code>resource</code>&gt;<code>static</code>&gt;<code>public</code></p><p>然后处理静态资源的方式：</p><ul><li>webjars：<code>localhost:8080/webjars</code></li><li>public ,static,resource,&#x2F;**（根目录下）：<code>localhost:8080/</code></li></ul><h2 id="首页定制"><a href="#首页定制" class="headerlink" title="首页定制"></a>首页定制</h2><p>springboot会去静态资源目录下寻找首页<code>welcomePage</code></p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>或者通过创建一个IndexController，将index.html创建在templates下，添加模板即可。</p><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在idea里搜索<code>shift</code>点两下，搜搜<code>thymeleafProperties.class</code>，发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.html&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">checkTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">checkTemplateLocation</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.html&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">mode</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTML&quot;</span>;<br></code></pre></td></tr></table></figure><p>表示我们应该把文件建立在<code>templates</code>下</p><p>thymeleaf文档：<code>https://fanlychie.github.io/post/thymeleaf.html</code></p><p>取值交给前端静态页面的过程：</p><p>​    这是Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">(Model model)</span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello thymeleaf&quot;</span>);<span class="hljs-comment">//消息名，消息内容</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这是test.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>//取出后端传来的值<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="SpringMVC自动配置"><a href="#SpringMVC自动配置" class="headerlink" title="SpringMVC自动配置"></a><code>SpringMVC自动配置</code></h2><h3 id="官网链接："><a href="#官网链接：" class="headerlink" title="官网链接："></a>官网链接：</h3><p><code>https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</code></p><h3 id="官方文档："><a href="#官方文档：" class="headerlink" title="官方文档："></a>官方文档：</h3><p>Spring MVC Auto-configuration</p><p>Spring Boot provides auto-configuration for Spring MVC that works well with most applications.</p><p>The auto-configuration adds the following features on top of Spring’s defaults:</p><ul><li>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</li><li>Support for serving static resources, including support for WebJars (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content">later in this document</a>)).</li><li>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</li><li>Support for <code>HttpMessageConverters</code> (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-message-converters">later in this document</a>).</li><li>Automatic registration of <code>MessageCodesResolver</code> (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/htmlsingle/#boot-features-spring-message-codes">later in this document</a>).</li><li>Static <code>index.html</code> support.</li><li>Custom <code>Favicon</code> support (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-favicon">later in this document</a>).</li><li>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a href="https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-web-binding-initializer">later in this document</a>).</li></ul><p>If you want to keep those Spring Boot MVC customizations and make more <a href="https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p><p>If you want to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, and still keep the Spring Boot MVC customizations, you can declare a bean of type <code>WebMvcRegistrations</code> and use it to provide custom instances of those components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p><h3 id="视图解析器拓展"><a href="#视图解析器拓展" class="headerlink" title="视图解析器拓展"></a>视图解析器拓展</h3><ul><li>在<code>Application.java</code>同级目录下创建文件夹：<code>config</code></li><li>在config下创建<code>MyMvcConfig.java</code></li><li>类前添加注释<code>@Configuration</code></li><li><code>implements WebMvcConfigurer</code>实现接口</li><li>添加内部类<code>MyViewResolver implements ViewResolver</code>，重写<code>resolveViewName</code>方法</li><li>添加<code>@Bean</code>，写一个JavaBean，返回<code>new MyViewResolver()</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title function_">myViewResolver</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyViewResolver</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ViewResolver</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> View <span class="hljs-title function_">resolveViewName</span><span class="hljs-params">(String s, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>先写一个视图解析器（内部类）</li><li>再注册到JavaBean中去</li></ul><h3 id="视图跳转拓展"><a href="#视图跳转拓展" class="headerlink" title="视图跳转拓展"></a>视图跳转拓展</h3><p>输入：<code>qcy</code>跳转到<code>test.html</code></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>    <span class="hljs-comment">//输入qcy自动跳转到test.html</span><br>    registry.addViewController(<span class="hljs-string">&quot;/qcy&quot;</span>).setViewName(<span class="hljs-string">&quot;test&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-Web开发–员工管理系统"><a href="#6-Web开发–员工管理系统" class="headerlink" title="6 Web开发–员工管理系统"></a>6 Web开发–员工管理系统</h1><h2 id="模拟数据库"><a href="#模拟数据库" class="headerlink" title="模拟数据库"></a>模拟数据库</h2><p>在启动类下创建</p><ul><li>一个<code>pojo</code>文件夹，里面创建<code>Employee.java</code> <code>Departments.java</code> ，分别是员工类和部门类</li><li>一个<code>dao</code>文件夹，里面是<code>EmployeeDao.java</code> <code>DepartmentDao.java</code></li></ul><p>目的：模拟数据库</p><h2 id="实现首页"><a href="#实现首页" class="headerlink" title="实现首页"></a>实现首页</h2><p>在config下实现。</p><p>添加一个视图跳转拓展即可。</p><h2 id="加载首页静态资源"><a href="#加载首页静态资源" class="headerlink" title="加载首页静态资源"></a>加载首页静态资源</h2><p>将html修改成thymeleaf支持的东西。</p><ul><li>html上加命名空间 <code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></li><li>超链接，只修改本地链接，在线链接不要修改<ul><li><code>css</code>–<code>href</code> ：把css用<code>@&#123;&#125;</code>括起来，在yaml中把thymeleaf的cach关闭。（关闭缓存）</li><li><code>picture</code>–<code>src</code>：用<code>@&#123;&#125;</code>括起来</li></ul></li></ul><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><ul><li><p>resource&gt;i18n</p></li><li><p>建立<code>login.properties</code>,填写需要国际化地方</p></li><li><p>建立<code>login_zh_CN.properties</code>,填写需要国际化地方</p></li><li><p>建立<code>login_en_US.properties</code>,填写需要国际化地方</p></li><li><p><code>application.yaml</code>里设置<code>spring.messages.basename=i18n.login</code></p></li><li><p>修改对应的<code>index.html</code>，改成thymeleaf支持的格式</p></li><li><p>在<code>index.html</code>中的中英文处添加超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;</span>&gt;</span>中文<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;</span>&gt;</span>English<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打开<code>WebMvcAutoConfiguration</code>，找到相关配置：<code>localResolver</code>方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title function_">localeResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.webProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.WebProperties.LocaleResolver.FIXED) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedLocaleResolver</span>(<span class="hljs-built_in">this</span>.webProperties.getLocale());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.LocaleResolver.FIXED) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedLocaleResolver</span>(<span class="hljs-built_in">this</span>.mvcProperties.getLocale());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <br>        <span class="hljs-type">AcceptHeaderLocaleResolver</span> <span class="hljs-variable">localeResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AcceptHeaderLocaleResolver</span>();<br>        <span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.webProperties.getLocale() != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">this</span>.webProperties.getLocale() : <span class="hljs-built_in">this</span>.mvcProperties.getLocale();<br>        localeResolver.setDefaultLocale(locale);<br>        <span class="hljs-keyword">return</span> localeResolver;<br>        <span class="hljs-comment">//自动配置localResolver</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//如果用户自己在webProperities中或者mvcProperties中配置了localResolver，就用用户的</span><br><span class="hljs-comment">//否则就new一个localResolver，并返回</span><br></code></pre></td></tr></table></figure></li><li><p>进入<code>AcceptHeaderLocaleResolver</code>，发现其实现了<code>LocaleResolver</code>接口。</p></li><li><p>在<code>config</code>下创建一个<code>MyLocaleResolver</code>类实现接口并重写方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-comment">//解析http请求</span><br><span class="hljs-keyword">public</span> Locale <span class="hljs-title function_">resolveLocale</span><span class="hljs-params">(HttpServletRequest httpServletRequest)</span> &#123;<br><br><span class="hljs-comment">//请求语言参数</span><br>String language=httpServletRequest.getParameter(<span class="hljs-string">&quot;l&quot;</span>);<span class="hljs-comment">//获取参数</span><br><span class="hljs-type">Locale</span> <span class="hljs-variable">aDefault</span> <span class="hljs-operator">=</span> Locale.getDefault();<span class="hljs-comment">//如果没有就使用默认的</span><br><span class="hljs-keyword">if</span>(!StringUtils.isEmpty(language))&#123;<span class="hljs-comment">//如果有的话</span><br>String[] s = language.split(<span class="hljs-string">&quot;_&quot;</span>);<br><br>aDefault = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Locale</span>(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]);<span class="hljs-comment">//构造我们自己的，传入参数</span><br>    <br>&#125;<br><span class="hljs-keyword">return</span> aDefault;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后在MyMvcConfig下，注册到Bean中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title function_">localeResolver</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLocaleResolver</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="登录页"><a href="#登录页" class="headerlink" title="登录页"></a>登录页</h2><p>用controller实现</p><p>先修改前端</p><ul><li><p>在<code>index.html</code>中将username的值和password的值都给一个参数命名，便于传给后端</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">name=&quot;username&quot; <br>name=&quot;password&quot;<br></code></pre></td></tr></table></figure></li><li><p>在<code>index.html</code>中修改action为thymeleaf对应的格式，如下，效果是点击登录就会跳转到&#x2F;user&#x2F;login</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-signin&quot;</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/user/login&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>后端部分：</p><ul><li><p>再建立一个<code>LoginController</code>，添加<code>@Controller</code>，<code>@RequestMapping(&quot;/user/login&quot;)</code></p></li><li><p>写一个判断方法，<code>@RequestParam</code>是向前端请求参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(&quot;password&quot;)</span> String password,</span><br><span class="hljs-params">        Model model</span><br><span class="hljs-params">)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(username)&amp;&amp;password.equals(<span class="hljs-string">&quot;111&quot;</span>))&#123;<br>        <span class="hljs-comment">//登陆成功</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/main.html&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//登陆失败</span><br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;用户或者密码错误&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>输入正确转到虚拟页面<code>main.html</code>，在<code>MyMvcConfig</code>的“视图转换器”中，添加转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">registry.addViewController(<span class="hljs-string">&quot;/main.html&quot;</span>).setViewName(<span class="hljs-string">&quot;dashboard&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="登录拦截器"><a href="#登录拦截器" class="headerlink" title="登录拦截器"></a>登录拦截器</h2><ul><li><p>在登录<code>loginController</code>的方法里面添加会话参数<code>HttpSession session</code>，登陆成功后，向拦截器传参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">session.setAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>,username);<br></code></pre></td></tr></table></figure></li><li><p>在<code>config</code>下创建<code>LoginHanderInterceptor</code>实现<code>HanderInterceptor</code>接口，重写<code>preHander</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//登陆成功后，获取用户的session</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">loginUser</span> <span class="hljs-operator">=</span> request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);<br>        <span class="hljs-comment">//Session：会话</span><br>        <span class="hljs-comment">//Attribute：属性</span><br>        <span class="hljs-keyword">if</span>(loginUser==<span class="hljs-literal">null</span>)&#123;<br>            request.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;没有权限，请先登录&quot;</span>);<br>            request.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(request,response);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><span class="hljs-comment">//        return HandlerInterceptor.super.preHandle(request, response, handler);</span><br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>重载<code>MyMvcConfig</code>中的<code>addInterceptors</code>方法，添加拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginHanderInterceptor</span>()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).excludePathPatterns(<br>            <span class="hljs-string">&quot;/index.html&quot;</span>,<br>            <span class="hljs-string">&quot;/user/login&quot;</span>,<br>            <span class="hljs-string">&quot;/css/**&quot;</span>,<br>            <span class="hljs-string">&quot;/js/**&quot;</span>,<br>            <span class="hljs-string">&quot;/img/**&quot;</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2022/02/16/SpringBoot/image-20220216022025470.png" alt="image-20220216022025470"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>计网</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-性能指标"><a href="#1-性能指标" class="headerlink" title="1.性能指标"></a>1.性能指标</h2><ul><li>速率</li><li>带宽</li><li>吞吐量</li><li>时延<ul><li>传输时延 &#x2F; 发送时延</li><li>传播时延</li><li>排队时延</li><li>处理时延</li></ul></li><li>时延带宽积</li><li>往返时间RTT</li><li>利用率<ul><li>信道利用率</li><li>网络利用率</li></ul></li></ul><h2 id="2-分层结构的元素"><a href="#2-分层结构的元素" class="headerlink" title="2.分层结构的元素"></a>2.分层结构的元素</h2><ol><li><p>实体：某一层的活动元素，同一层的实体叫对等实体</p></li><li><p>协议：对等实体间进行数据交换制定的规则，包括：</p><ul><li>语法</li><li>语义</li><li>时序 &#x2F; 同步</li></ul></li><li><p>接口：层层之间还有一层接口，是上层使用下层服务的入口</p></li><li><p>服务：下层中某些功能提供给上层调用</p></li><li><p>PCI + SDU &#x3D; PDU</p><ul><li>PCI： 协议控制信息</li><li>SDU：服务数据单元</li><li>PDU：协议数据单元（最终层间传输的单元）</li></ul><p>以n层为例，n层接受到n + 1传下来的PDU，作为本层的SDU，然后n层进行打包，加上协议信息PCI，打包为PDU，发给n - 1层作为它的SDU</p></li></ol><h2 id="3-OSI"><a href="#3-OSI" class="headerlink" title="3.OSI"></a>3.OSI</h2><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220128161115359.png" alt="image-20220128161115359"></p><ul><li><p>应用层：用户的页面</p></li><li><p>表示层：数据格式的转换，数据加密，数据的压缩及恢复</p></li><li><p>会话层：</p><ul><li>实体间建立连接及有序传输数据</li><li>使用校验点，在通信失效的时候从校验点重新开始</li></ul></li><li><p>传输层</p><ul><li>可靠 &#x2F; 不可靠传输</li><li>差错控制</li><li>流量控制</li><li>复用<ul><li>多个应用层进程可同时使用传输层的服务 – 复用</li><li>传输层会接收到所有进程的消息，然后分别发给对应的进程 – 分用</li></ul></li></ul></li><li><p>网络层：数据包 &#x2F; 分组</p><ul><li>路由选择</li><li>流量控制</li><li>拥塞控制</li><li>差错控制</li></ul></li><li><p>数据链路层：数据帧</p><ul><li>封装数据帧</li><li>差错控制：位错 &#x2F; 帧错</li><li>流量控制</li><li>接入控制：控制对信道的访问</li></ul></li><li><p>物理层：比特流，透明传输：无论收到什么样的数据帧，都能作为比特流，然后转化成电信号在介质中传播</p><ul><li>定义接口特性：比如接口有多少根引脚</li><li>定义传输模式：单工，半双工，双工</li><li>定义传输速率</li><li>比特同步</li><li>比特编码：曼彻斯特编码等等</li></ul></li></ul><p>​    上四层是e2e通信（进程），下三层是p2p通信（结点）</p><h2 id="4-TCP-x2F-IP-模型"><a href="#4-TCP-x2F-IP-模型" class="headerlink" title="4.TCP &#x2F; IP 模型"></a>4.TCP &#x2F; IP 模型</h2><ul><li>应用层</li><li>传输层</li><li>网际层</li><li>网络接口层</li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220130095908613.png" alt="image-20220130095908613"></p><h2 id="5-5层参考模型"><a href="#5-5层参考模型" class="headerlink" title="5.5层参考模型"></a>5.5层参考模型</h2><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220130100154087.png" alt="image-20220130100154087"></p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220130100308960.png" alt="image-20220130100308960"></p><h1 id="2-物理层（傻瓜层）"><a href="#2-物理层（傻瓜层）" class="headerlink" title="2.物理层（傻瓜层）"></a>2.物理层（傻瓜层）</h1><p>​    了解上层基础和下层建筑。</p><p>​    物理层主要是确定传输介质接口的标准，而不是定义传输介质。</p><p>​    有人将传输介质称作第零层，也有道理。</p><h2 id="1-通信分类"><a href="#1-通信分类" class="headerlink" title="1.通信分类"></a>1.通信分类</h2><p>​    通信模型：信源 – 调制解调器（发送，调制） – 信道 – 调制解调器（接收，解调） – 信宿</p><h3 id="1-通信方式"><a href="#1-通信方式" class="headerlink" title="1.通信方式"></a>1.通信方式</h3><ul><li>单工 – 广播</li><li>半双工 – 对讲机</li><li>双工 – 电话</li></ul><p>​    明确的是，信道是有方向的，可以看作是矢量。</p><h3 id="2-传输方式"><a href="#2-传输方式" class="headerlink" title="2.传输方式"></a>2.传输方式</h3><ul><li>串行传输：一条信道，一个byte的8个bit由低到高依次发送<ul><li>特性：速度低，费用低，适合远距离</li></ul></li><li>并行传输：八条信道，每个信道传输一位<ul><li>特性：速度高，费用高，适合近距离</li><li>例子：计算机内部部件的信息传输</li></ul></li></ul><h3 id="3-同步方式"><a href="#3-同步方式" class="headerlink" title="3.同步方式"></a>3.同步方式</h3><ul><li>同步：同步传输时，数据是以数据区块作为一个整体发送的，数据区块前面要加上同步字符SYN，作为收发端之间的同步时钟。</li><li>异步：将数据比特分为几个比特组，然后发送方会在传送数据之前给比特组加上起始位和终止位，发送端可以在任意时刻发送数据。</li></ul><p>​    同步和异步最终都是为了对收发的数据进行同步，最终得到完整不失真的数据。</p><p>​    同步的话，收发必须进行严格的校准，当接收方没接收到时，发送方不能继续发。而异步，发送方直接发就行了，不用关心接收方接收到没有。</p><p>​    类似于QQ的在线传文件和发送离线文件</p><h2 id="2-数字通信性能指标"><a href="#2-数字通信性能指标" class="headerlink" title="2.数字通信性能指标"></a>2.数字通信性能指标</h2><h3 id="1-码元"><a href="#1-码元" class="headerlink" title="1.码元"></a>1.码元</h3><p>​    一个码元可以携带多个比特信息。</p><p>​    码元是通过一定固定时长的信号波形来代表不同离散数值（0 &#x2F; 1）的基本波形。</p><p>​    二进制码元可以携带 0 &#x2F; 1，所以可以携带一个bit。</p><p>​    四进制码元，可以携带四个状态，00 &#x2F; 01 &#x2F; 10 &#x2F; 11，所以可以携带2bits</p><p>​    16进制码元，携带4bits</p><p>​    M进制码元，可以携带log2M个bits</p><h3 id="2-码元速率"><a href="#2-码元速率" class="headerlink" title="2.码元速率"></a>2.码元速率</h3><p>​    单位时间发送码元个数，单位是bote，Baud，B</p><h3 id="3-信息速率"><a href="#3-信息速率" class="headerlink" title="3.信息速率"></a>3.信息速率</h3><p>​    别名比特速率，比特率，表示单位时间传输的二进制码元的个数，单位bit&#x2F;s</p><h3 id="4-带宽"><a href="#4-带宽" class="headerlink" title="4.带宽"></a>4.带宽</h3><p>​    模拟带宽：高频与低频之间的差值，界限是功率为最大功率的一半</p><p>​    数字带宽：一点到另一点能通过的最高数据率，单位bps，b &#x2F; s</p><h2 id="3-奈氏准则-amp-amp-香农定理"><a href="#3-奈氏准则-amp-amp-香农定理" class="headerlink" title="3.奈氏准则 &amp;&amp; 香农定理"></a>3.奈氏准则 &amp;&amp; 香农定理</h2><p>​    信噪比：信噪比（db） &#x3D; 10log10（S&#x2F;N），S是信道平均功率，N是信道内噪声功率</p><ul><li>奈：理想低通情况下（无噪声），为避免码间串扰，码元极限传输速率是2W baud，W是信道带宽，单位hz</li><li>香：带宽受限且有噪声情况下，信息速率有上限，值为：Wlog2（1 + S&#x2F;N）</li></ul><p>​    奈奎斯特是在理想情况，无噪声的时候使用。香农则是在有噪声的时候使用。</p><h2 id="4-编码-amp-amp-调制"><a href="#4-编码-amp-amp-调制" class="headerlink" title="4.编码 &amp;&amp; 调制"></a>4.编码 &amp;&amp; 调制</h2><p>​    基带信号 &amp; 宽带信号</p><p>​    基带信号是直接将0101这种原始数字信号进行传输，传输信道是数字信道。</p><p>​    宽带信号是将基带信号进行调制后，再频分复用的信号，传输信道是模拟信道。</p><p>​    距离较近时使用基带信号传输，这样衰减小；距离较远的时候，就是使用宽带信号传输。</p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131173207400.png" alt="image-20220131173207400"></p><h3 id="1-数字数据-–-数字信号"><a href="#1-数字数据-–-数字信号" class="headerlink" title="1.数字数据 – 数字信号"></a>1.数字数据 – 数字信号</h3><ul><li><p>非归零编码（NRZ）：高1低0</p><ul><li>缺点：无开始结束，接收方无法判断，所以不好同步</li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131173650920.png" alt="image-20220131173650920"></p></li><li><p>归零编码（RZ）：在一个码元内需要归零。</p><ul><li>缺点：信道利用率低，0太多了，并且同步没解决</li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131173830468.png" alt="image-20220131173830468"></p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131173843015.png" alt="image-20220131173843015"></p></li><li><p>反向不归零编码（NRZI）：电平反转0，反之1</p><ul><li>缺点：数据全1的话，无法判断</li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131174255181.png" alt="image-20220131174255181"></p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131174302733.png" alt="image-20220131174302733"></p></li><li><p>曼彻斯特编码：将码元分成两部分，前高后低表示1，前低后高表示0，也可以反过来。</p><ul><li>缺点：数据传输速度是调制速率的二分之一</li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131174849899.png" alt="image-20220131174849899"></p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131174858911.png" alt="image-20220131174858911"></p></li><li><p>差分曼彻斯特编码：若码元为1，则前半个码元脉冲，与前一个码元的后半脉冲相同。反之相反</p><ul><li>优点：抗干扰能力优于曼彻斯特编码。</li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131180434222.png" alt="image-20220131180434222"></p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131180441467.png" alt="image-20220131180441467"></p></li><li><p>4B &#x2F; 5B编码：编码效率百分之80</p></li></ul><h3 id="2-数字数据-–-模拟信号"><a href="#2-数字数据-–-模拟信号" class="headerlink" title="2.数字数据 – 模拟信号"></a>2.数字数据 – 模拟信号</h3><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131182344549.png" alt="image-20220131182344549"></p><h3 id="3-模拟信号–-数字信号"><a href="#3-模拟信号–-数字信号" class="headerlink" title="3.模拟信号– 数字信号"></a>3.模拟信号– 数字信号</h3><p>​    采样 – 量化 – 编码</p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131183011631.png" alt="image-20220131183011631"></p><h3 id="4-模拟数据-–-模拟信号"><a href="#4-模拟数据-–-模拟信号" class="headerlink" title="4.模拟数据 – 模拟信号"></a>4.模拟数据 – 模拟信号</h3><p>​    低频 – 高频，采用频分复用</p><h2 id="5-数据交换方式"><a href="#5-数据交换方式" class="headerlink" title="5.数据交换方式"></a>5.数据交换方式</h2><p>​    局域网交换机，广域网路由器。</p><p>​    <img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131184129161.png" alt="image-20220131184129161"></p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131184329262.png" alt="image-20220131184329262"></p><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h3><p>​    用一条物理线路直接连接俩条通信设备，线路占有率为100%，连接始终open</p><p>​    具体步骤：建立连接（呼叫） – 通信 – 释放电路（拆除）</p><p>​    通信是全双工的</p><p>​    适用于大量的数据传输</p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131184915419.png" alt="image-20220131184915419"></p><h3 id="2-报文交换"><a href="#2-报文交换" class="headerlink" title="2.报文交换"></a>2.报文交换</h3><p>​    不需要在两个结点之间专门建立一条线路，单位是报文，采用的方式是：存储转发</p><ul><li>优点：存储转发，不独占资源，存储后交换设备会对报文进行检查查看是否出错</li><li>缺点：共享带宽</li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131185918907.png" alt="image-20220131185918907"></p><h3 id="3-分组交换"><a href="#3-分组交换" class="headerlink" title="3.分组交换"></a>3.分组交换</h3><p>​    与报文交换略有不同，传输单位是分组。源节点把数据发送过来后，交换设备会将数据切分成一个个的小分组。</p><p>​    一般每个分组的大小是128B</p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131190505122.png" alt="image-20220131190505122"></p><h4 id="1-数据包交换"><a href="#1-数据包交换" class="headerlink" title="1.数据包交换"></a>1.数据包交换</h4><h4 id="2-虚电路交换"><a href="#2-虚电路交换" class="headerlink" title="2.虚电路交换"></a>2.虚电路交换</h4><h3 id="4-如何选择"><a href="#4-如何选择" class="headerlink" title="4.如何选择"></a>4.如何选择</h3><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131190720267.png" alt="image-20220131190720267"></p><h2 id="6-物理层传输媒介"><a href="#6-物理层传输媒介" class="headerlink" title="6.物理层传输媒介"></a>6.物理层传输媒介</h2><ul><li><p>导向性传输介质 – 电磁波沿着固体介质传播</p><ul><li><p>双绞线 – 便宜</p></li><li><p>同轴电缆 – 优于双绞线</p></li><li><p>光纤 – 带宽大，损耗低，传输距离远</p><ul><li>单模光纤 – 远距离</li><li>多模光纤 – 近距离</li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131194222033.png" alt="image-20220131194222033"></p></li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131194712214.png" alt="image-20220131194712214"></p></li><li><p>非导向性传输介质 – 空气，真空，海水等</p><ul><li>无线电波：所有方向</li><li>微波：单一方向</li><li>红外线，单一方向</li></ul></li></ul><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131195135629.png" alt="image-20220131195135629"></p><h2 id="7-物理层设备"><a href="#7-物理层设备" class="headerlink" title="7.物理层设备"></a>7.物理层设备</h2><h3 id="1-中继器"><a href="#1-中继器" class="headerlink" title="1.中继器"></a>1.中继器</h3><p>​    对中途损耗的信号进行再生和还原，对衰减的信号进行放大</p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131202431114.png" alt="image-20220131202431114"></p><h3 id="2-集线器（多口中继器）"><a href="#2-集线器（多口中继器）" class="headerlink" title="2.集线器（多口中继器）"></a>2.集线器（多口中继器）</h3><p>​    功能和集线器一样，但是有多个端口，也就是多播（广播形式）。</p><p>​    集线器也是傻瓜设备，不仅不能存储数据，而且不支持并发，会有冲突。如果两个端口同时向一个端口发送数据，那么会失败，然后这两个端口会在随机时间后重试，知道不冲突为止</p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220131203205867.png" alt="image-20220131203205867"></p><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h1><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220201150714322.png" alt="image-20220201150714322"></p><p>​    链路层的功能：</p><ul><li>给网络层提供服务：无确认无连接，有确认无连接，有确认有连接</li><li>链路管理 –&gt; 连接的建立，维持，释放</li><li>组帧</li><li>流量控制</li><li>差错控制 –&gt; 位错 &#x2F; 帧错</li></ul><h2 id="1-组帧-amp-透明传输"><a href="#1-组帧-amp-透明传输" class="headerlink" title="1.组帧 &amp; 透明传输"></a>1.组帧 &amp; 透明传输</h2><p>测试：</p><p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220214130405104.png" alt="image-20220214130405104"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-自顶向下</title>
    <link href="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"/>
    <url>/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1 应用层"></a>1 应用层</h1><h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h2><h3 id="C-S："><a href="#C-S：" class="headerlink" title="C/S："></a><code>C/S</code>：</h3><p>不对等架构</p><ul><li>拓展性：差，要解决高并发，网络问题</li><li>可靠性：过度依赖服务器</li></ul><h3 id="P2P："><a href="#P2P：" class="headerlink" title="P2P："></a><code>P2P</code>：</h3><p>对等架构</p><ul><li>管理困难：结点上线，下线不稳定</li></ul><h3 id="混合："><a href="#混合：" class="headerlink" title="混合："></a><code>混合</code>：</h3><p>既有一个大服务器，同时又有每个节点，结点可以作为小服务器或者客户端</p><ul><li>服务器：管理所有上线用户<code>ip</code>，分发给结点。</li><li>结点：向服务器请求目标<code>ip</code>，选择跟这个<code>ip</code>连接，同时向服务器注册自己的<code>ip</code></li></ul><p>混合架构就是<code>C/S</code>里面套接<code>P2P</code>，既有两者的优点，也将缺点小化了。</p><h2 id="1-2-通信"><a href="#1-2-通信" class="headerlink" title="1.2 通信"></a>1.2 通信</h2><ul><li><p>不同端系统之间的网络进程，依靠网络通信，遵守相关协议。</p><p>任何一个用进程可以用端结点来标识，有一个<code>SAP</code>标识：</p><ul><li>主机<code>IP</code></li><li><code>TCP/UDP</code></li><li><code>port</code></li></ul><p>层间接口（稍底层），必须携带的信息：</p><ul><li>传输报文<code>SDU</code></li><li>发送者：<code>IP+TCP/UDP+port</code></li><li>接收者：<code>IP+TCP/UDP+port</code></li></ul><p><code>TCP Socket</code>：源IP+源Port+目标IP+目标Port。四元组。</p><p>发送：</p><ul><li>TCP Socket+报文</li></ul><p><code>UDP Socket</code>：源IP+源Port。二元组</p><p>发送：</p><ul><li>UDP Socket+报文+(目标IP+目标Port)</li></ul></li><li><p>同一端系统进程间通信，通过操作系统的：管道，消息队列，缓冲区等</p></li></ul><p>协议：应用进程之间通信的约束（语法，语义，规则），只跟网络相关。</p><p>应用实体：在某一层，和网络交互有关的，遵守协议的部分，叫做这一层的实体。在这个过程中需要实现协议的一些操作，是非实体。</p><p>应用层需要传输层提供什么样的服务：</p><ul><li>数据丢失率</li><li>延迟</li><li>吞吐</li><li>安全性<ul><li>机密性</li><li>完整性</li><li>可认证性</li></ul></li></ul><h2 id="1-3-HTTP"><a href="#1-3-HTTP" class="headerlink" title="1.3 HTTP"></a>1.3 <code>HTTP</code></h2><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><ul><li><p>web页：本身是对象，里面又嵌入了一些对象（的链接）</p></li><li><p>URL：统一资源定位器</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">Port:<span class="hljs-regexp">//u</span>ser:psw@www.xxx.edu<span class="hljs-regexp">/path/</span>pic.gif:port<br>协议名 用户 口令 主机名 路径 文件 端口<br></code></pre></td></tr></table></figure></li><li><p>匿名访问：不需要口令</p></li><li><p>HTTP默认端口：80</p></li><li><p>FTP默认端口：21</p></li></ul><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><ul><li><p>跑在TCP上</p></li><li><p>服务器客户端连接过程</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>.服务器有一个守候socket（<span class="hljs-keyword">waiting </span>socket）<span class="hljs-built_in">s1</span>，在服务器xxxip的<span class="hljs-number">80</span>端口，等待连接建立请求<br><span class="hljs-number">2</span>.web向服务器发送TCP请求，要求建立连接<br><span class="hljs-number">3</span>.服务器响应，允许建立连接，并返回一个socket <span class="hljs-built_in">s2</span>，代表web与server的会话关系<br><span class="hljs-number">4</span>.s1，<span class="hljs-built_in">s2</span>，<span class="hljs-built_in">s3</span>都守护在对应的<span class="hljs-number">80</span>端口，但<span class="hljs-built_in">s1</span>是守候socket，<span class="hljs-built_in">s2</span>，<span class="hljs-built_in">s3</span>是连接socket<br></code></pre></td></tr></table></figure></li></ul><h3 id="非持久HTTP（1-0）"><a href="#非持久HTTP（1-0）" class="headerlink" title="非持久HTTP（1.0）"></a>非持久HTTP（1.0）</h3><ul><li>TCP连接–TCP确认</li><li>HTTP请求–HTTP确认（返回对象，时间较长）</li><li>TCP关闭–关闭</li></ul><h3 id="持久HTTP（1-1）"><a href="#持久HTTP（1-1）" class="headerlink" title="持久HTTP（1.1）"></a>持久HTTP（1.1）</h3><ul><li>TCP请求–TCP确认</li><li>HTTP请求–HTTP确认（返回对象）</li><li>–等待，不关闭</li></ul><h3 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a>响应时间模型</h3><p>请求确认RTT：一次往返加小分组传输时间，因为分组字节数较小，所以通常忽略，只计算往返时间</p><h4 id="非持久HTTP"><a href="#非持久HTTP" class="headerlink" title="非持久HTTP"></a>非持久HTTP</h4><ul><li>TCP的RTT</li><li>HTTP的RTT</li><li>文件传输时间</li><li>总时间：2RTT+文件传输时间</li></ul><p>在非持久HTTP中，一个对象的时间：2RTT+文件传输时间</p><h4 id="持久HTTP"><a href="#持久HTTP" class="headerlink" title="持久HTTP"></a>持久HTTP</h4><h5 id="非流水线HTTP（同步-串行）"><a href="#非流水线HTTP（同步-串行）" class="headerlink" title="非流水线HTTP（同步,串行）"></a>非流水线HTTP（同步,串行）</h5><ul><li>TCP</li><li>HTTP</li><li>文件1</li><li>文件2</li></ul><h5 id="流水线HTTP（异步，并行）"><a href="#流水线HTTP（异步，并行）" class="headerlink" title="流水线HTTP（异步，并行）"></a>流水线HTTP（异步，并行）</h5><ul><li>TCP</li><li>HTTP</li><li>文件1+文件2+…</li></ul><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><ul><li>两种报文：请求+响应</li><li>ANCII码，人能阅读</li><li>GET：server向服务器请求</li><li>POST：上载</li><li>HEAD：只要HTML的head，搜索引擎建立索引或者维护</li></ul><h3 id="HTTP状态码："><a href="#HTTP状态码：" class="headerlink" title="HTTP状态码："></a>HTTP状态码：</h3><p>​    常用：</p><ul><li>200：ok</li><li>301：资源已被转移</li><li>404：页面不存在</li><li>500：内部服务器错误</li></ul><p>​    全部：</p><table><thead><tr><th>100</th><th>Continue</th><th>继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</th></tr></thead><tbody><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h3 id="cookie，有状态的HTTP"><a href="#cookie，有状态的HTTP" class="headerlink" title="cookie，有状态的HTTP"></a>cookie，有状态的HTTP</h3><ul><li>client第一次访问server，HTTP报文中不携带cookie</li><li>server给client分配cookie，保存到数据库，并在响应报文中返回cookie</li><li>client接收到cookie，存入本地操作系统。</li><li>client后续访问。请求报文中会携带本地的cookie</li><li>server将接收到的cookie与数据库中的cookie对比，得到用户历史</li></ul><h3 id="web缓存（代理服务器）"><a href="#web缓存（代理服务器）" class="headerlink" title="web缓存（代理服务器）"></a>web缓存（代理服务器）</h3><ul><li>c向s发出HTTP请求，首先到代理服务器。</li><li>代理服务器检查，没有发现对象，发送给origin server</li><li>origin server给出响应，返回给代理，代理将对象保存</li><li>代理返回对象给c</li><li>c第二次向s请求相同的对象，经过代理服务器。</li><li>代理服务器保有此对象，该对象被命中，代理返回对象给c</li></ul><p>优点：</p><p>​    1.客户端快，请求响应时间短</p><p>​    2.服务器端压力小，负载轻</p><p>​    3.减小网络拥堵</p><p>二八原则</p><p>​    很小的缓存，但可以满足很多用户访问。</p><h2 id="1-4-FTP"><a href="#1-4-FTP" class="headerlink" title="1.4 FTP"></a>1.4 <code>FTP</code></h2><ul><li>c与s使用tcp，与21号端口建立连接</li><li>c通过控制连接来获得身份确认</li><li>c通过控制连接连续发送命令浏览目录</li><li>收到文件传输命令时，s与c的20号端口进行数据连接（另外一个TCP连接）</li><li>文件传输结束，s关闭连接</li></ul><p>控制连接21端口：发送命令</p><p>数据连接20端口：传输数据</p><h2 id="1-5-Email"><a href="#1-5-Email" class="headerlink" title="1.5 Email"></a>1.5 <code>Email</code></h2><p>发送协议（push）：SMTP</p><p>接收协议（pop）：HTTP，pop3，IMAP</p><p>跑在TCP上</p><ul><li>用户代理：outlook，qqmail，发送给邮件服务器（SMTP）</li><li>邮件服务器：运行在25号端口</li><li>邮件服务器将接收的邮件放进队列里</li><li>邮件服务器将邮件发送给其它邮件服务器，放在用户的邮箱里</li><li>目标用户，使用用户代理将邮件从对应的邮件服务器的邮箱中取出来（pop3协议，HTTP，IMAP，60端口）</li></ul><h2 id="1-6-DNS"><a href="#1-6-DNS" class="headerlink" title="1.6 DNS"></a>1.6 <code>DNS</code></h2><p>域名解析系统：DNS是给其它应用应用的应用</p><p>其它应用访问web，通过DNS这个基础设施，来成功访问到server。</p><p>用户输入域名，DNS完成域名到ip地址的转换。</p><p>分布式解析，区域DNS</p><h3 id="DNS的问题："><a href="#DNS的问题：" class="headerlink" title="DNS的问题："></a>DNS的问题：</h3><ul><li>如何命名设备</li><li>如何完成域名到ip地址的转化</li><li>如何维护：增加域名&#x2F;子域名，删除…</li></ul><h3 id="DNS的思路："><a href="#DNS的思路：" class="headerlink" title="DNS的思路："></a>DNS的思路：</h3><ul><li>分层的命名</li><li>分布式的数据库</li><li>UDP的53号端口</li><li>是web的核心功能，但不在核心实现，在边缘实现。由此可见web最复杂的其实是边缘。</li></ul><h3 id="DNS的功能："><a href="#DNS的功能：" class="headerlink" title="DNS的功能："></a>DNS的功能：</h3><ul><li>主机名到IP的转换</li><li><ul><li>主机别名到规范名字的转换</li><li>邮件服务器别名到邮件服务器正规名字的转换</li><li>负载均衡（多个子服务器提供服务），分治的思想。</li></ul></li></ul><h3 id="DNS命名空间："><a href="#DNS命名空间：" class="headerlink" title="DNS命名空间："></a>DNS命名空间：</h3><ul><li><ul><li>国家：.cn    .us    .jp（国家的顶级域）</li><li>通用：.com（很多公司的顶级域）  .edu  .gov</li></ul></li><li>二级域</li><li>三级域</li><li>…</li></ul><p>DNS命名就是一个很多个个倒着生长的树，树根是顶级域，顶级域分为国家的和通用的。</p><h3 id="DNS根名字服务器："><a href="#DNS根名字服务器：" class="headerlink" title="DNS根名字服务器："></a>DNS根名字服务器：</h3><p>13个名字服务器。查询的时候选择任何一个树根开始往下查阅，这样更稳定。</p><h2 id="1-7-P2P"><a href="#1-7-P2P" class="headerlink" title="1.7 P2P"></a>1.7 <code>P2P</code></h2><h2 id="1-8-CDN"><a href="#1-8-CDN" class="headerlink" title="1.8 CDN"></a>1.8 <code>CDN</code></h2><h2 id="1-9-TCP"><a href="#1-9-TCP" class="headerlink" title="1.9 TCP"></a>1.9 <code>TCP</code></h2><p>可靠数据传输。</p><ul><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：网络拥堵时抑制发送方</li><li>不能提供的服务：时间保证，最小吞吐保证，安全性</li><li>面向连接：要求C&#x2F;S建立连接</li></ul><h2 id="1-10-UDP"><a href="#1-10-UDP" class="headerlink" title="1.10 UDP"></a>1.10 <code>UDP</code></h2><p>不可靠数据传输。</p><ul><li>不提供的服务：可靠，流量控制，拥塞控制，时间，带宽保证，建立连接</li><li>优点：简单，延时低</li></ul><h2 id="1-11-SSL"><a href="#1-11-SSL" class="headerlink" title="1.11 SSL"></a>1.11 <code>SSL</code></h2><p>TCP&#x2F;UDP都没有加密，都是明文传输。</p><p>SSL建立在TCP上，提供加密的TCP连接</p><p>SSL在应用层。</p><ul><li>私密性</li><li>数据完整性</li><li>端到端的鉴别（认证）</li></ul><p><code>https</code>开头的网站是跑在SSL协议上，再往下是TCP，是安全的</p><p><code>http</code>则跑在TCP上，明文传输，不安全</p><h1 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2.传输层"></a>2.传输层</h1><h2 id="2-1-多路复用解复用"><a href="#2-1-多路复用解复用" class="headerlink" title="2.1 多路复用解复用"></a>2.1 多路复用解复用</h2><p>​    传输层向应用层提供服务；网络层向传输层提供服务。传输层和应用层是进程–进程（或是线程）通信。网络层则是端系统–端系统通信。</p><p>​    多个应用程序把socket+报文（+目标&lt;ip,port&gt;二元组）向下交给传输层。传输层在报文前面加上源port，目标port的段，形成传输层的TCP字节流或者是UDP数据报。传输层再向下交给ip层，ip层在报文前面加上源ip，目标ip，形成ip数据报。再统一向下交，将多个ip数据报发出。–复用</p><p>​    经过网络核心到接收端，再依次向上交。一方面丢掉头部的ip，port信息，得到message；另一方面根据ip，port找到对应的进程。–解复用</p><h2 id="2-2-UDP"><a href="#2-2-UDP" class="headerlink" title="2.2 UDP"></a>2.2 UDP</h2><p>​    UDP是不可靠传输，但它在ip的基础上，优化了：进程–进程；差错检验功能。</p><p>​    差错检验，注意溢出回卷还有取反码部分。</p><h2 id="2-3-RDT"><a href="#2-3-RDT" class="headerlink" title="2.3 RDT"></a>2.3 RDT</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>操作系统</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h2><p>​    定义：位于用户层和底层硬件之间的一层，目的是：</p><ul><li>1.管理底层的硬件资源，协调硬件的资源，使得不同的部分组合在一起拥有更强大的功能。<ul><li>文件管理</li><li>内存管理</li><li>进程管理</li><li>设备管理</li></ul></li><li>2.提供给用户&#x2F;程序员接口：<ul><li>用户：<ul><li>GUI – 图形界面</li><li>命令接口<ul><li>cmd：联机命令接口</li><li>bat文件：脱机命令接口</li></ul></li></ul></li><li>程序员：系统调用</li></ul></li></ul><h2 id="1-2操作系统的特征"><a href="#1-2操作系统的特征" class="headerlink" title="1.2操作系统的特征"></a>1.2操作系统的特征</h2><p>​    四个特性：</p><ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步</li></ul><p>​    其中并发和共享是基础。</p><p>​    区分两个概念：</p><ul><li>并发：多个程序交替执行，是时分复用的思想</li><li>并行：多个程序同时执行</li></ul><h2 id="1-3操作系统的分类"><a href="#1-3操作系统的分类" class="headerlink" title="1.3操作系统的分类"></a>1.3操作系统的分类</h2><p>​    大致分一下几个阶段：</p><ul><li>手工操作机器：写纸袋 – 输入纸袋 – 读取纸袋 – 计算 –  写出纸袋 – 输出纸袋 – 取纸袋。缺点是利用率太低了，各个阶段，无论是cpu还是io</li><li>批处理阶段<ul><li>单道批处理系统：类似于bat文件，将程序直接写好，用外围机将纸袋转换成磁带 ，然后用户输入磁带，等待机器计算完后输出磁带。具体的不住：输入磁带 – 计算 – 输出磁带。利用的技术是：脱机输入输出技术。也有缺点，资源利用率低，cpu计算时io是空闲的。</li><li>多道批处理系统：利用了流水线技术。缺点：无人机交互功能，一旦提交程序就无法修改或输入参数</li></ul></li><li>分时操作系统：时间片轮转为用户提供作业，用户可通过终端与计算机进行交互。缺点是OS太公平了，没有优先级之分，没人得到的任务时间都是一样的，无法处理紧急任务</li><li>实时操作系统:<ul><li>硬实时操作系统：导弹发射 – 严格执行，对ddl的要求很严格</li><li>软实时操作系统：订火车票 – 偶尔违反</li></ul></li><li>其它：网络操作系统，分布式操作系统，个人操作系统</li></ul><h2 id="1-4操作系统的运行机制"><a href="#1-4操作系统的运行机制" class="headerlink" title="1.4操作系统的运行机制"></a>1.4操作系统的运行机制</h2><p>​    <img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212094555081.png" alt="image-20220212094555081"></p><h2 id="1-5中断和异常"><a href="#1-5中断和异常" class="headerlink" title="1.5中断和异常"></a>1.5中断和异常</h2><p>​    中断是唯一一种内核夺回cpu控制权的途径</p><p>​    中断分类：</p><ul><li>内中断：中断与当前执行的指令有关，也称为异常<ul><li>产生内中断的方式：执行非法的用户指令或参数非法，执行陷入指令（请求系统调用的时候会进行）</li></ul></li><li>外中断：与当前执行的指令无关<ul><li>产生外中断的方式：时钟中断（并发的实现），io中断（打印机打印完成）</li></ul></li></ul><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212112201718.png" alt="image-20220212112201718"></p><h2 id="1-6系统调用与函数"><a href="#1-6系统调用与函数" class="headerlink" title="1.6系统调用与函数"></a>1.6系统调用与函数</h2><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212113442182.png" alt="image-20220212113442182"></p><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212113701444.png" alt="image-20220212113701444"></p><p>​    系统调用能更好的去管理资源，因为很多资源的请求都是有条件的，共享也是在互斥的条件下才能共享的。</p><p>​    库函数是暴露给上层程序员的接口，而系统调用则是某些库函数在进行资源请求时的接口。</p><p>​    系统调用的过程：</p><ul><li>用户态：应用程序向寄存器中传入参数，指明想要那种系统调用</li><li>用户态：应用程序执行陷入指令，由用户态切换内核态</li><li>内核态：运行系统调用入口程序，检查寄存器中的参数，准备运行相对应的系统调用</li><li>内核态：运行响应的系统调用程序</li><li>用户态：返回用户态</li></ul><p>​    陷入指令 &#x3D; trap指令 &#x3D; 访管指令</p><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220212225124372.png" alt="image-20220212225124372"></p><h2 id="1-7操作系统体系结构"><a href="#1-7操作系统体系结构" class="headerlink" title="1.7操作系统体系结构"></a>1.7操作系统体系结构</h2><ul><li>大内核 &#x2F; 单内核 &#x2F; 宏内核</li><li>微内核</li></ul><p>微内核和大内核的一个比较重要的区别：微内核向OS请求服务需要经过6次状态改变，而大内核只需要经过2次状态改变</p><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213123547242.png" alt="image-20220213123547242"></p><p>​    所以微内核的性能比较低，但是内核维护的资源少一点</p><h1 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2.进程管理"></a>2.进程管理</h1><h2 id="1-进程-amp-程序-amp-进程实体"><a href="#1-进程-amp-程序-amp-进程实体" class="headerlink" title="1.进程 &amp; 程序 &amp; 进程实体"></a>1.进程 &amp; 程序 &amp; 进程实体</h2><p>​    概念 – 组成 – 特征</p><p>​    进程和程序的区别：</p><ul><li>程序：是我们写死的，一系列的指令的集和，表示为一个可执行文件，是静态的</li><li>进程：是程序的一次执行，是动态的</li></ul><p>​    进程的组成：</p><ul><li>PCB（程序管理块）：OS管理用的</li><li>程序段：进程自己用的，程序代码</li><li>数据段：进程自己用的，程序运行产生的数据</li></ul><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213132126787.png" alt="image-20220213132126787"></p><p>​    进程是程序的一次执行，是动态的，而进程实体，是在某一时刻进程的状态，包括PCB，程序段，数据段，这是静态的。</p><p>​    于是可以给进程下定义：进程是进程实体的整个运行过程，是系统进行资源分配与调度的基本单位</p><p>​    进程还有一些特征，不记录了</p><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213135040011.png" alt="image-20220213135040011"></p><h2 id="2-进程的状态与转换"><a href="#2-进程的状态与转换" class="headerlink" title="2.进程的状态与转换"></a>2.进程的状态与转换</h2><p>​    可以分为以下状态：</p><ul><li>创建状态：创建PCB，分配资源</li><li>就绪状态：资源1，处理机（CPU）0</li><li>运行状态：资源1，处理机1</li><li>阻塞状态：资源0，处理机0</li><li>终止状态：资源回收</li></ul><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213144610261.png" alt="image-20220213144610261"></p><p>​    进程的管理有两种方法，一是队列的形式（指针），二是索引的形式</p><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213144600005.png" alt="image-20220213144600005"></p><h2 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3.进程控制"></a>3.进程控制</h2><p>​    进程控制的工作：创建进程，撤销进程，进程状态转换。</p><p>​    用原语实现</p><p>​    原语的 原子性如何实现：通过“开 &#x2F; 关中断指令”。一旦执行了关中断指令，系统就不会去响应中断信号了。类似中断屏蔽机制。</p><h3 id="1-创建进程的原语"><a href="#1-创建进程的原语" class="headerlink" title="1.创建进程的原语"></a>1.创建进程的原语</h3><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213160142949.png" alt="image-20220213160142949"></p><h3 id="2-撤销进程的原语"><a href="#2-撤销进程的原语" class="headerlink" title="2.撤销进程的原语"></a>2.撤销进程的原语</h3><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213160229617.png" alt="image-20220213160229617"></p><h3 id="3-阻塞-x2F-唤醒进程的原语"><a href="#3-阻塞-x2F-唤醒进程的原语" class="headerlink" title="3.阻塞 &#x2F; 唤醒进程的原语"></a>3.阻塞 &#x2F; 唤醒进程的原语</h3><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213160431015.png" alt="image-20220213160431015"></p><h3 id="4-切换进程原语"><a href="#4-切换进程原语" class="headerlink" title="4.切换进程原语"></a>4.切换进程原语</h3><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213161125817.png" alt="image-20220213161125817"></p><h2 id="4-进程通信"><a href="#4-进程通信" class="headerlink" title="4.进程通信"></a>4.进程通信</h2><p>​    通过：共享存储，消息传递，管道通信实现</p><h3 id="1-共享存储"><a href="#1-共享存储" class="headerlink" title="1.共享存储"></a>1.共享存储</h3><p>​    进程之间的内存地址是只能有自己访问的。要想进程通信，可以再开辟一个单独的空间，归通信的进程所有，细分为两类。</p><ul><li>共享数据结构：只能存放一种特定的数据结构，通信慢，低级</li><li>共享存储区：在内存中单独分配一份空间，数据的类型，存放的位置由应用程序决定，不由OS决定，高速，高级</li></ul><p>​    无论哪种，进程对共享内存的访问都需要是互斥的</p><h3 id="2-管道通信"><a href="#2-管道通信" class="headerlink" title="2.管道通信"></a>2.管道通信</h3><p>​    以下几点：</p><ul><li>互斥访问</li><li>一个pipe只能半双工，要实现双工需要两个pipe</li><li>写满了会阻塞，只有写满了才能读，pipe不空不许写</li><li>最多一个进程读</li></ul><h3 id="3-消息传递"><a href="#3-消息传递" class="headerlink" title="3.消息传递"></a>3.消息传递</h3><ul><li>直接通信：直接将消息体加上消息头打包发出，然后OS给到对应进程的消息队列中去</li><li>间接通信（邮箱）：类似于web邮箱</li></ul><h2 id="5-线程"><a href="#5-线程" class="headerlink" title="5.线程"></a>5.线程</h2><h3 id="1-引入多线程"><a href="#1-引入多线程" class="headerlink" title="1.引入多线程"></a>1.引入多线程</h3><p>​    进程的出现是为了增加系统的并发度。多线程出现后，线程成为了系统调度的基本单位，进程只用于资源分配</p><p>​    线程和进程类似，有TCB（thread control block），TID（thread id）</p><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213203126361.png" alt="image-20220213203126361"></p><p>​    多线程引入后，相同进程的线程切换，开销少；不同进程的线程切换，开销依然大。</p><h3 id="2-线程的实现"><a href="#2-线程的实现" class="headerlink" title="2.线程的实现"></a>2.线程的实现</h3><ul><li>用户级线程（ULT）：用户自己来实现，并不由OS调度，通过app &amp; 线程库来对线程进行调度。<ul><li>优点：开销少，无需状态的切换</li><li>缺点：只能并发不能并行。并且单核多核一个样，因为核的调度单位是线程。然后若是碰上阻塞，那就阻塞了。</li></ul></li><li>内核级线程（kernel-level thread）：OS可以看到的线程，由OS调度<ul><li>优点：并发高，就算某线程阻塞了，可以通过内核的调度，去执行其它的线程</li><li>缺点：开销高，切换线程需要对应状态的改变。</li></ul></li></ul><h3 id="3-多线程模型"><a href="#3-多线程模型" class="headerlink" title="3.多线程模型"></a>3.多线程模型</h3><ul><li>一对一：一个用户级对应一个内核级</li></ul><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213213321140.png" alt="image-20220213213321140"></p><ul><li>多对一：多个用户级对应一个内核级，通过引入线程库实现。通过牺牲并发性来提高效率，一旦被阻塞就会over</li></ul><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213213205942.png" alt="image-20220213213205942"></p><ul><li>多对多（n : m）：n个用户及对应m个内核级，其中n&gt;&#x3D;m，这样就算某一个用户级线程被阻塞，其他用户线程也不会被阻塞。</li></ul><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213213144911.png" alt="image-20220213213144911"></p><p>​    总览：</p><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220213213547855.png" alt="image-20220213213547855"></p><h2 id="6-处理机调度"><a href="#6-处理机调度" class="headerlink" title="6.处理机调度"></a>6.处理机调度</h2><h3 id="1-作业"><a href="#1-作业" class="headerlink" title="1.作业"></a>1.作业</h3><p>​    作业就是任务。</p><p>​    当我们向OS提交一个作业，就是让OS启动一个程序。</p><p>​    三种调度方式。</p><h3 id="2-高级调度"><a href="#2-高级调度" class="headerlink" title="2.高级调度"></a>2.高级调度</h3><p>​    又称作业调度。</p><p>​    我们进行一个作业时，需要把程序从外存加载到内存，这个时候，首先将程序添加到外存 的<strong>准备队列（后备队列）</strong>中去进行排队，然后再按照<strong>调度算法</strong>将队列中的程序加载到内存，并且创建进程。</p><p>​    作业调入内存时会创建一次PCB，调出内存时撤销PCB。调入调出操作只执行一次</p><h3 id="3-低级调度"><a href="#3-低级调度" class="headerlink" title="3.低级调度"></a>3.低级调度</h3><p>​    又称进程调度 &#x2F; 处理机调度</p><p>​    前面的高级调度一般是在程序运行前。而低级调度是程序已经启动，操作对象是正在运行的进程 &#x2F; 进程实体。</p><p>​    具体是，根据<strong>调度算法</strong>选取进程就绪队列中的某一个进程，然后将CPU分配给它。</p><p>​    进程调度的使用频率很高，几十毫秒一次，是实现并发的关键。</p><h3 id="4-中级调度"><a href="#4-中级调度" class="headerlink" title="4.中级调度"></a>4.中级调度</h3><p>​    又称外内存调度。</p><p>​    引用场景是当OS发现内存不够了，会将后台暂时没有运行的进程挂到外存中去。被挂起的进程的PCB会形成挂起队列。等到要运行时OS再根据<strong>调度算法</strong>将队列中的PCB还回来，并且分配处理机。</p><p>​    中级调度发生的频率也比高级调度高。</p><h3 id="5-进程的7状态模型-amp-5状态模型对比"><a href="#5-进程的7状态模型-amp-5状态模型对比" class="headerlink" title="5.进程的7状态模型 &amp;5状态模型对比"></a>5.进程的7状态模型 &amp;5状态模型对比</h3><h4 id="7状态"><a href="#7状态" class="headerlink" title="7状态"></a>7状态</h4><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220214152243194.png" alt="image-20220214152243194"></p><h4 id="5状态"><a href="#5状态" class="headerlink" title="5状态"></a>5状态</h4><p><img src="/2022/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220214152418712.png" alt="image-20220214152418712"></p><h3 id="6-调度总结"><a href="#6-调度总结" class="headerlink" title="6.调度总结"></a>6.调度总结</h3><ul><li>高级调度：作业调度，频率低，外存 –&gt; 内存</li><li>低级调度：进程调度，频率高，内存 –&gt; CPU</li><li>中级调度：内存调度，频率中，内存 &lt; – &gt; 外存</li></ul><h2 id="7-进程调度详解"><a href="#7-进程调度详解" class="headerlink" title="7.进程调度详解"></a>7.进程调度详解</h2><h3 id="1-进程调度的时机"><a href="#1-进程调度的时机" class="headerlink" title="1.进程调度的时机"></a>1.进程调度的时机</h3><h4 id="1-需要进行进程调度的情况"><a href="#1-需要进行进程调度的情况" class="headerlink" title="1.需要进行进程调度的情况"></a>1.需要进行进程调度的情况</h4><ul><li>主动放弃CPU：<ul><li>进程正常终止</li><li>运行产生异常</li><li>io阻塞</li></ul></li><li>被动放弃CPU：<ul><li>时钟（时间片用完了）</li><li>更紧急的事件需要处理</li><li>更高优先级的进程进入就绪队列等待</li></ul></li></ul><h4 id="2-不能进行进程调度的情况"><a href="#2-不能进行进程调度的情况" class="headerlink" title="2.不能进行进程调度的情况"></a>2.不能进行进程调度的情况</h4><ul><li>处理中断</li><li>进程在操作系统内核程序临界区</li><li>原语（原子操作）</li></ul><p>​    临界资源：指一个时间段之内，只允许一个进程访问的资源。也就是需要互斥访问的资源。</p><p>​    临界区：访问临界资源的那一段代码。当访问临界资源时，代码会对临界资源进行上锁，确保其它进程不能同时访问临界资源；当进程离开临界区后，会对临界资源解锁。</p><p>​    内核临界区：一般是访问内核的某一个数据结构的代码，比如就绪队列。</p><p>​    所以，在内核资源临界区时不能进程调度，在普通临界区时是可以进程调度。考虑下面两个例子：</p><ul><li>进程在对内核中的队列进行操作（就绪队列，阻塞队列，阻塞挂起队列，就绪挂起队列）时，如果此时进行进程调度，夺取cpu，那么新来的进程要想进行工作，肯定也要对队列进行操作，如果是同一个队列，那么上锁了就产生了死锁。</li><li>进程等待打印机打印完成时，打印机时临界资源，也需要上锁。但是这时就可以进行进程调度了，因为不调度会空转cpu，调度的话也不会影响内核的工作，所以是ok的</li></ul><p>​    所以能否进行进程调度，关键问题还是之前的工作是否会对调度后的工作产生影响。（中断的话是在内核进行的，而原语也是内核的部分服务）</p><p>​    有的OS只能进程主动放弃CPU，有的OS会强制要求进程放弃CPU</p><h3 id="2-进程调度的方式"><a href="#2-进程调度的方式" class="headerlink" title="2.进程调度的方式"></a>2.进程调度的方式</h3><p>​    分为非剥夺调度方式和剥夺调度方式。</p><ul><li>非剥夺调度方式：非抢占式，只能进程自己放弃cpu，这种实现简单，开销少，但无法处理紧急任务。适合于批处理系统</li><li>剥夺调度方式：抢占式，可以由内核剥夺os，如果有优先级更高的或者时间片用完了。适合于分时，实时操作系统。</li></ul><h3 id="3-进程切换和进程调度"><a href="#3-进程切换和进程调度" class="headerlink" title="3.进程切换和进程调度"></a>3.进程切换和进程调度</h3><p>​    三个概念：</p><ul><li>进程切换：一个进程让出cpu，另一个进程得到cpu，注意，；俩进程不同</li><li>狭义进程调度：从就绪队列中选出一个进程，将cpu给到它。注意，这个进程可以是新的进程，也可以是原来被剥夺cpu的进程</li><li>广义进程调度：剥夺进程a的cpu，从就绪队列中选择一个进程b，将cpu赋予b</li></ul><p>​    进程切换的工作：</p><ul><li>保存剥夺cpu进程的pcb</li><li>恢复赋予cpu进程的pcb</li></ul><p>​    pcb中包含程序状态字，计数器，还有各种寄存器的信息。</p><p>​    从上看来，进程调度还是很有代价的。如果过于频繁的切换进程的话，系统的效率会下降。</p><h2 id="8-调度算法的性能指标"><a href="#8-调度算法的性能指标" class="headerlink" title="8.调度算法的性能指标"></a>8.调度算法的性能指标</h2><h3 id="1-cpu利用率"><a href="#1-cpu利用率" class="headerlink" title="1.cpu利用率"></a>1.cpu利用率</h3><p>​    计算：忙碌时间➗总运行时间</p><p>​    io设备的利用率也是这样算的。</p><h3 id="2-系统吞吐量"><a href="#2-系统吞吐量" class="headerlink" title="2.系统吞吐量"></a>2.系统吞吐量</h3><p>​    定义：单位时间完成作业的数量。</p><p>​    计算：总共完成多少道作业➗总花费时间</p><h3 id="3-周转时间"><a href="#3-周转时间" class="headerlink" title="3.周转时间"></a>3.周转时间</h3><p>​    定义：作业被提交到系统开始，到完成作业为止的时间。</p><p>​    计算：作业完成时间 - 作业提交时间</p><p>​    平均值计算：作业周转时间之和 ➗ 作业数</p><p>​    注意，周转时间包含了等待的时间在里面。</p><p>​    我们引出了带权周转时间：</p><p>​    计算：作业周转时间 ➗ 作业实际运行时间，注意，这个值大于等于1，越接近1对用户而言体验越好。</p><p>​    也有平均带权周转时间，计算类似前面。</p><h3 id="4-等待时间"><a href="#4-等待时间" class="headerlink" title="4.等待时间"></a>4.等待时间</h3><p>​    定义：作业等待处理机所消耗的时间。注意！这里严格的来讲不能将处理机视作cpu，因为处理机既可以是cpu核心，也可以是io设备，如打印机等。</p><p>​    这对进程和作业而言是两种计算：</p><ul><li>进程：指的是进程被建立后，从进入就绪队列开始，到进程结束，等待处理机服务的总时间。包括在就绪队列的时间，但不包括等待io的时间。如进程等待打印机打印，进程实际是被打印机服务的，所以不算等待时间。</li><li>作业：除了进程的等待时间，还要算上作业在从外存加入内存前，在后备队列上等待高级调度（作业调度）的时间。</li></ul><h3 id="5-响应时间"><a href="#5-响应时间" class="headerlink" title="5.响应时间"></a>5.响应时间</h3><p>​    定义：用户从首次提交请求到首次得到响应的时间，算作一次响应时间。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust-lang</title>
    <link href="/2022/02/14/rust-lang/"/>
    <url>/2022/02/14/rust-lang/</url>
    
    <content type="html"><![CDATA[<h1 id="0-基本操作"><a href="#0-基本操作" class="headerlink" title="0.基本操作"></a>0.基本操作</h1><h2 id="1-使用Clion开发Rust"><a href="#1-使用Clion开发Rust" class="headerlink" title="1.使用Clion开发Rust"></a>1.使用Clion开发Rust</h2><p>​    需要在系统的path里添加clion的bin路径，然后就可以通过命令行使用clion .来打开项目了。</p><h2 id="2-使用cargo创建库项目"><a href="#2-使用cargo创建库项目" class="headerlink" title="2.使用cargo创建库项目"></a>2.使用cargo创建库项目</h2><p>​    cargo new add –lib</p><h2 id="3-打印地址"><a href="#3-打印地址" class="headerlink" title="3.打印地址"></a>3.打印地址</h2><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">o</span> = Obj::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">adr</span> = &amp;o <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> Obj <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;0x&#123;:x&#125;&quot;</span>, adr);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Obj</span> &#123;<br>    val1: <span class="hljs-type">u8</span>,<br>    val2: <span class="hljs-type">u8</span>,<br>    val3: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Obj</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(v1: <span class="hljs-type">u8</span>, v2: <span class="hljs-type">u8</span>, v3: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> Obj &#123;<br>        Obj &#123;<br>            val1: v1,<br>            val2: v2,<br>            val3: v3,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="1-rust简介"><a href="#1-rust简介" class="headerlink" title="1 rust简介"></a>1 rust简介</h1><h2 id="1-1-基本特性"><a href="#1-1-基本特性" class="headerlink" title="1.1 基本特性"></a>1.1 基本特性</h2><p>特性</p><ul><li><p>运行时速度快</p></li><li><p>内存安全</p></li><li><p>并发</p><p>  rust是一门安全的语言，表现在类型安全和内存安全（横向对比c&#x2F;c++），同时性能也很好，因为没有GC（对比java），同时在设计的时候就考虑了多核处理器，支持并发，火狐公司的一个内核就是用rust写的，全并发执行。</p><p>  rust采的命名方法是：蛇形命名法，也就是字母小写单词之间加下划线</p><p>  rust的命令有rustc和rustup，rustc后面的c的意思是编译器。</p></li></ul><h2 id="1-2-命令行-vscode构建项目"><a href="#1-2-命令行-vscode构建项目" class="headerlink" title="1.2 命令行+vscode构建项目"></a>1.2 命令行+vscode构建项目</h2><p>步骤</p><ul><li>mkdir hello_rust创建工程目录</li><li>cd h*进入目录</li><li>code .用vscode打开该工程</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">常用的windows cmd命令<br><span class="hljs-number">1</span>. cd / -<span class="hljs-punctuation">-&gt;</span> 进入首盘，如c盘d盘<br><span class="hljs-number">2</span>. cd .. -<span class="hljs-punctuation">-&gt;</span> 进入上一级目录<br><span class="hljs-number">3</span>. dir -<span class="hljs-punctuation">-&gt;</span> 查看当当前目录下的文件 dir /a 是查看所有文件，包括隐藏文件<br><span class="hljs-number">4</span>. 可以用help cd查看cd的用法<br></code></pre></td></tr></table></figure><h2 id="1-3-编写hello-world程序"><a href="#1-3-编写hello-world程序" class="headerlink" title="1.3 编写hello world程序"></a>1.3 编写hello world程序</h2><ul><li>fn表示函数声明</li><li>rust采用的缩进不是tab，而是四个空格</li><li>println!是rust的宏，也就是rust micro</li><li>rust是预先编译的语言，也就是先编译好，然后生成二进制文件，可直接交给别人使用，而无需rust环境</li><li>rustc只适用于简单的rust文件，用cargo</li></ul><h2 id="1-4-cargo创建工程"><a href="#1-4-cargo创建工程" class="headerlink" title="1.4 cargo创建工程"></a>1.4 cargo创建工程</h2><div class="code-wrapper"><pre><code class="hljs">cargo是rust的创建及包管理工具rust里代码的包称为crate</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">windows cmd<br><span class="hljs-number">1</span>.rmdir xxx -- remove dir<br><span class="hljs-number">2</span>.del xxx -- delete file<br></code></pre></td></tr></table></figure><p>cargo.toml文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.toml是cargo的配置文件<br><span class="hljs-number">2</span>.前一部分是项目的信息，如项目名称，package，版本信息作者等<br><span class="hljs-number">3</span>.后部分是项目依赖<br></code></pre></td></tr></table></figure><p>顶层目录可放置的信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.README文件<br><span class="hljs-number">2</span>.许可信息<br><span class="hljs-number">3</span>.配置文件<br><span class="hljs-number">4</span>.其它与源程序无关的东西<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">当没有用cargo创建工程时，可以直接把文件拷贝到src下，然后再在顶层目录下编写一个cargo.toml文件即可</code></pre></div><p>cargo.lock</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.负责追寻项目依赖的准确版本<br><span class="hljs-number">2</span>.不需要去修改这个文件<br></code></pre></td></tr></table></figure><p>使用cargo运行项目</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>.cargo run会编译当前工程的main.rs及相关文件，然后再运行生成的exe文件<br><span class="hljs-number">2</span>.如果源代码没有更改过的话，就不编译了，之既然运行exe<br></code></pre></td></tr></table></figure><p>cargo check调试检查项目</p><div class="code-wrapper"><pre><code class="hljs">一般在开发的时候都是用的这个命令来进行检查调试，因为更快。只有要生成文件的时候才会使用run/build指令如果要发布的话，使用cargo build --release，这样编译的时候时间更久，会进行优化，提高编译出来的程序的性能</code></pre></div><br><h1 id="2-rust基本语法"><a href="#2-rust基本语法" class="headerlink" title="2 rust基本语法"></a>2 rust基本语法</h1><h2 id="2-1-获取控制台输入"><a href="#2-1-获取控制台输入" class="headerlink" title="2.1 获取控制台输入"></a>2.1 获取控制台输入</h2><h3 id="1-输入"><a href="#1-输入" class="headerlink" title="1.输入"></a>1.输入</h3><div class="code-wrapper"><pre><code class="hljs">std里提供了一个io，也就是标准输入输出，然后io里有一个关联函数叫stdin，是io里关于输入输出的输入那一部分，会返回一个句柄。然后stdin里有一个方法是read_line，读取命令行中的一行，这个方法可能抛出异常，所以该有一个except函数。read_line会返回一个io::Result类型，也就是枚举类型，有两个值，一个是OK，另一个是Err，如果返回Err的话，就会中断当前程序，执行except那一部分。</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">std::io::stdin.<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> string).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;exception message&quot;</span>);<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">关联函数类似于java中的静态方法。</code></pre></div><h3 id="2-输出"><a href="#2-输出" class="headerlink" title="2.输出"></a>2.输出</h3><div class="code-wrapper"><pre><code class="hljs">println!宏</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;这是一个数字：&#123;&#125;&quot;</span>, number);<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">&#123;&#125;中的就是number。</code></pre></div><h2 id="2-2-添加外部依赖包rand（修改toml文件）"><a href="#2-2-添加外部依赖包rand（修改toml文件）" class="headerlink" title="2.2 添加外部依赖包rand（修改toml文件）"></a>2.2 添加外部依赖包rand（修改toml文件）</h2><div class="code-wrapper"><pre><code class="hljs">在cargo.toml中添加bin结点。</code></pre></div><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;guess_game&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang/.org/cargo/reference/manifest.html</span><br><span class="hljs-comment"># 下面的部分是添加的代码，其中name是你的项目名称</span><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;guess_game&quot;</span><br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;src/test.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">rand</span> = <span class="hljs-string">&quot;0.5.0&quot;</span><br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">然后cargo就会自动下载依赖包了。为什么会自动下载包？其实，是因为打开了rust server，这样就会自动去扫描toml里的依赖，检查版本并且及时下载对应的版本。如果我们关闭这个server，那么更新toml中的依赖，工程文件中的包并不会更新，因为工程文件会去lock文件中去找到并使用对应的版本。这个时候不仅要修改toml，还要进行生级，也就是输入指令：cargo update。但事实上使用这个指令需要换源，因为直接用的话，会提示超时，因为下载的源好像是github，需要用steam++加速或者换源。</code></pre></div><h2 id="2-3-使用枚举进行比较"><a href="#2-3-使用枚举进行比较" class="headerlink" title="2.3 使用枚举进行比较"></a>2.3 使用枚举进行比较</h2><div class="code-wrapper"><pre><code class="hljs">进行比较需要用到std下的cmp中的Ordering这个枚举类型。</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br></code></pre></td></tr></table></figure><div class="code-wrapper"><pre><code class="hljs">进行枚举时需要注意一下两个问题：</code></pre></div><ul><li>类型一致</li><li>使用时大小等都得写全</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num2</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">match</span> num1.<span class="hljs-title function_ invoke__">cmp</span>(&amp;num2) &#123;<br>    Ordering::Equal =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;=&quot;</span>),<br>    Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt;&quot;</span>),<br>    Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&lt;&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-处理异常"><a href="#2-4-处理异常" class="headerlink" title="2.4 处理异常"></a>2.4 处理异常</h2><div class="code-wrapper"><pre><code class="hljs">前面我们使用的是except方法来处理异常，如parse将字符串转换成数字时，会返回一个Result，根据这个类型是OK还是Err来判断是否执行except中的内容。如果Result中判定为Err的话，会直接中断当前程序，然后程序结束（崩溃）。这样我们的程序一遇到非法输入就崩溃，并不健壮。所以这里我们用了上一节中的match模式匹配来处理这个问题。如果是OK的话，就执行ok的代码块，如果是Rrr的话再做相应的应对措施（如提示用户重新输入）</code></pre></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> num.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>    <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is not valid input, try again&quot;</span>, num.<span class="hljs-title function_ invoke__">trim</span>());<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;,<br>&#125;; <span class="hljs-comment">//将字符串转为u32类型，无符号整数32位</span><br></code></pre></td></tr></table></figure><h1 id="3-变量及控制流"><a href="#3-变量及控制流" class="headerlink" title="3 变量及控制流"></a>3 变量及控制流</h1><h2 id="3-1变量"><a href="#3-1变量" class="headerlink" title="3.1变量"></a>3.1变量</h2><h3 id="3-1-1-不可变变量"><a href="#3-1-1-不可变变量" class="headerlink" title="3.1.1 不可变变量"></a>3.1.1 不可变变量</h3><p>​    使用let关键字声明，将等号右边的值绑定到等号左侧。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = -<span class="hljs-number">1</span>;<br><span class="hljs-comment">// num = 2;错误，不可变变量无法二次绑定</span><br></code></pre></td></tr></table></figure><h3 id="3-1-2-可变变量"><a href="#3-1-2-可变变量" class="headerlink" title="3.1.2 可变变量"></a>3.1.2 可变变量</h3><p>​    mutable，可变化的，还是使用let声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">1</span>;<br>num = num + <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h3 id="3-1-3-常量"><a href="#3-1-3-常量" class="headerlink" title="3.1.3 常量"></a>3.1.3 常量</h3><p>​        常量用const声明（constant的意思），常量必须显式声明数据类型，无法自动推断。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> MAX_LEN: <span class="hljs-type">u8</span> = <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure><p>​    其实工程中大多数都是不可变类型的变量。</p><h2 id="3-2-shadow机制"><a href="#3-2-shadow机制" class="headerlink" title="3.2 shadow机制"></a>3.2 shadow机制</h2><p>​    变量可以被隐藏。如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-string">&quot;ssss&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = string.<span class="hljs-title function_ invoke__">len</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = string + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;string is &#123;&#125;&quot;</span>, string);<br></code></pre></td></tr></table></figure><p>​    此机制是为了避免以下情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name_string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jack&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">name_length</span> <span class="hljs-operator">=</span> name_string.length();<br></code></pre></td></tr></table></figure><h2 id="3-3-标量类型"><a href="#3-3-标量类型" class="headerlink" title="3.3 标量类型"></a>3.3 标量类型</h2><h3 id="3-3-1-整数"><a href="#3-3-1-整数" class="headerlink" title="3.3.1 整数"></a>3.3.1 整数</h3><p>​    整数的类型：</p><p>​                                                     <img src="/2022/02/14/rust-lang/image-20220114153100948.png" alt="image-20220114153100948"></p><p>​    其中isize和usize和机器的位数有关，一般不用。</p><p>​    整数的字面量表示：</p><p><img src="/2022/02/14/rust-lang/image-20220114153226641.png" alt="image-20220114153226641"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">adr</span> = <span class="hljs-number">0x1234_5678u64</span><span class="hljs-comment">//无符号64位16进制数</span><br></code></pre></td></tr></table></figure><p>​    整数的默认类型一般是i32，比较快。    </p><p>​    下面是整数溢出的情况：</p><ul><li>调试模式下：会发生panic（恐慌）</li><li>发布模式：不发生panic，选择环绕操作，即256&#x3D;0</li></ul><h3 id="3-3-2-浮点"><a href="#3-3-2-浮点" class="headerlink" title="3.3.2 浮点"></a>3.3.2 浮点</h3><p>​    两种类型：</p><ul><li>f64</li><li>f32</li></ul><p>​    一般是采用f64</p><h3 id="3-3-3-bool类型"><a href="#3-3-3-bool类型" class="headerlink" title="3.3.3 bool类型"></a>3.3.3 bool类型</h3><p>​    true或者false。</p><p>​    占用大小一个Byte</p><p>​    为什么不用一个bit？因为如果用一位的话不利于存储，会产生内存碎片。</p><h3 id="3-3-4-字符类型"><a href="#3-3-4-字符类型" class="headerlink" title="3.3.4 字符类型"></a>3.3.4 字符类型</h3><p>​    char</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">yeye</span> = &#x27;👴&#x27;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, yeye);<br></code></pre></td></tr></table></figure><h2 id="3-4-复合类型"><a href="#3-4-复合类型" class="headerlink" title="3.4 复合类型"></a>3.4 复合类型</h2><h3 id="3-4-1-元组Tuple"><a href="#3-4-1-元组Tuple" class="headerlink" title="3.4.1 元组Tuple"></a>3.4.1 元组Tuple</h3><p>​    每个位置对应一个类型，类型不必相同。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tp</span> = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, tp.<span class="hljs-number">0</span>, tp.<span class="hljs-number">1</span>, tp.<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>​    元组赋值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tp</span> = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>);<br><span class="hljs-comment">// println!(&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;, tp.0, tp.1, tp.2);</span><br><span class="hljs-keyword">let</span> (x, y, z) = tp;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, x, y, z);<br></code></pre></td></tr></table></figure><h3 id="3-4-2-数组"><a href="#3-4-2-数组" class="headerlink" title="3.4.2 数组"></a>3.4.2 数组</h3><p>​    和其他语言类似</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h3 id="3-4-5-Vector"><a href="#3-4-5-Vector" class="headerlink" title="3.4.5 Vector"></a>3.4.5 Vector</h3><p>​    大小可变，用的更多。</p><h2 id="3-5-函数"><a href="#3-5-函数" class="headerlink" title="3.5 函数"></a>3.5 函数</h2><p>​    函数声明，函数名，参数列表，返回值。这是声明函数的全过程。</p><p>​    代码块里的最后一行没加分号，代表是返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">32</span>, <span class="hljs-number">2</span>))<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    x + y<br>&#125;<br></code></pre></td></tr></table></figure><p>​    或者这样也行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-if-else"><a href="#3-6-if-else" class="headerlink" title="3.6 if-else"></a>3.6 if-else</h2><p>​    第一种用法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">if</span> cdt &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure><p>​    第二种：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>;<br><span class="hljs-keyword">if</span> cdt &#123;<br>    num = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure><p>​    如果ifelse嵌套太多，使用模式匹配吧。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cdt</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">match</span> cdt &#123;<br>    <span class="hljs-literal">true</span> =&gt; <span class="hljs-number">1</span>,<br>    <span class="hljs-literal">false</span> =&gt; <span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure><h2 id="3-7-循环"><a href="#3-7-循环" class="headerlink" title="3.7 循环"></a>3.7 循环</h2><h3 id="3-7-1-loop"><a href="#3-7-1-loop" class="headerlink" title="3.7.1 loop"></a>3.7.1 loop</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">loop</span> &#123;<br>    count = count + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, count);<br>    <span class="hljs-keyword">if</span> count &gt;<span class="hljs-number">100</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7-2-while"><a href="#3-7-2-while" class="headerlink" title="3.7.2 while"></a>3.7.2 while</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">100</span> &#123;<br>    count = count + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-7-3-for-each"><a href="#3-7-3-for-each" class="headerlink" title="3.7.3 for - each"></a>3.7.3 for - each</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> arr &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> arr.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure><p>60s倒计时</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">e</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">61</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-所有权"><a href="#4-所有权" class="headerlink" title="4 所有权"></a>4 所有权</h1><p>​    rust采用所有权系统来管理内存。并且，是在编译时检查，这样就不会减慢程序运行的速度。无运行时开销。</p><p><img src="/2022/02/14/rust-lang/image-20220114182046202.png" alt="image-20220114182046202"></p><h2 id="4-1-栈内存与堆内存"><a href="#4-1-栈内存与堆内存" class="headerlink" title="4.1 栈内存与堆内存"></a>4.1 栈内存与堆内存</h2><ul><li>堆栈：LIFO，last in first out，后进先出</li><li>堆：OS给用户在heap上找到一块足够大的区域，标记为在用，然后返回给用户。这就是在堆上分配内存。</li></ul><p><img src="/2022/02/14/rust-lang/image-20220114181038063.png" alt="image-20220114181038063"></p><p>​    堆是通过分配来得到内存，而栈不同，栈是直接将数据存放到那一个格子就行了，不需要分配。</p><p>​    栈上分配的内存是固定不变的，如数组。而堆上分配的内存可以动态变化，也就是可变数组，像C语言里的动态内存分配，就是在堆上分配空间，然后返回一个指针给用户（malloc函数返回指针）。而这个指针由于是固定大小，所以可以存到栈上去。</p><p>​    在堆上分配空间更慢，因为OS需要找到一块足够大的空间。而在栈上就比较快了，因为这个空间肯定在栈的顶端。</p><p>​    在堆上访问数据也慢，因为需要通过指针寻址来访问，是间接访问，需要跳转，从栈-&gt;堆，比较慢；而从栈上访问数据就不一样了，因为是栈-&gt;栈，所以快。</p><p><img src="/2022/02/14/rust-lang/image-20220114181940185.png" alt="image-20220114181940185"></p><h2 id="4-2-所有权规则"><a href="#4-2-所有权规则" class="headerlink" title="4.2 所有权规则"></a>4.2 所有权规则</h2><p><img src="/2022/02/14/rust-lang/image-20220114182405990.png" alt="image-20220114182405990"></p><p>​    简化：在一个时间内，每个值有且只有一个变量，并且当所有者超出作用域时，所有者及其值将被删除。</p><h2 id="4-3-初识String"><a href="#4-3-初识String" class="headerlink" title="4.3 初识String"></a>4.3 初识String</h2><p>​    之前的标量数据类型都是存储在stack上的，一旦离开作用域就会被弹出。</p><p>​    而String是一种存放在heap上的数据类型。    </p><p>​    String可以代表std中复杂的数据类型，或者是我们自己创建的数据类型。</p><p>​    在程序运行中，有两种字符串：</p><ul><li>字符串字面量：是不可变的。在程序运行之前，即在编译期间，就可以知道其内容了，所以直接硬编码到可执行文件中了。所以在运行期间就不需要额外的内存了，高效。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">//hello就是一个字符串字面量</span><br></code></pre></td></tr></table></figure><ul><li>String类型：可变的，如获取用户的输入是，是不可预知的，用的就是String。String是在运行期间才会在heap上分配内存，通过from函数向OS申请内存。然后变变量超出作用域后，救会通过drop函数回收内存（自动的）。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//从字符串字面量创建一个String类型</span><br></code></pre></td></tr></table></figure><p>​    下面解释一段程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br></code></pre></td></tr></table></figure><p>​    第一行向heap申请了一块内存。具体是如下：在堆上申请了一块空间，存放hello字符数组，然后返回这个字符数组的三个信息：起始地址，长度，容量。返回给s1接收。</p><p><img src="/2022/02/14/rust-lang/image-20220115132259157.png" alt="image-20220115132259157"></p><p>​    第二行是将s1的指针考培给了s2，包括heap指针，len和capacity。然后按照常规的思路，s1 s2都离开作用域时，都会进行drop回收内存。这样一块heap内存被回收了两次，是不安全的。</p><p>​    为了解决这个，在将s1指针拷贝给了s2后，也就是MOVE操作后，s1的内容被废弃，再次调用将出现报错。然后s1s2离开作用域后，只有s2指向的heap会被drop掉。</p><p><img src="/2022/02/14/rust-lang/image-20220115132743008.png" alt="image-20220115132743008"></p><p><img src="/2022/02/14/rust-lang/image-20220115132811413.png" alt="image-20220115132811413"></p><p>​    这样无疑更安全，也不会在堆上重新分配空间。</p><p>​    以上其实是一种浅拷贝，然是由于s1时失效了，于是创建了新的术语叫MOVE。</p><ul><li>浅拷贝 – MOVE移动</li><li>深拷贝 – CLONE克隆</li></ul><p>​    Rust所有的操作都是廉价的浅拷贝操作，不会开辟新的heap内存，除非是这样要求的。</p><p>​    下面的深拷贝，即克隆的操作。</p><p><img src="/2022/02/14/rust-lang/image-20220115133335999.png" alt="image-20220115133335999"></p><p><img src="/2022/02/14/rust-lang/image-20220115133353197.png" alt="image-20220115133353197"></p><p>​    而在栈上进行的MOVE，先前声明的变量就不会失效。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">//useful</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x; <span class="hljs-comment">//useful</span><br></code></pre></td></tr></table></figure><p>​    可以用下面两个概念来解释：</p><ul><li>Copy trait（复制特性）：实现了Copy trait的数据结构，在赋值后旧的变量仍然有效。</li><li>Drop trait（回收特性）：实现了Drop trait的数据结构，不能再实现Copy trait</li></ul><p><img src="/2022/02/14/rust-lang/image-20220115134031494.png" alt="image-20220115134031494"></p><h2 id="4-4-函数与所有权"><a href="#4-4-函数与所有权" class="headerlink" title="4.4 函数与所有权"></a>4.4 函数与所有权</h2><p>​    将值窜给函数，要么会发生移动（Move），要么发生复制（Copy）</p><p><img src="/2022/02/14/rust-lang/image-20220115135319262.png" alt="image-20220115135319262"></p><ul><li>copy trait的数据类型被传入时（i32）：传进去的时副本，在函数结束的时候，副本会被弹出stack</li><li>drop trait数据类型被传入时（String）：传进去后，旧的变量丧失所有权，回收时不再使用drop清理heap内存。传进去的数据获得所有权，在函数结束时弹出堆栈并且使用drop回收堆内存</li></ul><p>​    如果想即使用所有权，还能返回回来的话，可以使用元组</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> (s1, len) = <span class="hljs-title function_ invoke__">get_len</span>(s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;   &#123;&#125;&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_len</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>, <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br>    (s, l)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-引用"><a href="#4-5-引用" class="headerlink" title="4.5 引用"></a>4.5 引用</h2><p>​    引用：引用数据的值而不使用其所有权。&amp;符号表示</p><p><img src="/2022/02/14/rust-lang/image-20220115140318148.png" alt="image-20220115140318148"></p><p>引用分类：</p><ul><li>不可变引用：不能修改指向堆上的数据</li><li>可变引用：可以修改指向堆上的数据</li><li>悬空引用：引用指向的数据已经被释放，而引用依然有效（Rust在编译期杜绝了这个问题）</li></ul><p><img src="/2022/02/14/rust-lang/image-20220115141807954.png" alt="image-20220115141807954"></p><p>​    有以下规则： </p><ul><li>一个作用域内只能有一个可变引用</li><li>一个作用域内可以有多个不可变引用</li><li>同一个作用域内可变引用与不可变引用不能同时存在</li></ul><p><img src="/2022/02/14/rust-lang/image-20220115142315424.png" alt="image-20220115142315424"></p><p>​    可以看到：先声明了俩不可变的引用，然后声明了一个可变引用。如果不对不可变引用做操作的话，不会报错。如果在声明了可变引用后，还对不可变引用进行操作，这样就会报错。</p><h2 id="4-5-切片"><a href="#4-5-切片" class="headerlink" title="4.5 切片"></a>4.5 切片</h2><p><img src="/2022/02/14/rust-lang/image-20220115144940387.png" alt="image-20220115144940387"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;ssss ssss&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">indx</span> = <span class="hljs-title function_ invoke__">get_space_index</span>(&amp;s);<br>    s.<span class="hljs-title function_ invoke__">clear</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, indx);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_space_index</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> p1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上面的代码是获取第一个空格所在的位置。</p><p>​    bug：当字符串被清空了后，得到的index不会发生改变，也就是同步性的问题。要保证：在字符串改变的同时，这个index也会同步改变。这很困难。</p><p>​    rust可以采用切片解决这个问题。</p><p><img src="/2022/02/14/rust-lang/image-20220115144751616.png" alt="image-20220115144751616"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;ssss ssss&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">indx</span> = <span class="hljs-title function_ invoke__">get_space_index</span>(&amp;s[..]);<br>    s.<span class="hljs-title function_ invoke__">clear</span>(); <span class="hljs-comment">//报错，这个方法会创建一个可变的引用，与上一行的不可变引用冲突 </span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, indx);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_space_index</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> p1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i]; <span class="hljs-comment">//[0, i)</span><br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    因为函数里面采用了字符串切片，也就是不可变引用，所以修改时报错。</p><p>​    注意：字符串切片仅仅针对UTF-8的字符，两字节的汉字会报错。</p><p>​    还做了一个优化，把字符串引用修改成为了字符串切片，这样就能同时接收两种类型了(&amp;String -&gt; &amp;str)。如字符串字面量（&amp;str）和String类型。</p><p>​    数组也可以切片，和上面类似。</p><h1 id="5-结构"><a href="#5-结构" class="headerlink" title="5 结构"></a>5 结构</h1><h2 id="5-1-结构定义"><a href="#5-1-结构定义" class="headerlink" title="5.1 结构定义"></a>5.1 结构定义</h2><p>​    三类：</p><ul><li>struct：普通结构</li><li>tuple struct：元组结构，当你想给元组起名字的时候，使用它。</li><li>Unit - like - struct：无任何字段的结构</li></ul><p>​    普通结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    active: <span class="hljs-type">bool</span>,<br>    id: <span class="hljs-type">u32</span>,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jack</span> = <span class="hljs-title function_ invoke__">get_user</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;jack&quot;</span>), String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;12222@qq.com&quot;</span>), <span class="hljs-literal">true</span>, <span class="hljs-number">1111</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jack.active);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_user</span>(name: <span class="hljs-type">String</span>, email: <span class="hljs-type">String</span>, active: <span class="hljs-type">bool</span>, id: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        name,<br>        email,<br>        active,<br>        id,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    元组结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-结构实例"><a href="#5-2-结构实例" class="headerlink" title="5.2 结构实例"></a>5.2 结构实例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = rectangle&#123;<br>        width: <span class="hljs-number">2</span>,<br>        length: <span class="hljs-number">3</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">get_area</span>(&amp;r1));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, r1);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_area</span>(rec: &amp;rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    rec.length * rec.width<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    Rust中有类似与java的toString方法，或者说是trait，但是默认没有实现，所以我们就用的是debug特性。</p><p><img src="/2022/02/14/rust-lang/image-20220115163757974.png" alt="image-20220115163757974"></p><ul><li>#[derive(Debug)]：实现debug trait</li><li>{:?}：输出结构的信息，不换行</li><li>{:#?}：输出结构的信息，换行</li></ul><h2 id="5-3-struct方法"><a href="#5-3-struct方法" class="headerlink" title="5.3 struct方法"></a>5.3 struct方法</h2><p>​    两种：</p><ul><li>方法：方法用impl定义的块去实现，需要传递它本身（或本身的引用）</li><li>关联函数：不需要传递本身，只是跟这个结构有关联，类似静态函数。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.length<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.length &gt;= other.length &amp;&amp; <span class="hljs-keyword">self</span>.width &gt;= other.width<br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sqare</span>(size: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> rectangle &#123;<br>        rectangle &#123;<br>            width: size,<br>            length: size,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">20</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = rectangle &#123;<br>        width: <span class="hljs-number">100</span>,<br>        length: <span class="hljs-number">20</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = rectangle &#123;<br>        width: <span class="hljs-number">10</span>,<br>        length: <span class="hljs-number">10</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r2.<span class="hljs-title function_ invoke__">area</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;r2));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;r3));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = rectangle::<span class="hljs-title function_ invoke__">sqare</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, r4);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-枚举与模式匹配"><a href="#6-枚举与模式匹配" class="headerlink" title="6 枚举与模式匹配"></a>6 枚举与模式匹配</h1><h2 id="6-1-定义枚举"><a href="#6-1-定义枚举" class="headerlink" title="6.1 定义枚举"></a>6.1 定义枚举</h2><p>​    rust的枚举很强大。可以自定义枚举并存储数据，不需要消耗额外的结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">home</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-number">120</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V6</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;::1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>​    枚举也可以定义方法。与结构体相同使用impl</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">express</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-2-Option枚举"><a href="#6-2-Option枚举" class="headerlink" title="6.2 Option枚举"></a>6.2 Option<T>枚举</T></h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span> &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;Sdssdffdsdsds&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n2</span>:<span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-match"><a href="#6-3-match" class="headerlink" title="6.3 match"></a>6.3 match</h2><p>​    math允许一个值与一系列的模式进行匹配，并执行匹配上的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Fir,<br>    <span class="hljs-title function_ invoke__">Fun</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Week</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_fun</span>(one_day: &amp;Week) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">match</span> one_day &#123;<br>            Week::<span class="hljs-title function_ invoke__">Fun</span>(statement) =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, statement);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            Week::Mon =&gt; <span class="hljs-literal">false</span>,<br>            Week::Fir =&gt; <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::<span class="hljs-title function_ invoke__">Fun</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;no need to work!!!&quot;</span>));<br>    Week::<span class="hljs-title function_ invoke__">is_fun</span>(&amp;day);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上面通过枚举存储了数据（String），并且通过模式匹配，将数据与statement绑定，重现了数据。</p><p>​    match必须列举所有的值进行匹配，若值太多了，使用_来代表其他的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>    <span class="hljs-title function_ invoke__">Fun</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Week</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_fun</span>(one_day: &amp;Week) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">match</span> one_day &#123;<br>            Week::<span class="hljs-title function_ invoke__">Fun</span>(statement) =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, statement);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            Week::Mon =&gt; <span class="hljs-literal">false</span>,<br>            Week::Fir =&gt; <span class="hljs-literal">false</span>,<br>            _ =&gt; <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-4-if-let语法糖"><a href="#6-4-if-let语法糖" class="headerlink" title="6.4 if-let语法糖"></a>6.4 if-let语法糖</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;this is Firday&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;nonono&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    等价于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Week</span> &#123;<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thi,<br>    Fir,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">day</span> = Week::Fir;<br>    <span class="hljs-keyword">match</span> day &#123;<br>        Week::Fir =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;this is Firday&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;nonono&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-package-crate-module"><a href="#7-package-crate-module" class="headerlink" title="7  package crate module"></a>7  package crate module</h1><p><img src="/2022/02/14/rust-lang/image-20220116100625209.png" alt="image-20220116100625209"></p><h2 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h2><p>​    自顶向下：</p><ul><li><p>Package：通过cargo可以创建一个新的包，位于最顶层。</p></li><li><p>Crate：cargo创建完包后，下面的.rs文件，有的会生成binary二进制文件（main.rs就是默认创建的binary文件，crate root），有的是产生library（其它的非main.rs文件）。Crate只能是以下两种类型：</p><ul><li>binary</li><li>library</li></ul></li><li><p>Module：在一个.rs文件中，可以定义多个module。</p></li><li><p>Path：</p></li></ul><p>​    还有一个概念叫crate root，是.rs源代码文件，编译器从这里开始组成我们的Module文件。</p><p>​    下面是Package的描述：</p><p><img src="/2022/02/14/rust-lang/image-20220116102055982.png" alt="image-20220116102055982"></p><p>​    crate可以把相关的功能整合到一个作用域内，还可以避免命名冲突。</p><p>​    Module是在一个crate内，将代码进行分组，可以复用，并且可以控制代码的权限（pub or pri）。mod还是可以嵌套的。</p><h2 id="7-2-权限"><a href="#7-2-权限" class="headerlink" title="7.2 权限"></a>7.2 权限</h2><p><img src="/2022/02/14/rust-lang/image-20220116103815978.png" alt="image-20220116103815978"></p><p>​    同级可以互相调用，父级不能调用子级的私有，子级可以调用所有父级的，无论暴露与否。外层mod加上了pub，里层的函数没加，函数依然是pri的。所以外面的mod里面的fn都需要加上pub才行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son_1 &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun1</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">mod</span> son_2 &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun2</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtt</span>() &#123;<br>    crate::father::son_1::<span class="hljs-title function_ invoke__">fun1</span>();<br>    crate::father::son_2::<span class="hljs-title function_ invoke__">fun2</span>(); <span class="hljs-comment">//报错，提示函数和mod都是私有的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    访问函数可以通过绝对路径和相对路径。建议绝对路径。</p><ul><li>绝对路径：<code>crate::father::son_1::fun1();</code></li><li>相对路径：<ul><li><code>father::son_1::fun1();</code></li><li>子级在调用父级的函数时，可以通过<code>super关键字</code></li></ul></li></ul><h2 id="7-3-结构的权限"><a href="#7-3-结构的权限" class="headerlink" title="7.3 结构的权限"></a>7.3 结构的权限</h2><p>​    结构默认为pri，并且结构的字段也是pri的，如果像设置乘公有的，加上pub</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>        <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_eat</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;is eating &#123;&#125; at &#123;&#125;.&#123;&#125;.&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.food, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">0</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">1</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">2</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">3</span>, <span class="hljs-keyword">self</span>.time.<span class="hljs-number">4</span>);<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtt</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">jack</span> = crate::father::eat &#123;<br>        time: (<span class="hljs-number">2022</span>, <span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>),<br>        food: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;kaoji&quot;</span>),<br>    &#125;;<br>    jack.<span class="hljs-title function_ invoke__">to_eat</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-枚举的权限"><a href="#7-4-枚举的权限" class="headerlink" title="7.4 枚举的权限"></a>7.4 枚举的权限</h2><p>​    枚举前面加上pub后，其里面的枚举变体自动变成公共的了。</p><h2 id="7-5-use的使用"><a href="#7-5-use的使用" class="headerlink" title="7.5 use的使用"></a>7.5 use的使用</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>​    针对函数，use一般时引用它的上一级mod，而不是直接引入到函数本身，这样增强代码的可读性，避免函数冲突了。</p><p>​    而针对结构struct，enum的话，就是引入到本身，而不是父级条目。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> father &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>            <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>            <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cry</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wawawawa&quot;</span>);<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">use</span> crate::father::son;<br><span class="hljs-keyword">use</span> crate::father::son::eat;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">testtttt</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = eat &#123;<br>        time: (<span class="hljs-number">2020</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>),<br>        food: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sasa&quot;</span>),<br>    &#125;;<br>    son::<span class="hljs-title function_ invoke__">cry</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    对于有同名的数据结构，有以下两种做法：</p><ul><li>像函数一样，引入到父级条目下就停止，不到该数据结构。</li><li>可以使用别名，用as，指定一个别名。</li></ul><p><img src="/2022/02/14/rust-lang/image-20220116121716763.png" alt="image-20220116121716763"></p><p>​    可以看到报错了。</p><p>​    可以写成如下:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = IoResult::<span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = FmtResult::<span class="hljs-literal">Ok</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h3><p>​    使用use导入mod后，这个mod对内部作用是可见的。而对如果外部去调用这个函数，对这个mod是没有访问权限的。所以这个时候可以使用pub use，这样这个模块对外部也是可见的了。</p><p>​    pub use 意思是重导出。</p><h2 id="7-6-特殊的use使用"><a href="#7-6-特殊的use使用" class="headerlink" title="7.6 特殊的use使用"></a>7.6 特殊的use使用</h2><ul><li>一次引入同一级下的多个包。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult;<br>-------<span class="hljs-punctuation">-&gt;</span><br><span class="hljs-keyword">use</span> std::&#123;<br>    io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult,<br>    fmt::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> FmtResult,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>用self代表它自身</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span>;<br><span class="hljs-keyword">use</span> std::io;<br>-------<span class="hljs-punctuation">-&gt;</span><br><span class="hljs-keyword">use</span> std::io::&#123;<br>    <span class="hljs-type">Result</span>,<br>    <span class="hljs-keyword">self</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>通过通配符*引入全部的包（不建议经常使用），一般用于 以下情况<ul><li>测试：将所有的公共条目引入测试test模块</li><li>预导入</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::*;<br></code></pre></td></tr></table></figure><h2 id="7-7-引入自己写的mod"><a href="#7-7-引入自己写的mod" class="headerlink" title="7.7 引入自己写的mod"></a>7.7 引入自己写的mod</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my_lib;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_lib::father::son::<span class="hljs-title function_ invoke__">cry</span>(); <span class="hljs-comment">//使用了my_lib.rs下的father模块中的son模块中的一个关联函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    如果mod的嵌套太多，可以创建一个新的同名文件夹，然后里面建立子mod的同名.rs文件。</p><p>​    可以用mod和use一起作用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//main.rs</span><br><span class="hljs-keyword">mod</span> my_lib;<br><span class="hljs-keyword">use</span> my_lib::father::son <span class="hljs-keyword">as</span> son;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    son::<span class="hljs-title function_ invoke__">cry</span>();<br>&#125;<br><br><span class="hljs-comment">//my_lib.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> father;<br><br><span class="hljs-comment">//my_lib\father.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> son &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">eat</span> &#123;<br>        <span class="hljs-keyword">pub</span> time: (<span class="hljs-type">u16</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>        <span class="hljs-keyword">pub</span> food: <span class="hljs-type">String</span>,<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cry</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wawawawa&quot;</span>);<br>        <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    树形结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">src<br>main.rs<br>my_lib.rs<br>my_lib<br>father.rs<br></code></pre></td></tr></table></figure><h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8 集合"></a>8 集合</h1><p>​    集和是建立在heap上的数据，因此在编译时不需要去确定大小，在运行时会自动变化。</p><h2 id="8-1-Vector"><a href="#8-1-Vector" class="headerlink" title="8.1 Vector"></a>8.1 Vector</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><p>​    有两种方式创建Vector</p><ul><li>通过关联函数，这种情况需要显示的指明类型。</li><li>通过已有的值来创建</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = <span class="hljs-built_in">vec!</span>[String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;first&quot;</span>)];<br>&#125;<br></code></pre></td></tr></table></figure><p>​    rust有上下文推断机制，如果前面没有明确Vec的类型，这时会报错；然后后面添加了元素，又能够自动推断出类型了，报错会消失。</p><h3 id="2-更新"><a href="#2-更新" class="headerlink" title="2.更新"></a>2.更新</h3><p>​    我们使用第一种方式创建Vector，并且向里面添加元素。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1i64</span>); <span class="hljs-comment">//64位有符号</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-清理"><a href="#3-清理" class="headerlink" title="3.清理"></a>3.清理</h3><p>​    一般而言，离开作用域后，Vector就会被OS调用drop给清理掉。</p><h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4.获取"></a>4.获取</h3><p>​    两种方法：</p><ul><li>索引：得到的是数据本身</li><li>get方法：得到的是Some(T)或者None，其中T是不可变引用。</li></ul><p>​    get更安全，可以对得到的数据进行类型判断，如果是Some就取出，是None就不取出，提示错误。</p><p>​    而索引的话，就会出现panic，程序恐慌。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">30i32</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span>: <span class="hljs-type">i32</span> = <span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">10000</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(n) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;get it: &#123;&#125;&quot;</span>, n);<br>            *n<br>        &#125;,<br>        <span class="hljs-literal">None</span> =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>            -<span class="hljs-number">1</span><br>        &#125;,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    因为Vec在heap上，所以有所有权的借用，用get得到的是引用，用索引的到的是本身。但是借用两边并不会报错（i32），<em>说明是存放在栈上的，copy和move都一样</em>。这个地方是错误的，因为i32实现的是copy trait，所以使用等号时会在栈上压栈一个相同的数据。自然不会有所有权的问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">30i32</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n2</span> = v[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">//并没有报错</span><br></code></pre></td></tr></table></figure><p>​    下面修改成String类型的试试。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//cannot move out of index of `std::vec::Vec&lt;std::string::String&gt;`</span><br><span class="hljs-comment">//move occurs because value has type `std::string::String`, which does not implement the `Copy` trait</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>]; <span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    错误信息如上。String没有实现copy trait，而是drop trait，如果操作成功，原来Vec里面对应位置的数据就会失效，所以只能采用借用，也就是用引用来获取。</p><p>​    而get默认的就是得到一个引用，用索引的话需要加上引用符号。</p><p>​    下面我们先通过索引加引用符号得到一个不可变引用，然后再添加一个元素进去，最后再打印这个不可变引用指向的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = &amp;v[<span class="hljs-number">0</span>];<br>    v.<span class="hljs-title function_ invoke__">push</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;   &quot;</span>)); <span class="hljs-comment">//这一行会报错</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, n1);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/14/rust-lang/image-20220116142000246.png" alt="image-20220116142000246"></p><p>​    原因是什么呢？</p><ul><li>不可变引用与可变引用不能同时存在。</li><li>Vec的机制，因为在堆上分配的空间，所以空间可能不足，需要重新分配空间，然后进行一个数据的迁移，最后释放掉原来那部分的空间。如果发生这种情况，上面获取的不可变引用，它的指向是不会改变的，这样就指向了一片空的内存，是不安全的。所以编译器不允许这样的情况发生。</li></ul><p>​    然后再次试了一下使用Vector存放i64，放很多数据。然后发生了栈溢出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/**memory allocation of 8589934592 bytes failed</span><br><span class="hljs-comment"> *error: process didn&#x27;t exit successfully: `target\debug\stdvector.exe` (exit code: 0xc0000409,          *STATUS_STACK_BUFFER_OVERRUN)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1i64</span>);<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2i64</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span> = v[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">1000000000000000000i64</span>) &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(num);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, n1);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    换成String也会发生溢出。</p><p>​    然后查阅了相关资料，确定Vec是存放在栈上的。</p><h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5.遍历"></a>5.遍历</h3><p>​    通过for循环遍历，通过解引用*更新。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>        *num = *num + <span class="hljs-number">50</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-enum-amp-vector"><a href="#8-2-enum-amp-vector" class="headerlink" title="8.2 enum &amp; vector"></a>8.2 enum &amp; vector</h2><p>​    存放时直接存放就行，取出时需要根据类型取出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">InputKind</span> &#123;<br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>        InputKind::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">32</span>),<br>        InputKind::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">3.22222</span>),<br>        InputKind::<span class="hljs-title function_ invoke__">Text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hhhh&quot;</span>)),<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-String类型"><a href="#8-3-String类型" class="headerlink" title="8.3 String类型"></a>8.3 String类型</h2><h3 id="1-创建字符串"><a href="#1-创建字符串" class="headerlink" title="1.创建字符串"></a>1.创建字符串</h3><p>​    两种方法：</p><ul><li>字符串无初值，使用new关联函数。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure><ul><li><p>字符串有初值：</p><ul><li>使用关联函数from</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hhh&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>使用to_String方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hhh&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(); <span class="hljs-comment">//这里的string是小写</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-更新-1"><a href="#2-更新-1" class="headerlink" title="2.更新"></a>2.更新</h3><p><img src="/2022/02/14/rust-lang/image-20220116152252174.png" alt="image-20220116152252174"></p><h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3.访问"></a>3.访问</h3><p>​    不支持索引访问，只能用切片来访问。</p><p>​    原因有两个：</p><ul><li>UTF8编码，一个Unicode值对应的字节数不是固定的。</li><li>索引操作应该消耗O(1)的时间复杂度，但是String无法保证。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello_world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, p);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-内部表示"><a href="#4-内部表示" class="headerlink" title="4.内部表示"></a>4.内部表示</h3><p>​    String时对Vec<u8>的包装，也就是一个可变字节数组。</u8></p><p>​    有一个len方法返回的是它的字节数。</p><p>​    String有一个大坑，String里面存储的是字节，但是字符都有它的Unicode标量值，一个Unicode值不一定就是一个字节。如下：</p><ul><li>汉字：1 Unicode – 3 Byte</li><li>英语：1 Unicode – 1 Byte</li><li>印度：1 Unicode – 2 Byte</li></ul><p>​    这个时候我们访问，用字符串切割也要看响应的场景了。</p><p>​    Rust里有三种看待字符串的方式（自底向上）：</p><ul><li>字节</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;नमस्ते&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">bytes</span>() &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &quot;</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//224 164 168 224 164 174 224 164 184 224 165 141 224 164 164 224 165 135 </span><br></code></pre></td></tr></table></figure><ul><li>标量值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;हेलो बास्टियन&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &quot;</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//न म स ् त े </span><br><span class="hljs-comment">//第四个和第六个是类似音调的东西，拆分开没有意义</span><br></code></pre></td></tr></table></figure><ul><li>字形簇：标准库里没有提供。</li></ul><h3 id="5-字符串切片的坑"><a href="#5-字符串切片的坑" class="headerlink" title="5.字符串切片的坑"></a>5.字符串切片的坑</h3><p>​    使用[min..max]来进行切片，从[min, max - 1]</p><p>​    如果切割的不是完整的Unicode编码，不会报错，但会发生恐慌</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;नमस्ते&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//thread &#x27;main&#x27; panicked at &#x27;byte index 1 is not a char boundary; it is inside &#x27;न&#x27; (bytes 0..3) of `नमस्ते`&#x27;, src\main.rs:3:14</span><br></code></pre></td></tr></table></figure><h3 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6.遍历"></a>6.遍历</h3><p>​    遍历在内部表示中提及。</p><h2 id="8-4-HashMap"><a href="#8-4-HashMap" class="headerlink" title="8.4 HashMap"></a>8.4 HashMap</h2><h3 id="1-创建及插入"><a href="#1-创建及插入" class="headerlink" title="1.创建及插入"></a>1.创建及插入</h3><ul><li>引入包</li><li>new创建</li><li>insert插入</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    map.<span class="hljs-title function_ invoke__">insert</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;001&quot;</span>), String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcy&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>​    HashMap是同构的，所有的key是一种类型，value也是一种类型</p><p>​    上面是常规的创建方法，还可以使用tuple来创建。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">12u8</span>, <span class="hljs-number">13u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = name.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(age.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    先创建两个Vector，然后用一个vec生成一个迭代器，再跟另外一个vec的迭代器进行一一映射。然后再用collect方法打包返回一个hashmap。</p><p>​    那个&lt;_, _&gt;是会自动推断的，但是不可以省去。</p><p>​    向HashMap中插入数据时，如果数据是实现了copy trait的话，数据会被复制一份。如果是是西安了drop trait的话，数据会被一觉，所有权也会转移，源数据也会失效。</p><p>​    但如果插入的是引用，就不会发生所有权的移交了。</p><p>​    下面是通过get获取map中的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = map.<span class="hljs-title function_ invoke__">get</span>(&amp;name[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(r) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>),<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//打印18</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = map.<span class="hljs-title function_ invoke__">get</span>(&amp;<span class="hljs-string">&quot;hhh&quot;</span>);<br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(r) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error&quot;</span>),<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//打印 error</span><br></code></pre></td></tr></table></figure><h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><p>​    使用元组tuple和for-each进行遍历</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;qcy&quot;</span>, <span class="hljs-string">&quot;qqccuy&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">18u8</span>, <span class="hljs-number">18u8</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;_, _&gt; = (&amp;name).<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>((&amp;age).<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-title function_ invoke__">for</span> (k, v) <span class="hljs-keyword">in</span> map &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, k, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h3><p>​    当向map中插入数据时，可能有三种情况：</p><ul><li><p>数据不存在，直接插入即可。</p></li><li><p>数据存在</p><ul><li>忽略原来的数据v，用新的v替换掉它 – insert()方法就是这样的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcy&quot;</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s, <span class="hljs-number">0u8</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s, <span class="hljs-number">99u8</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, m);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;qcy&quot;: 99&#125;</span><br></code></pre></td></tr></table></figure><ul><li>保留现在的v，忽略新的v – 使用entry来判断是否存在，用or_insert(v)方法来插入，如果k不存在，执行；存在，不执行。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qqcy&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;qcwdfg&quot;</span>);<br>    m.<span class="hljs-title function_ invoke__">insert</span>(&amp;s1, <span class="hljs-number">1u8</span>);<br>    m.<span class="hljs-title function_ invoke__">entry</span>(&amp;s2).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">122u8</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, m);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;qqcy&quot;: 1, &quot;qcwdfg&quot;: 122&#125;</span><br></code></pre></td></tr></table></figure><ul><li>合并旧的v和新的v – 还是使用or_insert(v)，来判断，若k存在会返回一个k的可变引用，可以对k进行修改。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span>: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">u32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;h h h h h a a x c v b g r e qw s f gf g h h &quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = text.<span class="hljs-title function_ invoke__">split_whitespace</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> res &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = map.<span class="hljs-title function_ invoke__">entry</span>((*i).<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br>        *num += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, map);<br>&#125;<br><span class="hljs-comment">//&#123;&quot;h&quot;: 7, &quot;b&quot;: 1, &quot;x&quot;: 1, &quot;r&quot;: 1, &quot;e&quot;: 1, &quot;f&quot;: 1, &quot;gf&quot;: 1, &quot;g&quot;: 2, &quot;s&quot;: 1, &quot;c&quot;: 1, &quot;qw&quot;: 1, &quot;v&quot;: 1, &quot;a&quot;: 2&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-Hash函数"><a href="#4-Hash函数" class="headerlink" title="4.Hash函数"></a>4.Hash函数</h3><p>​    一般默认情况下：</p><ul><li>可抵御Dos攻击 – 良好的安全性</li><li>并不是最快的 – 性能一般</li></ul><p>若是觉得性能不好，可以修改trait</p><h1 id="9-错误处理"><a href="#9-错误处理" class="headerlink" title="9.错误处理"></a>9.错误处理</h1><h2 id="1-不可恢复的错误与panic-宏"><a href="#1-不可恢复的错误与panic-宏" class="headerlink" title="1.不可恢复的错误与panic!宏"></a>1.不可恢复的错误与panic!宏</h2><p>​    大多编程语言在错误处理这方面提供了异常机制，没有对可恢复错误与不可恢复错误进行区分，而Rust没有异常机制，但他对错误处理进行了分类：</p><ul><li>可恢复错误：如文件找不到，可再次尝试<ul><li>使用Result&lt;T, E&gt;</li></ul></li><li>不可恢复错误：如Vec越界访问<ul><li>使用panic!宏进行处理</li></ul></li></ul><p>​    针对不可恢复的错误，我们有两种处理，展开或终止（abort）调用栈。</p><ul><li>展开调用栈：Rust沿着调用栈往回走，清理遇到每个函数中的数据。</li><li>终止调用栈：直接终止程序，不进行清理。但是需要由OS来清理。</li></ul><p>​    若想二进制文件更小，需要将默认的展开改成终止。</p><p>​    具体就是在cargo.toml中设置profile。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;paniccccccc&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang/.org/cargo/reference/manifest.html</span><br><br><span class="hljs-section">[dependencies]</span><br><br><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&#x27;abort&#x27;</span><br></code></pre></td></tr></table></figure><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2u8</span>];<br>    v[<span class="hljs-number">999</span>];<br>&#125;<br><span class="hljs-comment">//note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="hljs-comment">//通过set RUST_BACKTRACE=1 &amp;&amp; cargo run 进行栈回溯</span><br></code></pre></td></tr></table></figure><p>​    顺便再次复习一下，v.get(999)并不会报错，得到的返回值是None</p><h2 id="2-Result枚举与可恢复的错误"><a href="#2-Result枚举与可恢复的错误" class="headerlink" title="2.Result枚举与可恢复的错误"></a>2.Result枚举与可恢复的错误</h2><p>​    执行文件操作会返回一个Result的枚举变体，操作成功为Ok(T)，失败为Err(E)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, error);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    下面是针对不同的错误，通过match做的一些处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    fs::File,<br>    io::ErrorKind,<br>&#125;;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>() &#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(msg) =&gt; msg,<br>                <span class="hljs-title function_ invoke__">Err</span>(msg) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, msg),<br>            &#125;,<br>            OtherError =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, OtherError),<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-unwrap与expect替换match"><a href="#3-unwrap与expect替换match" class="headerlink" title="3.unwrap与expect替换match"></a>3.unwrap与expect替换match</h2><p>​    上面我们用了很多match，代码的可读性还行，但太臃肿了。</p><p>​    下面提供一种unwrap()方法。</p><p>​    使用unwrap打开文件</p><ul><li>如果文件不存在，程序恐慌</li><li>如果文件存在，返回文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用unwrap创建文件</p><ul><li>如果文件不存在，创建文件</li><li>如果文件存在，返回文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    但是有一个缺点，unwrap无法定位错误信息（所有unwrap返回的错误信息都是一样的），所以下面介绍expect</p><p>​    expect与unwrap一样，单数可以控制输出的错误信息，精确的定位到处错在哪一行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;出错啦&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-通过函数将错误返回"><a href="#4-通过函数将错误返回" class="headerlink" title="4.通过函数将错误返回"></a>4.通过函数将错误返回</h2><p>​    将函数的返回值设置为一个Result枚举类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123; <span class="hljs-comment">//file必须是可变的，因为会执行读这个操作。</span><br>        <span class="hljs-title function_ invoke__">Ok</span>(f) =&gt; f,<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e) <span class="hljs-comment">//直接作为函数返回值</span><br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">match</span> f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(s),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-语法糖：”-”"><a href="#5-语法糖：”-”" class="headerlink" title="5.语法糖：”?”"></a>5.语法糖：”?”</h2><p>​    ?：执行一个操作</p><ul><li>如果是Ok的话，就把Ok里的值作为结果绑定到变量。</li><li>如果是Err的话，就直接返回错误（注意main函数没有返回值，所以如果要使用”?”的话，需要加东西）。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path)?;<br>    <span class="hljs-comment">// let mut f = match f &#123; //file必须是可变的，因为会执行读这个操作。</span><br>    <span class="hljs-comment">//     Ok(f) =&gt; f,</span><br>    <span class="hljs-comment">//     Err(e) =&gt; return Err(e) //直接作为函数返回值</span><br>    <span class="hljs-comment">// &#125;;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-comment">// match f.read_to_string(&amp;mut s) &#123;</span><br>    <span class="hljs-comment">//     Ok(_) =&gt; Ok(s),</span><br>    <span class="hljs-comment">//     Err(e) =&gt; Err(e),</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    删掉注释后效果如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(path)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    非常精简。</p><p>​    然后再进行链式调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">read_text</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>));<br>    <span class="hljs-keyword">match</span> s &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(res) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, e),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_text</span>(path: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>    File::<span class="hljs-title function_ invoke__">open</span>(path)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-main函数中如何使用”-”运算符"><a href="#6-main函数中如何使用”-”运算符" class="headerlink" title="6.main函数中如何使用”?”运算符"></a>6.main函数中如何使用”?”运算符</h2><p>​    main的返回类型是()，也可以修改为Result，T对应的是()，E对应的是任意可能的错误类型（其实是一个trait对象7.）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;xxx.txt&quot;</span>)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-何时使用panic"><a href="#7-何时使用panic" class="headerlink" title="7.何时使用panic!"></a>7.何时使用panic!</h2><p>​    总体原则如下：</p><ul><li>尽量使用Result！将错误返回到代码的调用者，让他们决定如何去处理，如果我们觉得这个错误除了panic!，没有其它的解决办法，就直接使用panic!吧</li></ul><h1 id="10-泛型，trait，生命周期"><a href="#10-泛型，trait，生命周期" class="headerlink" title="10.泛型，trait，生命周期"></a>10.泛型，trait，生命周期</h1><h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h2><p>​    Rust对类型的命名采用的是驼峰命名而非蛇形命名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DogAnimal</span> &#123;<span class="hljs-comment">//...&#125;</span><br></code></pre></td></tr></table></figure><p>​    泛型的声明</p><ul><li>结构</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Good</span>&lt;X, Y&gt; &#123;<br>    name: X,<br>    msg: Y,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hhh</span>&lt;X&gt;() &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>枚举（Option<T> 和 Result&lt;T, E&gt;）</T></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法</li></ul><p>​    注：针对具体的方法，impl后不需要接收泛型。如果是泛型方法，那么就需要</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Good</span>&lt;X, Y&gt; &#123;<br>    name: X,<br>    msg: Y,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;X, Y&gt; Good&lt;X, Y&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name: X, msg: Y) <span class="hljs-punctuation">-&gt;</span> Good&lt;X, Y&gt;&#123;<br>        Good&#123;<br>            name,<br>            msg,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Good</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">speak</span>(<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    使用泛型并不会影响性能。因为Rust使用了<em><strong>单态化</strong></em>，也就是编译的时候会将具体的类型带入到泛型参数里去，从而在运行时不需要额外的开销。</p><h2 id="2-trait"><a href="#2-trait" class="headerlink" title="2.trait"></a>2.trait</h2><ul><li>类似于接口，告诉编译器哪些类型可以具有相同的功能。</li><li>还有一个trait bound的特性：要求传进来的泛型参数必须实现了对应的trait</li></ul><p>​    trait的产生和接口是类似的，有些不同的类型会实现相同的方法。所以我们就把这些方法提取出来，实现一个trait。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​    如下，只有方法签名，无具体实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Behavior</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat</span>(<span class="hljs-keyword">self</span>);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_money</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h3><p>my_lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Man</span> &#123;<br>        <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,<br>        <span class="hljs-keyword">pub</span> age: <span class="hljs-type">i8</span>,<br>        <span class="hljs-keyword">pub</span> money: <span class="hljs-type">i32</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Boy</span> &#123;<br>        <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,<br>        <span class="hljs-keyword">pub</span> age: <span class="hljs-type">i8</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Man</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>            <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;name is &#123;&#125;, age is &#123;&#125;, get money &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age, <span class="hljs-keyword">self</span>.money)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Boy</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>            <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;i am &#123;&#125;, age is &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> fanxingggggg::my_struct::&#123;<br>    Man,<br>    Boy,<br>&#125;;<br><span class="hljs-keyword">use</span> fanxingggggg::my_trait::Text;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Man &#123;<br>        name: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;father&quot;</span>),<br>        age: <span class="hljs-number">40</span>,<br>        money: <span class="hljs-number">100</span>,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Boy &#123;<br>        name: String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;boy&quot;</span>),<br>        age: <span class="hljs-number">18</span>,<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, m.<span class="hljs-title function_ invoke__">write</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b.<span class="hljs-title function_ invoke__">write</span>());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​    trait也可以使用默认实现，也就是在trait的定义时就实现trait。如果结构对trait的默认实现进行了重写的话，就不能再调用默认实现了。</p><h3 id="3-将trait作为参数"><a href="#3-将trait作为参数" class="headerlink" title="3.将trait作为参数"></a>3.将trait作为参数</h3><ul><li>参数类型为iml trait</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun1</span>(object: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Text</span> + Display) &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用trait bound</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;T: Text + Display&gt;(o: T) &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在返回类型后使用where</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_struct &#123;<br>    <span class="hljs-keyword">use</span> std::fmt::Display;<br>    <span class="hljs-keyword">use</span> crate::my_trait::Text;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;T&gt;(o: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">where</span> T: Text + <span class="hljs-built_in">Clone</span> + Display,<br>    &#123;<br>        String::<span class="hljs-title function_ invoke__">new</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> my_trait &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Text</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h2><p>​    定义：让引用保持有效的作用域。</p><p>​    Rust有一个东西叫做借用检查器。会在编译的时候比较两个引用的生命周期的长短。</p><h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1.简单使用"></a>1.简单使用</h3><p>​    当你写了一个函数时，向里面传了多个引用，然后对其进行一系列操作，最后返回一个引用时。需要用到生命周期。</p><p>​    因为编译器需要确保传进来的生命周期，与传出去的生命周期一样，或者说大于。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">&quot;hello world!&quot;</span>; <span class="hljs-comment">//5</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sss&quot;</span>); <span class="hljs-comment">//3</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = <span class="hljs-title function_ invoke__">get_longer</span>(&amp;s1, &amp;s2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;res);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_longer</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s1: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, s2: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> s1.<span class="hljs-title function_ invoke__">len</span>() &gt; s2.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        s1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        s2<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    目的检查非法调用。</p><p>​    实际返回结果的生命周期是两个参数中生命周期较小的那一个。</p><p>​    我们看下面这个错误调用。</p><p><img src="/2022/02/14/rust-lang/image-20220119202214447.png" alt="image-20220119202214447"></p><p><img src="/2022/02/14/rust-lang/image-20220119202225682.png" alt="image-20220119202225682"></p><p>​    通过函数，res的生命这些周期被缩短到和s2一样了。这样在外部继续调用的话，就会发生错误。</p><p>​    再试试Java里的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.reptile;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestD</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br>        String res;<br>        &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sss&quot;</span>;<br>            res = s2;<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    res的值和s2是一样的，这意味着s2并没有被GC回收掉。</p><h3 id="2-函数的生命周期"><a href="#2-函数的生命周期" class="headerlink" title="2.函数的生命周期"></a>2.函数的生命周期</h3><p>​    函数的返回值的生命周期跟输入的参数的生命周期有关。</p><p>​    如果要返回一个引用，需要确保这个引用不会被回收（即不是本地变量）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s1: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, s2: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &amp;s <span class="hljs-comment">//报错，returns a reference to data owned by the current function</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    返回的引用指向的堆已经被drop掉了，所以不行。这个引用叫悬垂指针。在Rust里，只要提供了足够的信息（生命周期），就不会发生这种情况。</p><p>​    如果想要使用在函数里的变量，建议返回一个String，移交所有权，而不是返回一个引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(arg: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Config, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> arg.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">3</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;arguments counts not good, find &#123;&#125;, need 2&quot;</span>, arg.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = &amp;arg[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = &amp;arg[<span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">Ok</span>(<br>        Config &#123;<br>            query: p1,<br>            file_path: p2,<br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-struct的生命周期"><a href="#3-struct的生命周期" class="headerlink" title="3.struct的生命周期"></a>3.struct的生命周期</h3><p>​    与函数类似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Man</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    name: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这里生命周期的意思是：字段存活的时间必须比结构久，不然的话字段先被回收了，结构还在，就会发生内存泄漏。</p><p>​    即绑定给name的数据的生命周期的存活时间必须要覆盖这个结构的生命周期。</p><h3 id="4-生命周期省略的规则"><a href="#4-生命周期省略的规则" class="headerlink" title="4.生命周期省略的规则"></a>4.生命周期省略的规则</h3><ul><li>每个引用类型的参数都有自己的生命周期</li><li>如果只有一个输入生命周期参数，那么这个生命周期参数将被赋给输出生命周期参数</li><li>如果有多个输入生命周期参数，但是其中之一是<code>&amp;self or &amp;mut self</code>，那么self的生命周期将被赋给输出生命周期参数。</li></ul><h3 id="5-静态生命周期"><a href="#5-静态生命周期" class="headerlink" title="5.静态生命周期"></a>5.静态生命周期</h3><p>​    静态生命周期用&#96;static，表示，意思是比那辆的存活时间和程序的存活时间是一致的。也就是说编译器在编译的时候就把这一部分作为二进制值写进去了。</p><p>​    只有实现了copy trait的变量才可以声明static</p><h1 id="11-测试"><a href="#11-测试" class="headerlink" title="11.测试"></a>11.测试</h1><p>​    测试三个步骤，3A</p><ul><li><em><strong>准备数据</strong></em> </li><li><em><strong>运行测试代码</strong></em></li><li><em><strong>断言结果</strong></em></li></ul><h2 id="1-编写测试"><a href="#1-编写测试" class="headerlink" title="1.编写测试"></a>1.编写测试</h2><p>​    在函数的上方加上 属性（aattribute）<code>#[test]</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-运行测试"><a href="#2-运行测试" class="headerlink" title="2.运行测试"></a>2.运行测试</h2><p>​    使用cargo test命令</p><h2 id="3-断言的作用"><a href="#3-断言的作用" class="headerlink" title="3.断言的作用"></a>3.断言的作用</h2><h3 id="1-assert"><a href="#1-assert" class="headerlink" title="1.assert!"></a>1.assert!</h3><p>​    断定此处为true！</p><p>​    可以接收一个bool类型，true通过，false则panic</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#[test]</span><br><span class="hljs-function">fn <span class="hljs-title">ppp</span>()</span> &#123;<br>    <span class="hljs-keyword">let</span> f = <span class="hljs-literal">false</span>;<br>    assert!(f);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-assert-eq"><a href="#2-assert-eq" class="headerlink" title="2.assert_eq!"></a>2.assert_eq!</h3><p>​    断定两个同类型的变量相等！</p><p>​    比如下面的assert_eq!，就是表明括号里面传入的参数肯定相等，不然就会报错。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    还可以接收字符串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(result, String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-assert-ne"><a href="#3-assert-ne" class="headerlink" title="3.assert_ne!"></a>3.assert_ne!</h3><p>​    与assert eq相反，ne的意思是not eq</p><h3 id="4-给断言添加自定义消息"><a href="#4-给断言添加自定义消息" class="headerlink" title="4.给断言添加自定义消息"></a>4.给断言添加自定义消息</h3><p>​        其实assert宏还有另外一个参数，可以传递字符串，而事实上这个字符串最终会传递给format宏。所以这个字符串里面可以添加占位符{}，并且后面可以带参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i1</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i2</span> = <span class="hljs-number">12</span>;<br>    <span class="hljs-built_in">assert_eq!</span>(i1, i2, <span class="hljs-string">&quot;&#123;&#125; is not eq &#123;&#125;&quot;</span>, i1, i2);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-属性should-panic"><a href="#4-属性should-panic" class="headerlink" title="4.属性should_panic"></a>4.属性should_panic</h2><p>​    在测试下面，函数上面再添加一条属性（attribute），叫<code>#[should_panic]</code></p><p>​    表示下面的测试函数应该恐慌，不恐慌测试就不会通过。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-meta">#[should_panic]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hello should_panic&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    可以通过在should_panic(expected &#x3D; “”)添加参数，让测试更加精确一点。如添加了字符串参数，然后如果恐慌信息里包含了这个expected参数，那么就测试通过；反之，如果不包含，那么测试失败。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-meta">#[should_panic(expected = <span class="hljs-string">&quot;hello&quot;</span>)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;hello should_panic&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-使用Result枚举来进行测试"><a href="#5-使用Result枚举来进行测试" class="headerlink" title="5.使用Result枚举来进行测试"></a>5.使用Result枚举来进行测试</h2><p>​    无需panic。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Err</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;not eq&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="12-命令行项目"><a href="#12-命令行项目" class="headerlink" title="12.命令行项目"></a>12.命令行项目</h1><p>​    实现这样的功能：通过命令行，向程序中输入参数，一个是字符串，一个是文件绝对路径。然后找到这个绝对路径中跟字符串内容匹配的部分，并且打印出来。</p><h2 id="1-接收命令行参数"><a href="#1-接收命令行参数" class="headerlink" title="1.接收命令行参数"></a>1.接收命令行参数</h2><p>​    使用std::env下的args接收参数，并调用collect方法，返回一个Vec</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-comment">// let p1 = &amp;v[0];</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, v);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-读取文件内容"><a href="#2-读取文件内容" class="headerlink" title="2.读取文件内容"></a>2.读取文件内容</h2><p>​    使用std::fs下的read _to_string 来读取，会返回一个result，所以我们调用except来处理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: python</span><br><span class="hljs-comment">path: C:\Users\User\Desktop\Typora快捷键.txt</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = &amp;v[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = &amp;v[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = std::fs::<span class="hljs-title function_ invoke__">read_to_string</span>(path).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, content);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-代码重构"><a href="#3-代码重构" class="headerlink" title="3.代码重构"></a>3.代码重构</h2><p>​    遵循一个函数一个功能的原则，main函数现在太臃肿了。</p><p>​    选择将main.rs拆分成main.rs和lib.rs，将业务逻辑的实现放在libl里。</p><p>​    具体如下：</p><ul><li>在main.rs里编写全部功能，可以忽略重构，忽略错误处理，只考虑理想情况。</li><li>将实现功能的业务逻辑抽取出来，独立成单个的函数。</li><li>在函数中进行错误处理，或者返回一个Result让main去处理。</li><li>最后将抽取出来的函数移动到lib里去</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;env, fs, process&#125;;<br><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> cmdddddd::&#123;Config, run&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: python</span><br><span class="hljs-comment">path: C:\Users\User\Desktop\Typora快捷键.txt</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">config</span> = Config::<span class="hljs-title function_ invoke__">new</span>(&amp;v).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error_msg| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;problem happened: &#123;&#125;&quot;</span>, error_msg);<br>        process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;);<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(&amp;config) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; (),<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;got some problem； &#123;:#?&#125;&quot;</span>, err);<br>            process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(config: &amp;Config) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">query</span> = config.<span class="hljs-title function_ invoke__">query</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = config.<span class="hljs-title function_ invoke__">file_path</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(path)?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,content);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    query: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>    file_path: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Config&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(arg: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Config, <span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> arg.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;arguments counts not good, find &#123;&#125;, need 2&quot;</span>, arg.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = &amp;arg[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = &amp;arg[<span class="hljs-number">2</span>];<br>        <span class="hljs-title function_ invoke__">Ok</span>(<br>            Config &#123;<br>                query: p1,<br>                file_path: p2,<br>            &#125;<br>        )<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">query</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.query<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">file_path</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.file_path<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-使用TDD在lib里进行查错"><a href="#4-使用TDD在lib里进行查错" class="headerlink" title="4.使用TDD在lib里进行查错"></a>4.使用TDD在lib里进行查错</h2><p>​    TDD：test driver development，测试驱动开发</p><p><img src="/2022/02/14/rust-lang/image-20220120223838199.png" alt="image-20220120223838199"></p><p>​    测试部分</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">to_test</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-string">&quot;\n</span><br><span class="hljs-string">hi,\n</span><br><span class="hljs-string">rust-langn</span><br><span class="hljs-string">demo demo dododododod\n</span><br><span class="hljs-string">hello \n</span><br><span class="hljs-string">hhh\n</span><br><span class="hljs-string">s\n</span><br><span class="hljs-string">hhh\n</span><br><span class="hljs-string">hhh hanpi\n</span><br><span class="hljs-string">en\n&quot;</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">query</span> = <span class="hljs-string">&quot;hhh&quot;</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;demo demo dododododod&quot;</span>], <span class="hljs-title function_ invoke__">search</span>(<span class="hljs-string">&quot;demo&quot;</span>, content));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    被测试的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(query: &amp;<span class="hljs-type">str</span>, content: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lines</span> = content.<span class="hljs-title function_ invoke__">lines</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> lines &#123;<br>        <span class="hljs-keyword">if</span> line.<span class="hljs-title function_ invoke__">contains</span>(query) &#123;<br>            res.<span class="hljs-title function_ invoke__">push</span>(line);<br>        &#125;<br>    &#125;<br>    res<br>&#125;<br></code></pre></td></tr></table></figure><p>​        以后使用TDD来进行测试。测试样例与功能实现分离开。</p><h2 id="5-使用环境变量进行选择"><a href="#5-使用环境变量进行选择" class="headerlink" title="5.使用环境变量进行选择"></a>5.使用环境变量进行选择</h2><p>​    方法如下：</p><p>​    程序中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">flag</span> = std::env::<span class="hljs-title function_ invoke__">var</span>(<span class="hljs-string">&quot;IGNORE_CASE&quot;</span>);<br></code></pre></td></tr></table></figure><p>​    命令行中：IGNORE_CASE &#x3D; 1 cargo run</p><p>​    这样就可以在程序中读到环境变量了。</p><h2 id="6-进行错误信息定向输出"><a href="#6-进行错误信息定向输出" class="headerlink" title="6.进行错误信息定向输出"></a>6.进行错误信息定向输出</h2><p>​    我们可以使用cargo run &gt; output.txt 运行使得通过println!输出的内容定向到output.txt里面。</p><p>​    但是这样错误信息也输出到output里了。</p><p>​    可以使用eprintln!，将错误信息定向到控制台输出。</p><h1 id="13-迭代器-闭包"><a href="#13-迭代器-闭包" class="headerlink" title="13.迭代器 闭包"></a>13.迭代器 闭包</h1><h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h2><h3 id="1-闭包的定义"><a href="#1-闭包的定义" class="headerlink" title="1 闭包的定义"></a>1 闭包的定义</h3><p>​    定义：可以捕获其所在环境的匿名函数。</p><p>​    闭包是一个匿名函数，他是将一个函数的定义存放在一个变量中去，而不是函数的执行结果。这个闭包只有在遇到向里面传输参数的时候，才会去执行函数，得到返回结果。</p><p>​    闭包并不需要显式声明它的参数和返回值类型。因为闭包是在当前作用域内工作的，范围狭小，不是作为接口去调用的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ggg</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bi_bao</span> = |num| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the num is &#123;&#125;&quot;</span>, num);<br>        num<br>    &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, <span class="hljs-title function_ invoke__">bi_bao</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">//调用bi_bao(3)的时候才是会真正执行闭包</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    将闭包绑定给变量后，变量的类型就是：<code>variable bi_bao: fn(&lt;unknown&gt;) -&gt; &lt;unknown&gt;</code></p><h3 id="2用结构来存储闭包"><a href="#2用结构来存储闭包" class="headerlink" title="2用结构来存储闭包"></a>2用结构来存储闭包</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cashe</span>&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    calculation: T,<br>    value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Cashe&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span><br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> Cashe&lt;T&gt; &#123;<br>        Cashe &#123;<br>            calculation,<br>            value: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, num: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.value &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(n) =&gt; n,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = (<span class="hljs-keyword">self</span>.calculation)(num);<br>                <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(res);<br>                res<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = Cashe::<span class="hljs-title function_ invoke__">new</span>(|num| num + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">32</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">92</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>​    上面结构中的calculation，是一个泛型参数T，并且加上了限制，要求这个泛型参数是实现了Fn trait的一个闭包。</p><p>​    但是只能存储一次。</p><p>​    可以用hashmap来进行改进。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cashe</span>&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    calculation: T,<br>    value: HashMap&lt;<span class="hljs-type">u32</span>, <span class="hljs-type">u32</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Cashe&lt;T&gt;<br>    <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span><br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> Cashe&lt;T&gt; &#123;<br>        Cashe &#123;<br>            calculation,<br>            value: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, num: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span> = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.value;<br>        <span class="hljs-keyword">match</span> map.<span class="hljs-title function_ invoke__">get</span>(&amp;num) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(res) =&gt; *res,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = (<span class="hljs-keyword">self</span>.calculation)(num);<br>                map.<span class="hljs-title function_ invoke__">insert</span>(num, res);<br>                res<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = Cashe::<span class="hljs-title function_ invoke__">new</span>(|num| num + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">32</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s.<span class="hljs-title function_ invoke__">value</span>(<span class="hljs-number">92</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-使用闭包捕获外部变量"><a href="#3-使用闭包捕获外部变量" class="headerlink" title="3.使用闭包捕获外部变量"></a>3.使用闭包捕获外部变量</h3><p>​    闭包可以捕获和他定义于同一个作用域的变量。这是闭包独有的功能，而函数是没有的。</p><p>​    但是会产生额外的内存开销。</p><h3 id="4-闭包的trait"><a href="#4-闭包的trait" class="headerlink" title="4.闭包的trait"></a>4.闭包的trait</h3><ul><li>Fn            不可变借用</li><li>FnMut    可变借用</li><li>FnOnce   取得所有权</li></ul><p><img src="/2022/02/14/rust-lang/image-20220121151726938.png" alt="image-20220121151726938"></p><p>​    可以使用move关键字将闭包外的所有权强行移动到闭包内。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bb</span> = <span class="hljs-keyword">move</span> ||v; <span class="hljs-comment">//移动所有权</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, v); <span class="hljs-comment">//这一行报错</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2.迭代器"></a>2.迭代器</h2><h3 id="1-iterator-trait"><a href="#1-iterator-trait" class="headerlink" title="1.iterator trait"></a>1.iterator trait</h3><p>​    实现next方法即可。</p><h3 id="2-几个迭代api"><a href="#2-几个迭代api" class="headerlink" title="2.几个迭代api"></a>2.几个迭代api</h3><ul><li>iter：在不可变引用上创建迭代器</li><li>into_iter：创建的迭代器会获取所有权 – 用一个数据引出迭代器，并且夺取了元数据的所有权。</li><li>iter_mut：迭代可变的引用 – 可以通过解引用修改其中的值。</li></ul><h3 id="3-消耗-x2F-产生-迭代器"><a href="#3-消耗-x2F-产生-迭代器" class="headerlink" title="3.消耗&#x2F;产生 迭代器"></a>3.消耗&#x2F;产生 迭代器</h3><h4 id="1-消耗（消耗性适配器）"><a href="#1-消耗（消耗性适配器）" class="headerlink" title="1.消耗（消耗性适配器）"></a>1.消耗（消耗性适配器）</h4><p>​    消耗迭代器：当调用迭代器的next方法时，会消耗迭代器，迭代器中的元素会被一个一个消除掉，这就是叫消耗的原因。rust里有些方法（针对于实现了iterator trait的类型），会自主调用next，从而消耗迭代器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iterator</span> = v.<span class="hljs-title function_ invoke__">iter</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span>: <span class="hljs-type">i32</span> = iterator.<span class="hljs-title function_ invoke__">sum</span>(); <span class="hljs-comment">//sum消耗了迭代器</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/14/rust-lang/image-20220122155108279.png" alt="image-20220122155108279"></p><p>​    要调用sum这个方法，self必须实现Sizd这个trait，并且泛型参数必须实现了Sum这个trait。 </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.Sized trait: 要求这个类型必须有固定的长度，如i32，u32</span><br><span class="hljs-comment">2.Sum trait：可以进行求和</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="2-产生（迭代器适配器）"><a href="#2-产生（迭代器适配器）" class="headerlink" title="2.产生（迭代器适配器）"></a>2.产生（迭代器适配器）</h4><p>​    将一个迭代器转换成另一个迭代器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iter1</span> = v1.<span class="hljs-title function_ invoke__">iter</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">map</span> = iter1.<span class="hljs-title function_ invoke__">map</span>(|num| &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num)<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = map.<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">iter2</span> = v2.<span class="hljs-title function_ invoke__">iter</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    map()方法：一个泛型方法，接收两个泛型参数，目的是将传进来的类型T更改成传出去的类型F。接收两个参数，第一个是self，要求实现了Sized这个trait。第二个参数是T，要求实现FnMut这个trait，也就是一个闭包，并且是可变引用，因为要对参数进行修改。</p><p>​    调用map方法后，迭代器的所有权被Move。</p><h4 id="3-迭代器-闭包-捕获环境"><a href="#3-迭代器-闭包-捕获环境" class="headerlink" title="3.迭代器+闭包 捕获环境"></a>3.迭代器+闭包 捕获环境</h4><p>​    使用filter()这个方法，一个迭代器适配器。接收一个闭包，这个闭包必须返回bool类型。若是返回true，则元素被加到迭代器里，最终作为这个方法的返回值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        v.<span class="hljs-title function_ invoke__">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i1</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|num| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        **num &gt; <span class="hljs-number">90</span><br>    &#125;).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, i1);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    传进闭包后，要用collect进行收集,返回一个集合，不然闭包是不会执行的</p><h4 id="4-构建自定义的迭代器"><a href="#4-构建自定义的迭代器" class="headerlink" title="4.构建自定义的迭代器"></a>4.构建自定义的迭代器</h4><p>​    实现Iterator trait即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">e1</span> = Elem::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e1.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Elem</span> &#123;<br>    val: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Elem</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Elem &#123;<br>        Elem &#123;<br>            val: <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Elem</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">i32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    迭代器比for循环遍历要快一点。</p><p>​    用filter方法。</p><h1 id="14-发布"><a href="#14-发布" class="headerlink" title="14.发布"></a>14.发布</h1><h1 id="15-智能指针"><a href="#15-智能指针" class="headerlink" title="15.智能指针"></a>15.智能指针</h1><h2 id="1-Box-lt-T-gt"><a href="#1-Box-lt-T-gt" class="headerlink" title="1.Box&lt; T &gt;"></a>1.Box&lt; T &gt;</h2><p>​    Rust中所有的类型在编译时都会知道大小。</p><p>​    考虑C语言中的链表的实现，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> value;<br>    Node* next;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    有两个类型，一个是int，一个是指针。这实际就是一个递归，只不过递归的是指针，并不是结构，如果是结构的话，就永远无法知道声明一个struct的时候应该分配多少大小了。所以用的是指针。指针存放在栈上，就是一个地址而已。</p><p>​    rust也是类似的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l</span> = Node &#123;<br>        value: <span class="hljs-number">1</span>,<br>        next: <span class="hljs-title function_ invoke__">Some</span>(Box::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>            value: <span class="hljs-number">2</span>,<br>            next: <span class="hljs-literal">None</span>,<br>        &#125;))<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>, l);<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>    next: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    Box这个类型就是一个智能指针，实现了两个trait，deref的目的是确保Box可以被当成一个引用实现；drop则是确保Box在离开作用域时，其指针（栈内存）和指向的数据（堆内存）都会被释放。</p><p><img src="/2022/02/14/rust-lang/image-20220123150617915.png" alt="image-20220123150617915"></p><h2 id="2-deref-trait"><a href="#2-deref-trait" class="headerlink" title="2.deref trait"></a>2.deref trait</h2><h3 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h3><p>​    实现这个trait后，可以确保类型被当成引用来使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Box::<span class="hljs-title function_ invoke__">new</span>(n);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, n);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, *m);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-实现Deref-trait"><a href="#2-实现Deref-trait" class="headerlink" title="2.实现Deref trait"></a>2.实现Deref trait</h3><p>​    给结构实现deref trait即可。</p><p>​    具体的话，就是指定一下类型，然后实现deref方法即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(m, *n);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt;(T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-deref-coercion"><a href="#3-deref-coercion" class="headerlink" title="3.deref coercion"></a>3.deref coercion</h3><p>​    假设实现了deref trait，然后传入的是引用，那么编译器就会自动调用deref方法，将&amp;Box<T> -&gt; &amp;T。</T></p><p>​    如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-title function_ invoke__">fun</span>(&amp;a);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>(s: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    首先将&amp;MyBox<String> -&gt; &amp;String，由于String类型实现了deref trait，所以 &amp;String -&gt; &amp;str，所以参数就匹配了。</String></p><p>​    并且，所有的这些操作，都是在编译期完成的，不会产生额外的运行时性能开销。</p><h2 id="3-drop-trait"><a href="#3-drop-trait" class="headerlink" title="3.drop trait"></a>3.drop trait</h2><p>​    变量在离开作用域时，会自动调用drop方法，来释放相关的资源。</p><p>​    不可以提前调用drop trait的drop方法，但是可以提前释放资源，使用另外一个drop方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-title function_ invoke__">drop</span>(s);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Rc-lt-T-gt"><a href="#4-Rc-lt-T-gt" class="headerlink" title="4.Rc&lt; T &gt;"></a>4.Rc&lt; T &gt;</h2><p>​    引用计数智能指针</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;s1)); <span class="hljs-comment">//2</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;s1)); <span class="hljs-comment">//3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    为什么要有Rc<T>？</T></p><p>​    把Box<T>传进去之后，Box会夺取T的所有权，所以如果还想复用T的话，或者是在别的地方传入Box<T>，那么就会报错，因为T已经被移动了。</T></T></p><p>​    使用Rc就不一样了，如果函数接收的是Rc<T>，那么传入Rc::clone(&amp;T)就可以了，这个clone函数并不会深拷贝，只是增加引用计数，返回一个Rc<T>。</T></T></p><p>​    使用了Rc<T>，就相当于单个值有了多个所有者。</T></p><p>​    Rc使用的是不可变引用，如果是可变引用就会违反引用规则。并且，Rc只能在单线程下使用。</p><h2 id="5-RfCell-lt-T-gt"><a href="#5-RfCell-lt-T-gt" class="headerlink" title="5.RfCell&lt; T &gt;"></a>5.RfCell&lt; T &gt;</h2><p><img src="/2022/02/14/rust-lang/image-20220123172820248.png" alt="image-20220123172820248"></p><h1 id="16-并发"><a href="#16-并发" class="headerlink" title="16.并发"></a>16.并发</h1><h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><p>​    创建线程的两种方式：</p><ul><li>通过OS的api来创建 – 运行时小 – 1  : 1</li><li>语言自己实现的线程 – 运行时大 – M : N</li></ul><p>​    Rust提供的是1:1线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread: &#123;&#125;&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;main: &#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这样写，一旦主线程结束了，我们创建的线程也就停止了。可以通过join方法来阻塞主线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread: &#123;&#125;&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;main: &#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br><br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">//只有j的线程结束后，才会恢复主线程的执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    可以使用move将主线程里的值的所有权强制移动到分线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> v &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>        &#125;<br>    &#125;);<br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-通过channel实现线程通信"><a href="#2-通过channel实现线程通信" class="headerlink" title="2.通过channel实现线程通信"></a>2.通过channel实现线程通信</h2><p>​    通过mpsc的一个关联函数可以构造一个元组（send, receive）</p><p>​    mpsc的意思：多个生产者，一个消费者。multiple producer， single consumer</p><p>​    可以通过克隆来实现多个发送者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (send, receive) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">send1</span> = send.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ss</span> = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> ss &#123;<br>            send.<span class="hljs-title function_ invoke__">send</span>(s).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">j1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ss</span> = [<span class="hljs-string">&quot;111hello&quot;</span>, <span class="hljs-string">&quot;111world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>, <span class="hljs-string">&quot;111from&quot;</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> ss &#123;<br>            send1.<span class="hljs-title function_ invoke__">send</span>(s).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">r</span> <span class="hljs-keyword">in</span> receive &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r);<br>    &#125;<br>    j.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    j1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Mutex-lt-T-gt-共享内存"><a href="#3-Mutex-lt-T-gt-共享内存" class="headerlink" title="3.Mutex&lt; T &gt;共享内存"></a>3.Mutex&lt; T &gt;共享内存</h2><p>​        Mutex就是一个互斥锁，使用数据前需要先获取锁，然后使用完后需要释放锁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;mpsc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = n.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num = <span class="hljs-number">7</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="hljs-comment">//n从5到7</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    mutex可能会产生死锁</p><h2 id="4-Arc-lt-T-gt-原子引用计数"><a href="#4-Arc-lt-T-gt-原子引用计数" class="headerlink" title="4.Arc&lt; T &gt;原子引用计数"></a>4.Arc&lt; T &gt;原子引用计数</h2><p>​    在外面克隆引用，然后把克隆的引用传进去。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, mpsc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">l1</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;n);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = l1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num += <span class="hljs-number">999</span>;<br>    &#125;);<br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, n); <span class="hljs-comment">//1004</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ceshi:</p><p><img src="/2022/02/14/rust-lang/image-20220214142148258.png" alt="image-20220214142148258"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/13/hello-world/"/>
    <url>/2022/02/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
